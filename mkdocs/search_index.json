{
    "docs": [
        {
            "location": "/index.html", 
            "text": "Introduction\n\n\n\n\n\n\n\n\nExperimental Boost.DI\n\n\n\n\n\n\n\n\n\n\n\n\nYour C++14 header only Dependency Injection library with no dependencies (\nTry it online!\n)\n\n\nGitHub\n\n\n\n\n\n\n\n\n\n\n Latest Release: \nv1.0.0\n (February 28, 2016)\n\n\n \nDownload\n \n \n \nChangelog\n \n \n \nTutorial\n \n \n \nExamples\n\n\n\n\n\nWhat is Dependency Injection?\n\n\n\n\n\"Don't call us, we'll call you\", Hollywood principle\n\n\n\n\nDependency Injection\n (DI)\n involves passing (injecting) one or more dependencies (or services) to a dependent object (or client) which become part of the client\u2019s state.\nIt is like the Strategy Pattern, except the strategy is set once, at construction. DI enables loosely coupled designs, which are easier to maintain and test.\n\n\n\n\n\"Let's make some coffee!\"\n\n\n\n\n\n\n                      No Dependency injection                 | Dependency Injection\n                      ----------------------------------------|-------------------------------------------\n                      class coffee_maker {                    | class coffee_maker {\n                      public:                                 | public:\n                          void brew() {                       |   coffee_maker(shared_ptr\niheater\n heater\n                              heater-\non();                   |              , unique_ptr\nipump\n pump)\n                              pump-\npump();                   |         : heater(heater), pump(move(pump))\n                              clog \n \ncoffee\n! \n endl;      |     { }\n                              heater-\noff();                  |\n                          }                                   |     void brew() {\n                                                              |         heater-\non();\n                      private:                                |         pump-\npump();\n                          shared_ptr\niheater\n heater =        |         clog \n \ncoffee!\n \n endl;\n                              make_shared\nelectric_heater\n(); |         heater-\noff();\n                                                              |     }\n                          unique_ptr\nipump\n pump =            |\n                              make_unique\nheat_pump\n(heater); | private:\n                      };                                      |     shared_ptr\niheater\n heater;\n                                                              |     unique_ptr\nipump\n pump;\n                                                              | };\n                                                              |\n\n\n\n\nDo I need Dependency Injection?\n\n\nReal Life examples?\n\n\n\n\nMatch-3 Game\n\n\nSimple game in C++14 using SDL2 / Model View Controller / Meta State Machine / Dependency Injection\n\n\n\n\n\n\n\n\n\n\n\n\nAutomatic Mocks Injector\n\n\nAutomatically create and inject required mocks to tested classes via constructors\n\n\n\n\n\n\n\n\n\n\n\n\nExperimental Boost.MSM-lite\n\n\nC++14 header only eUML-like Meta State Machine library with no dependencies\n\n\n\n\n\n\n\n\nWhy Dependency Injection?\n\n\n\n\nDI provides loosely coupled code (separation of business logic and object creation)\n\n\nDI provides easier to maintain code (different objects might be easily injected)\n\n\nDI provides easier to test code (fakes objects might be injected)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhy Boost.DI?\n\n\n\n\nBoost.DI has none or minimal run-time overhead - \nRun-time performance\n\n\nBoost.DI compiles fast - \nCompile-time performance\n\n\nBoost.DI gives short diagnostic messages - \nError messages\n\n\nBoost.DI is not intrusive\n\n\nBoost.DI reduces boilerplate code\n\n\nBoost.DI reduces testing effort\n\n\nBoost.DI gives better control of what and how is created\n\n\nBoost.DI gives better understanding about objects hierarchy\n\n\n\n\n\nBoost.DI design goals\n\n\n\n\nBe as fast as possible (see \nPerformance\n)\n\n\nCompile as fast as possible (see \nPerformance\n)\n\n\nGive short and intuitive error messages (see \nError messages\n)\n\n\nGuarantee object creation at compile-time (see \nPerformance\n)\n\n\nBe as non-intrusive as possible (see \nPerformance\n)\n\n\nBe easy to extend (see \nExtensions\n)\n\n\n\n\nAcknowledgements\n\n\n\n\nThanks to Bartosz Kalinczuk for code review and tips how to improve \nBoost.DI\n\n\nThanks to Sohail Somani for support and tips how to improve \nBoost.DI\n\n\nThanks to Rob Stewart and Robert Ramey for documentation feedback and tips how to improve it", 
            "title": "Introduction"
        }, 
        {
            "location": "/index.html#introduction", 
            "text": "Experimental Boost.DI       Your C++14 header only Dependency Injection library with no dependencies ( Try it online! )  GitHub", 
            "title": "Introduction"
        }, 
        {
            "location": "/index.html#what-is-dependency-injection", 
            "text": "\"Don't call us, we'll call you\", Hollywood principle   Dependency Injection  (DI)  involves passing (injecting) one or more dependencies (or services) to a dependent object (or client) which become part of the client\u2019s state.\nIt is like the Strategy Pattern, except the strategy is set once, at construction. DI enables loosely coupled designs, which are easier to maintain and test.   \"Let's make some coffee!\"                          No Dependency injection                 | Dependency Injection\n                      ----------------------------------------|-------------------------------------------\n                      class coffee_maker {                    | class coffee_maker {\n                      public:                                 | public:\n                          void brew() {                       |   coffee_maker(shared_ptr iheater  heater\n                              heater- on();                   |              , unique_ptr ipump  pump)\n                              pump- pump();                   |         : heater(heater), pump(move(pump))\n                              clog    coffee !   endl;      |     { }\n                              heater- off();                  |\n                          }                                   |     void brew() {\n                                                              |         heater- on();\n                      private:                                |         pump- pump();\n                          shared_ptr iheater  heater =        |         clog    coffee!    endl;\n                              make_shared electric_heater (); |         heater- off();\n                                                              |     }\n                          unique_ptr ipump  pump =            |\n                              make_unique heat_pump (heater); | private:\n                      };                                      |     shared_ptr iheater  heater;\n                                                              |     unique_ptr ipump  pump;\n                                                              | };\n                                                              |", 
            "title": "What is Dependency Injection?"
        }, 
        {
            "location": "/index.html#do-i-need-dependency-injection", 
            "text": "", 
            "title": "Do I need Dependency Injection?"
        }, 
        {
            "location": "/index.html#real-life-examples", 
            "text": "Match-3 Game  Simple game in C++14 using SDL2 / Model View Controller / Meta State Machine / Dependency Injection       Automatic Mocks Injector  Automatically create and inject required mocks to tested classes via constructors       Experimental Boost.MSM-lite  C++14 header only eUML-like Meta State Machine library with no dependencies", 
            "title": "Real Life examples?"
        }, 
        {
            "location": "/index.html#why-dependency-injection", 
            "text": "DI provides loosely coupled code (separation of business logic and object creation)  DI provides easier to maintain code (different objects might be easily injected)  DI provides easier to test code (fakes objects might be injected)", 
            "title": "Why Dependency Injection?"
        }, 
        {
            "location": "/index.html#why-boostdi", 
            "text": "Boost.DI has none or minimal run-time overhead -  Run-time performance  Boost.DI compiles fast -  Compile-time performance  Boost.DI gives short diagnostic messages -  Error messages  Boost.DI is not intrusive  Boost.DI reduces boilerplate code  Boost.DI reduces testing effort  Boost.DI gives better control of what and how is created  Boost.DI gives better understanding about objects hierarchy", 
            "title": "Why Boost.DI?"
        }, 
        {
            "location": "/index.html#boostdi-design-goals", 
            "text": "Be as fast as possible (see  Performance )  Compile as fast as possible (see  Performance )  Give short and intuitive error messages (see  Error messages )  Guarantee object creation at compile-time (see  Performance )  Be as non-intrusive as possible (see  Performance )  Be easy to extend (see  Extensions )", 
            "title": "Boost.DI design goals"
        }, 
        {
            "location": "/index.html#acknowledgements", 
            "text": "Thanks to Bartosz Kalinczuk for code review and tips how to improve  Boost.DI  Thanks to Sohail Somani for support and tips how to improve  Boost.DI  Thanks to Rob Stewart and Robert Ramey for documentation feedback and tips how to improve it", 
            "title": "Acknowledgements"
        }, 
        {
            "location": "/overview/index.html", 
            "text": "Quick Start\n\n\n\n\nGet \nboost/di.hpp\n header\n\n\n\n\nwget https://raw.githubusercontent.com/boost-experimental/di/master/include/boost/di.hpp\n\n\n\n\n\n\nInclude the header and define \ndi\n namespace alias\n\n\n\n\n#include \nboost/di.hpp\n\nnamespace di = boost::di;\n\n\n\n\n\n\nCompile with C++14 support\n\n\n\n\n$CXX -std=c++14 ...\n\n\n\n\n\n\nTo run tests\n\n\n\n\ngit clone https://github.com/boost-experimental/di \n cd di \n make test\n\n\n\n\nDependencies\n\n\n\n\nNo external dependencies are required (neither STL nor Boost)\n\n\n\n\nSupported/Tested compilers\n\n\n\n\nClang-3.4+\n\n\nGCC-5.2+\n\n\nMSVC-2015+\n\n\n\n\nConfiguration\n\n\n\n\n\n\n\n\nMacro\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBOOST_DI_VERSION\n\n\nCurrent version of Boost.DI (ex. 1'0'0)\n\n\n\n\n\n\nBOOST_DI_CFG\n\n\nGlobal configuration allows to customize provider and policies\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\nGives more information with error messages\n\n\n\n\n\n\nBOOST_DI_CFG_CTOR_LIMIT_SIZE\n\n\nLimits number of allowed consturctor parameters [0-10, default=10]\n\n\n\n\n\n\nBOOST_DI_NAMESPACE_BEGIN\n\n\nnamespace boost { namespace di { inline namespace v_1_0_0 {\n\n\n\n\n\n\nBOOST_DI_NAMESPACE_END\n\n\n}}}\n\n\n\n\n\n\n\n\nException Safety\n\n\n\n\nBoost.DI is not using exceptions internally and therefore might be compiled with \n-fno-exceptions\n.\n\n\nCheck \nUser Guide\n to verify which API's are marked \nnoexcept\n.\n\n\n\n\nThread Safety\n\n\n\n\nBoost.DI is thread safe.\n\n\n\n\nDesign\n\n\n\n\n\n\n\n\n\n\nComponent\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBindings\n\n\nDSL to create dependencies representation which will be used by core to resolve types\n\n\n\n\n\n\nScopes\n\n\nResponsible for maintain objects life time\n\n\n\n\n\n\nProviders\n\n\nResponsible for providing object instance\n\n\n\n\n\n\nPolicies\n\n\nCompile-time limitations for types / Run-time types vistor\n\n\n\n\n\n\nCore\n\n\nResponsible for resolving requested types (implementation detail)\n\n\n\n\n\n\nWrappers\n\n\nResponsible for conversion to required type (implementation detail)\n\n\n\n\n\n\n\n\nPerformance\n\n\n\n\nRun-time performance\n\n\nEnvironment\n\n\nx86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux\n\n\nclang++3.4 -O2 -fno-exceptions / \ngdb -batch -ex 'file ./a.out' -ex 'disassemble main'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCompile-time performance\n\n\nEnvironment\n\n\nx86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux\n\n\nclang++3.4 -O2 -fno-exceptions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBoost.DI header\n\n\nTime [s]\n\n\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\n0.050s\n\n\n\n\n\n\n\n\nLegend:\n    ctor    = raw constructor: c(int i, double d);\n    inject  = inject constructor: BOOST_DI_INJECT(c, int i, double d);\n    all     = all types exposed from module: auto configure();\n    exposed = one type exposed from module: di::injector\nc\n configure();\n\n\n\n\n\n\n* 4248897537 instances created\n* 132 different types\n* 10 modules\n\n\n\n\n\n\n\n\n* 1862039751439806464 instances created\n* 200 different types\n* 10 modules\n\n\n\n\n\n\n\n\n* 5874638529236910091 instances created\n* 310 different types\n* 100 different interfaces\n* 10 modules\n\n\n\n\nError messages\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::is_abstract\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n is abstract\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0, 1 -\n no additional info, 2 -\n info about why type \nT\n is abstract\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::is_bound_more_than_once\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n is bound more than once\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError\n\n\nabstract_type\nT\n::is_not_bound\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nconfig \nT\n requires only providable and callable types\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0 -\n 'constraint not satisfied', 1 -\n (0) + abstract type is not bound, 2 -\n (1) + creation tree\n\n\n\n\n\n\nSuggestion\n\n\n'type is not bound, did you forget to add: 'di::bind\n.to\n()'?'\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\nDependency Injection Libraries\n\n\n\n\nC++ Dependency Injection Libraries\n\n\n\n\n\n\n\n\n\n\n\n\nBoost.DI\n\n\ndicpp\n\n\nGoogle.Fruit\n\n\n\n\n\n\n\n\n\n\nVersion\n\n\n1.0.0\n\n\nHEAD\n\n\n1.0.2\n\n\n\n\n\n\nLanguage\n\n\nC++14\n\n\nC++11\n\n\nC++11\n\n\n\n\n\n\nLicense\n\n\nBoost 1.0\n\n\nBoost 1.0\n\n\nApache 2.0\n\n\n\n\n\n\nLinkage\n\n\nheader only\n\n\nheader only\n\n\nlibrary\n\n\n\n\n\n\nApproach\n\n\ncompile-time\n\n\nrun-time\n\n\ncompile/run-time\n\n\n\n\n\n\nErrors\n\n\ncompile-time errors\n\n\nexceptions\n\n\ncompile-time errors + exceptions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLibrary\n\n\nBind Interface\n\n\n\n\n\n\n\n\n\n\nBoost.DI\n\n\n\n\n\n\n\n\ndicpp\n\n\n\n\n\n\n\n\nGoogle.Fruit\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLibrary\n\n\nBind Value\n\n\n\n\n\n\n\n\n\n\nBoost.DI\n\n\n\n\n\n\n\n\ndicpp\n\n\n\n\n\n\n\n\nGoogle.Fruit\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLibrary\n\n\nMissing Binding Error\n\n\n\n\n\n\n\n\n\n\nBoost.DI\n\n\n\n\n\n\n\n\ndicpp\n\n\n\n\n\n\n\n\nGoogle.Fruit\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTest\n\n\nCXXFLAGS\n\n\nTypes\n\n\nInstances created\n\n\nModules\n\n\n\n\n\n\n\n\n\n\nCreate Simple\n\n\n-O2 -s\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate Simple\n\n\nBoost.DI\n\n\ndicpp\n\n\nGoogle.Fruit\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.000s\n\n\n0.000s\n\n\n0.000s (-DFRUIT_NO_LOOP)\n\n\n\n\n\n\nExecution time\n\n\n0ms\n\n\n0ms\n\n\n0ms\n\n\n\n\n\n\nMemory usage / sizeof(injector)\n\n\n0b\n\n\n0b\n\n\n0b\n\n\n\n\n\n\nExecutable size\n\n\n0kb\n\n\n0kb\n\n\n0kb\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTest\n\n\nCXXFLAGS\n\n\nTypes\n\n\nInstances created\n\n\nModules\n\n\n\n\n\n\n\n\n\n\nCreate Complex\n\n\n-O2 -s\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate Complex\n\n\nBoost.DI\n\n\ndicpp\n\n\nGoogle.Fruit\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.000s\n\n\n0.000s\n\n\n0.000s (-DFRUIT_NO_LOOP)\n\n\n\n\n\n\nExecution time\n\n\n0ms\n\n\n0ms\n\n\n0ms\n\n\n\n\n\n\nMemory usage / sizeof(injector)\n\n\n0b\n\n\n0b\n\n\n0b\n\n\n\n\n\n\nExecutable size\n\n\n0kb\n\n\n0kb\n\n\n0kb\n\n\n\n\n\n\n\n\n\n\n\n\nDependency Injection Libraries\n\n\n\n\n\n\n\n\n\n\n\n\nBoost.DI\n\n\nGoogle.Guice\n\n\nDagger2\n\n\nNinject\n\n\n\n\n\n\n\n\n\n\nLanguage\n\n\nC++14\n\n\nJava 6\n\n\nJava\n\n\nC#\n\n\n\n\n\n\nLicense\n\n\nBoost 1.0\n\n\nApache 2.0\n\n\nApache 2.0\n\n\nApache 2.0\n\n\n\n\n\n\nLinkage\n\n\nheader only\n\n\njar\n\n\njar\n\n\ndll\n\n\n\n\n\n\nApproach\n\n\ncompile-time\n\n\nrun-time\n\n\ncompile-time (annotation processor)\n\n\nrun-time\n\n\n\n\n\n\nErrors\n\n\ncompile-time errors\n\n\nexceptions\n\n\ncompile-time errors\n\n\nexceptions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLibrary\n\n\nBind Interface\n\n\n\n\n\n\n\n\n\n\nBoost.DI\n\n\n\n\n\n\n\n\nGoogle.Guice\n\n\n\n\n\n\n\n\nDagger2\n\n\n\n\n\n\n\n\nNinject\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLibrary\n\n\nBind Value\n\n\n\n\n\n\n\n\n\n\nBoost.DI\n\n\n\n\n\n\n\n\nGoogle.Guice\n\n\n\n\n\n\n\n\nDagger2\n\n\n\n\n\n\n\n\nNinject\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLibrary\n\n\nMissing Bindings Error\n\n\n\n\n\n\n\n\n\n\nBoost.DI\n\n\n\n\n\n\n\n\nGoogle.Guice\n\n\n\n\n\n\n\n\nDagger2\n\n\n\n\n\n\n\n\nNinject\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTest\n\n\nCXXFLAGS\n\n\nTypes\n\n\nInstances created\n\n\nModules\n\n\n\n\n\n\n\n\n\n\nCreate Simple\n\n\n-O2 -s\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate Simple\n\n\nBoost.DI\n\n\nGoogle.Guice\n\n\nDagger2\n\n\nNinject\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.000s\n\n\n0.000s\n\n\n0.000s\n\n\n0.000s\n\n\n\n\n\n\nExecution time\n\n\n0ms\n\n\n0ms\n\n\n0ms\n\n\n0ms\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTest\n\n\nCXXFLAGS\n\n\nTypes\n\n\nInstances created\n\n\nModules\n\n\n\n\n\n\n\n\n\n\nCreate Complex\n\n\n-O2 -s\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate Complex\n\n\nBoost.DI\n\n\nGoogle.Guice\n\n\nDagger2\n\n\nNinject\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.000s\n\n\n0.000s\n\n\n0.000s\n\n\n0.000s\n\n\n\n\n\n\nExecution time\n\n\n0ms\n\n\n0ms\n\n\n0ms\n\n\n0ms", 
            "title": "Overview"
        }, 
        {
            "location": "/overview/index.html#quick-start", 
            "text": "Get  boost/di.hpp  header   wget https://raw.githubusercontent.com/boost-experimental/di/master/include/boost/di.hpp   Include the header and define  di  namespace alias   #include  boost/di.hpp \nnamespace di = boost::di;   Compile with C++14 support   $CXX -std=c++14 ...   To run tests   git clone https://github.com/boost-experimental/di   cd di   make test", 
            "title": "Quick Start"
        }, 
        {
            "location": "/overview/index.html#dependencies", 
            "text": "No external dependencies are required (neither STL nor Boost)", 
            "title": "Dependencies"
        }, 
        {
            "location": "/overview/index.html#supportedtested-compilers", 
            "text": "Clang-3.4+  GCC-5.2+  MSVC-2015+", 
            "title": "Supported/Tested compilers"
        }, 
        {
            "location": "/overview/index.html#configuration", 
            "text": "Macro  Description      BOOST_DI_VERSION  Current version of Boost.DI (ex. 1'0'0)    BOOST_DI_CFG  Global configuration allows to customize provider and policies    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  Gives more information with error messages    BOOST_DI_CFG_CTOR_LIMIT_SIZE  Limits number of allowed consturctor parameters [0-10, default=10]    BOOST_DI_NAMESPACE_BEGIN  namespace boost { namespace di { inline namespace v_1_0_0 {    BOOST_DI_NAMESPACE_END  }}}", 
            "title": "Configuration"
        }, 
        {
            "location": "/overview/index.html#exception-safety", 
            "text": "Boost.DI is not using exceptions internally and therefore might be compiled with  -fno-exceptions .  Check  User Guide  to verify which API's are marked  noexcept .", 
            "title": "Exception Safety"
        }, 
        {
            "location": "/overview/index.html#thread-safety", 
            "text": "Boost.DI is thread safe.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/overview/index.html#design", 
            "text": "Component  Description      Bindings  DSL to create dependencies representation which will be used by core to resolve types    Scopes  Responsible for maintain objects life time    Providers  Responsible for providing object instance    Policies  Compile-time limitations for types / Run-time types vistor    Core  Responsible for resolving requested types (implementation detail)    Wrappers  Responsible for conversion to required type (implementation detail)", 
            "title": "Design"
        }, 
        {
            "location": "/overview/index.html#performance", 
            "text": "Run-time performance  Environment  x86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux  clang++3.4 -O2 -fno-exceptions /  gdb -batch -ex 'file ./a.out' -ex 'disassemble main'              Compile-time performance  Environment  x86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux  clang++3.4 -O2 -fno-exceptions          Boost.DI header  Time [s]      #include  boost/di.hpp  0.050s     Legend:\n    ctor    = raw constructor: c(int i, double d);\n    inject  = inject constructor: BOOST_DI_INJECT(c, int i, double d);\n    all     = all types exposed from module: auto configure();\n    exposed = one type exposed from module: di::injector c  configure();   * 4248897537 instances created\n* 132 different types\n* 10 modules    * 1862039751439806464 instances created\n* 200 different types\n* 10 modules    * 5874638529236910091 instances created\n* 310 different types\n* 100 different interfaces\n* 10 modules", 
            "title": "Performance"
        }, 
        {
            "location": "/overview/index.html#error-messages", 
            "text": "Error  type T ::is_abstract      Description  type  T  is abstract    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0, 1 -  no additional info, 2 -  info about why type  T  is abstract    Expression         Error  type T ::is_bound_more_than_once      Description  type  T  is bound more than once    Expression         Error  abstract_type T ::is_not_bound      Description  config  T  requires only providable and callable types    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0 -  'constraint not satisfied', 1 -  (0) + abstract type is not bound, 2 -  (1) + creation tree    Suggestion  'type is not bound, did you forget to add: 'di::bind .to ()'?'    Expression     Expression", 
            "title": "Error messages"
        }, 
        {
            "location": "/overview/index.html#dependency-injection-libraries", 
            "text": "C++ Dependency Injection Libraries       Boost.DI  dicpp  Google.Fruit      Version  1.0.0  HEAD  1.0.2    Language  C++14  C++11  C++11    License  Boost 1.0  Boost 1.0  Apache 2.0    Linkage  header only  header only  library    Approach  compile-time  run-time  compile/run-time    Errors  compile-time errors  exceptions  compile-time errors + exceptions        Library  Bind Interface      Boost.DI     dicpp     Google.Fruit         Library  Bind Value      Boost.DI     dicpp     Google.Fruit         Library  Missing Binding Error      Boost.DI     dicpp     Google.Fruit          Test  CXXFLAGS  Types  Instances created  Modules      Create Simple  -O2 -s  0  0  0        Create Simple  Boost.DI  dicpp  Google.Fruit      Compilation time  0.000s  0.000s  0.000s (-DFRUIT_NO_LOOP)    Execution time  0ms  0ms  0ms    Memory usage / sizeof(injector)  0b  0b  0b    Executable size  0kb  0kb  0kb         Test  CXXFLAGS  Types  Instances created  Modules      Create Complex  -O2 -s  0  0  0        Create Complex  Boost.DI  dicpp  Google.Fruit      Compilation time  0.000s  0.000s  0.000s (-DFRUIT_NO_LOOP)    Execution time  0ms  0ms  0ms    Memory usage / sizeof(injector)  0b  0b  0b    Executable size  0kb  0kb  0kb       Dependency Injection Libraries       Boost.DI  Google.Guice  Dagger2  Ninject      Language  C++14  Java 6  Java  C#    License  Boost 1.0  Apache 2.0  Apache 2.0  Apache 2.0    Linkage  header only  jar  jar  dll    Approach  compile-time  run-time  compile-time (annotation processor)  run-time    Errors  compile-time errors  exceptions  compile-time errors  exceptions        Library  Bind Interface      Boost.DI     Google.Guice     Dagger2     Ninject         Library  Bind Value      Boost.DI     Google.Guice     Dagger2     Ninject         Library  Missing Bindings Error      Boost.DI     Google.Guice     Dagger2     Ninject          Test  CXXFLAGS  Types  Instances created  Modules      Create Simple  -O2 -s  0  0  0        Create Simple  Boost.DI  Google.Guice  Dagger2  Ninject      Compilation time  0.000s  0.000s  0.000s  0.000s    Execution time  0ms  0ms  0ms  0ms         Test  CXXFLAGS  Types  Instances created  Modules      Create Complex  -O2 -s  0  0  0        Create Complex  Boost.DI  Google.Guice  Dagger2  Ninject      Compilation time  0.000s  0.000s  0.000s  0.000s    Execution time  0ms  0ms  0ms  0ms", 
            "title": "Dependency Injection Libraries"
        }, 
        {
            "location": "/tutorial/index.html", 
            "text": "All code examples include \nboost/di.hpp\n as well as declare a convienent msm namespace alias.\n\n\n#include \nboost/di.hpp\n\nnamespace di = boost::di;\n\n\n\n\n0. [Pre] Refactor towards DI\n\n\nNOT -\n carry dependencies\n\n\n1. [Basic] Create objects tree\n\n\n\n\nauto injector = make_injector();\ninjector.create\n();\n\n\n2. [Basic] First steps with bindings\n\n\nbind interface\nbind value\ndynamic bindings\n\n\nobject creation ggurantee\nunderstand error messages\n\n\n3. [Basic] Decide the life times\n\n\ndeduce scope\nunique scope\nsingleton scope\n\n\n4. [Basic] Annotations to the rescue\n\n\nambigious constructors\nnamed name\n\n\n5. [Basic] Split your configuration\n\n\nauto module = [] { ... };\n\n\n6. [Advanced] Dump/Limit your types\n\n\numl dumper\nlimit types\n\n\n7. [Advanced] Customize it\n\n\ncustom scope\ncustom provider\ncustom policies\n\n\n8. [Advanced] Extend it\n\n\nextensions", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/index.html#0-pre-refactor-towards-di", 
            "text": "NOT -  carry dependencies", 
            "title": "0. [Pre] Refactor towards DI"
        }, 
        {
            "location": "/tutorial/index.html#1-basic-create-objects-tree", 
            "text": "auto injector = make_injector();\ninjector.create ();", 
            "title": "1. [Basic] Create objects tree"
        }, 
        {
            "location": "/tutorial/index.html#2-basic-first-steps-with-bindings", 
            "text": "bind interface\nbind value\ndynamic bindings  object creation ggurantee\nunderstand error messages", 
            "title": "2. [Basic] First steps with bindings"
        }, 
        {
            "location": "/tutorial/index.html#3-basic-decide-the-life-times", 
            "text": "deduce scope\nunique scope\nsingleton scope", 
            "title": "3. [Basic] Decide the life times"
        }, 
        {
            "location": "/tutorial/index.html#4-basic-annotations-to-the-rescue", 
            "text": "ambigious constructors\nnamed name", 
            "title": "4. [Basic] Annotations to the rescue"
        }, 
        {
            "location": "/tutorial/index.html#5-basic-split-your-configuration", 
            "text": "auto module = [] { ... };", 
            "title": "5. [Basic] Split your configuration"
        }, 
        {
            "location": "/tutorial/index.html#6-advanced-dumplimit-your-types", 
            "text": "uml dumper\nlimit types", 
            "title": "6. [Advanced] Dump/Limit your types"
        }, 
        {
            "location": "/tutorial/index.html#7-advanced-customize-it", 
            "text": "custom scope\ncustom provider\ncustom policies", 
            "title": "7. [Advanced] Customize it"
        }, 
        {
            "location": "/tutorial/index.html#8-advanced-extend-it", 
            "text": "extensions", 
            "title": "8. [Advanced] Extend it"
        }, 
        {
            "location": "/quick_user_guide/index.html", 
            "text": "Injector\n\n\nBindings\n\n\nInjections\n\n\nAnnotations\n\n\nScopes\n\n\nModules\n\n\nProviders\n\n\nPolicies\n\n\n\n\n\n\n\n\nLet's assume all examples below include \nboost/di.hpp\n header and define \ndi\n namespace alias.\n\n\n\n\n#include \nboost/di.hpp\n\nnamespace di = boost::di;\n//\nstruct i1 { virtual ~i1() = default; virtual void dummy1() = 0; };\nstruct i2 { virtual ~i2() = default; virtual void dummy2() = 0; };\nstruct impl1 : i1 { void dummy1() override { } };\nstruct impl2 : i2 { void dummy2() override { } };\nstruct impl : i1, i2 { void dummy1() override { } void dummy2() override { } };\n\n\n\n\n\n\nInjector\n\n\n\n\n\n\n\n\nBindings\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInjections\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnnotations\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nScopes\n\n\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDeduced scope\n\n\n\n\n\n\n\n\n\n\nT\n\n\nunique\n\n\n\n\n\n\nT\n\n\nsingleton\n\n\n\n\n\n\nconst T\n\n\nunique (temporary)/singleton\n\n\n\n\n\n\nT*\n\n\nunique (ownership transfer)\n\n\n\n\n\n\nconst T*\n\n\nunique (ownership transfer)\n\n\n\n\n\n\nT\n\n\nunique\n\n\n\n\n\n\nunique_ptr\n\n\nunique\n\n\n\n\n\n\nshared_ptr\n\n\nsingleton\n\n\n\n\n\n\nweak_ptr\n\n\nsingleton\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType/Scope\n\n\nunique\n\n\nsingleton\n\n\ninstance\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\n\n\n\n\nT\n\n\n-\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\n\n\n\n\nconst T\n\n\n\u2714 (temporary)\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\n\n\n\n\nT* (transfer ownership)\n\n\n\u2714\n\n\n-\n\n\n-\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\nconst T*\n\n\n\u2714\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n-\n\n\n\n\n\n\n\n\n\n\nunique_ptr\n\n\n\u2714\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\n\n\n\n\nshared_ptr\n\n\n\u2714\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\n\n\n\n\nweak_ptr\n\n\n-\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModules\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProviders\n\n\n\n\n\n\n\n\nPolicies", 
            "title": "Quick User Guide"
        }, 
        {
            "location": "/user_guide/index.html", 
            "text": "Injector\n\n\ndi::make_injector\n\n\n\n\n\n\nBindings\n\n\ndi::bind\n\n\n\n\n\n\nInjections\n\n\nautomatic (default)\n\n\nBOOST_DI_INJECT\n\n\nBOOST_DI_INJECT_TRAITS\n\n\ndi::inject\n\n\ndi::ctor_traits\n\n\n\n\n\n\nAnnotations\n\n\n(named = name)\n\n\n\n\n\n\nScopes\n\n\ndi::deduce (default)\n\n\ndi::instance (di::bind\n.to(value))\n\n\ndi::singleton\n\n\ndi::unique\n\n\n\n\n\n\nModules\n\n\nProviders\n\n\ndi::providers::stack_over_heap (default)\n\n\ndi::providers::heap\n\n\n\n\n\n\nPolicies\n\n\ndi::policies::constructible\n\n\n\n\n\n\nConcepts\n\n\ndi::concepts::boundable\n\n\ndi::concepts::callable\n\n\ndi::concepts::configurable\n\n\ndi::concepts::creatable\n\n\ndi::concepts::providable\n\n\ndi::concepts::scopable\n\n\n\n\n\n\nConfiguration\n\n\ndi::config\n\n\n\n\n\n\n\n\n\n\n\n\nLet's assume all examples below include \nboost/di.hpp\n header and define \ndi\n namespace alias.\n\n\n\n\n#include \nboost/di.hpp\n\nnamespace di = boost::di;\n//\nstruct i1 { virtual ~i1() = default; virtual void dummy1() = 0; };\nstruct i2 { virtual ~i2() = default; virtual void dummy2() = 0; };\nstruct impl1 : i1 { void dummy1() override { } };\nstruct impl2 : i2 { void dummy2() override { } };\nstruct impl : i1, i2 { void dummy1() override { } void dummy2() override { } };\n\n\n\n\nInjector\n\n\n\n\n--- \ndi::make_injector\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nCreates \ninjector\n type.\n\n\nSemantics\n\n\ntemplate\nclass... TDeps\n requires boundable\nTDeps...\n\nclass injector {\npublic:\n  using deps; // list of dependencies\n  using config; // configuration\n\n  injector(injector\n) = default;\n  template \nclass... Ts\n // no requirements\n  injector(core::injector\nTs...\n) noexcept;\n  explicit injector(const TDeps\n...) noexcept;\n\n  template\nclass T\n requires creatable\nT\n\n  T create() const;\n\n  template \nclass T\n requires creatable\nT\n\n  operator T() const;\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTDeps...\n\n\nboundable\nTDeps...>\n\n\n[Bindings] to be used as configuration\n\n\n-\n\n\n\n\n\n\ncreate\nT\n()\n\n\ncreatable\nT>\n\n\nCreates type \nT\n\n\nT\n\n\n\n\n\n\noperator T()\n\n\ncreatable\nT>\n\n\nCreates type \nT\n\n\nT\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType \nT\n\n\nIs allowed?\n\n\nNote\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nT*\n\n\n\u2714\n\n\nOwnerhsip transfer!\n\n\n\n\n\n\nconst T*\n\n\n\u2714\n\n\nOwnerhsip transfer!\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nconst T\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nstd::unique_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nstd::shared_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nstd::weak_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nboost_shared_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\n\n\ntemplate\n\n  class TConfig = di::config\n, class... TBindings\n\n requires boundable\nTBindings...\n \n configurable\nTConfig\n\nauto make_injector(const TBindings\n...) noexcept;\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTConfig\n\n\nconfigurable\nTConfig>\n\n\nConfiguration\n\n\n-\n\n\n\n\n\n\nmake_injector(const TBindings\n...)\n\n\nboundable\nTBindings...>\n\n\nCreates \ninjector\n with given [Bindings]\n\n\ninjector\n\n\n\n\n\n\n\n\nTest\n\n\n\n\nExample\n\n\n\n\n\n\nBindings\n\n\nBindings define dependencies configuration which basically means what types will be created\nand what values will be passed into them.\n\n\n\n--- \ndi::bind\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nAllows to bind interface to implementation and associate value with it.\n\n\nSemantics\n\n\nstruct override; // overrides given configuration\n\nnamespace detail {\n  template\nclass... Ts\n requires boundable\nTs...\n\n  struct bind {\n    bind(bind\n) noexcept = default;\n\n    template\nclass T\n requires boundable\nT\n\n    auto to() noexcept;\n\n    template\nclass T\n requires boundable\nT\n\n    auto to(T\n) noexcept;\n\n    template\nclass TScope\n requires scopable\nTScope\n\n    auto in(const TScope\n = di::deduce) noexcept;\n\n    template\nclass TName\n // no requirements\n    auto named(const TName\n = {}) noexcept;\n\n    auto operator[](const override\n) noexcept;\n  };\n} // detail\n\ntemplate\nclass... Ts\n requires boundable\nTs...\n\ndetail::bind\nTs...\n bind{};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTs...\n\n\nboundable\nTs...>\n\n\n'Interface' types\n\n\n-\n\n\n\n\n\n\nto\nT\\\n\n\nboundable\nT>\n\n\nBinds \nTs...\n to \nT\n type\n\n\nboundable\n\n\n\n\n\n\nto(T\n)\n\n\nboundable\nT>\n\n\nBinds \nTs...\n to \nT\n object\n\n\nboundable\n\n\n\n\n\n\nin(const TScope\n)\n\n\nscopable\nTScope>\n\n\nBinds \nTs...\n into \nTScope\n\n\nboundable\n\n\n\n\n\n\nnamed(const TName\n)\n\n\n-\n\n\nBinds \nTs...\n using 'Named' annotation\n\n\nboundable\n\n\n\n\n\n\noperator[](const override\n)\n\n\n-\n\n\nOverrides given binding\n\n\nboundable\n\n\n\n\n\n\n\n\nTest\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInjections\n\n\nConstructor Injection\n is the most powerful of available injections.\nIt guarantees initialized state of data members. Boost.DI constructor injection is achieved without any additional work from the user.\n\n\n\n--- \nautomatic (default)\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nBoost.DI will deduce the best available constructor to be used for injection - unique constructor with the longest parameter list.\nIf the default behavior should be changed constructor has to be explicitly marked with \nBOOST_DI_INJECT\n or \nBOOST_DI_INJECT_TRAITS\n.\n\n\n\n\n Note\n\nAutomatic constructor parameters deduction is limited to [BOOST_DI_CFG_CTOR_LIMIT_SIZE], which by default is set to 10.\n\n\n\n\nSemantics\n\n\nclass constructor {\npublic:\n  constructor(auto parameter1, auto parameter2, ..., auto parameterN);\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nparameter1-parameterN\n\n\n-\n\n\nN\n constructor parameter\n\n\n-\n\n\n\n\n\n\n\n\n\n\n Note\n\nBoost.DI is not able to distinguish between ambiguous constructors with the same (longest) amount of parameters.\n\n\n\n\nTest\n\n\n\n\n\n\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n--- \nBOOST_DI_INJECT\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nBOOST_DI_INJECT is a macro definition used to explicitly say Boost.DI which constructor should be used as well as in order to annotate types - see [annotations] for further reding.\nWhen class has more than one constructor Boost.DI will by default choose the one with the longest parameter list.\nIn case of constructors ambiguity Boost.DI is not able to choose the best one.\nThen BOOST_DI_INJECT become handy to point which constructor should be used.\n\n\nSemantics\n\n\nstruct T {\n    BOOST_DI_INJECT(T, ...) { }\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nT\n\n\n-\n\n\nClass type\n\n\n-\n\n\n\n\n\n\n...\n\n\n-\n\n\nT\n constructor parameters\n\n\n-\n\n\n\n\n\n\n\n\n\n\n Note\n\nBOOST_DI_INJECT constructor parameters is limited to [BOOST_DI_CFG_CTOR_LIMIT_SIZE], which by default is set to 10.\n\n\n\n\nTest\n\n\n\n\nExample\n\n\n\n\n\n\n\n--- \nBOOST_DI_INJECT_TRAITS\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nBOOST_DI_INJECT_TRAITS is a macro definition used to define constructor traits.\n\n\nSemantics\n\n\nstruct T {\n  BOOST_DI_INJECT_TRAITS(...) { }\n  T(...) { }\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\n...\n\n\n-\n\n\nT\n constructor parameters\n\n\n-\n\n\n\n\n\n\n\n\n\n\n Note\n\nBOOST_DI_INJECT_TRAITS constructor parameters is limited to [BOOST_DI_CFG_CTOR_LIMIT_SIZE], which by default is set to 10.\n\n\n\n\nTest\n\n\n\n\n\n\nExample\n\n\n\n\n\n\n\n--- \ndi::inject\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\ndi::inject informs Boost.DI about constructor parameters. Useful for generated/generic classes as it doesn't have constructor parameters size limitations.\n\n\nSemantics\n\n\nstruct T {\n  using boost_di_inject__ = di::inject\n...\n;\n  T(...) {}\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\n...\n\n\n-\n\n\nT\n constructor parameters\n\n\n-\n\n\n\n\n\n\n\n\n\n\n Note\n\ndi::inject has no limitations if it comes to constructor parameters, however, named parameters are not allowed.\n\n\n\n\nTest\n\n\n\n\n\n\nExample\n\n\n\n\n\n\n\n--- \ndi::ctor_traits\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nSemantics\n\n\nTest\n\n\n\n\nExample\n\n\n\n\n\n\nAnnotations\n\n\nAnnotations are intrusive, additional informations specified along with the type in order to refer to given type by the\nannotation instead of type it self. Useful, when there are more than one type of the same parameters in constructor parameters.\n\n\n\n--- \n(named = name)\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nNamed parameters are useful when constructor has more parameters of the same type.\n\n\n  T(int value1, int value2);\n\n\n\n\nIn order to inject proper values into \nvalue1\n and \nvalue2\n they have to be distinguished somehow.\nBoost.DI solution for that problem are annotations.\n\n\n\n\n Note\n\nAnnotations might be set only when constructor is selected using BOOST_DI_INJECT or BOOST_DI_INJECT_TRAITS.\n\n\n\n\nSemantics\n\n\nauto Name = []{}; // just an object\n\nstruct T {\n  BOOST_DI_INJECT(T, (named = Name) type type_name [= default_value], ...);\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nName\n\n\n-\n\n\nObject representing named type\n\n\n-\n\n\n\n\n\n\n\n\nExample\n\n\nBOOST_DI_INJECT(T, (named = value_1) int value1, (named = value_2) int value2);\n\n\n\n\n\n Note\n\nImplementation of constructor doesn't require annotations, which means implementation won't be affected by annotations.\n\n\n\n\nTest\n\n\n\n\n\n\n\n\n\n\nExample\n\n\n\n\n\n\nScopes\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nScopes are responsible for creating and maintaining life time of dependencies.\nIf no scope will be given, deduce scope will be assumed.\n\n\nSemantics\n\n\ntemplate \nclass TExpected, class TGiven\n\nstruct scope {\n  template \nclass T\n\n  using is_referable;\n\n  template \nclass T, class TName, class TProvider\n\n  static auto try_create(const TProvider\n);\n\n  template \nclass T, class TName, class TProvider\n\n  auto create(const TProvider\n);\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTExpected\n\n\n-\n\n\n'Interface' type\n\n\n-\n\n\n\n\n\n\nTGiven\n\n\n-\n\n\n'Implementation' type\n\n\n-\n\n\n\n\n\n\nis_referable\nT\\\n\n\n-\n\n\nVerifies whether scope value might be converted to a reference\n\n\nstd::true_type/std::false_type\n\n\n\n\n\n\ntry_create\nT, TName, TProvider\\\n\n\nprovidable\nTProvider>\n\n\nVerifies whether type might be created\n\n\nstd::true_type/std::false_type\n\n\n\n\n\n\ncreate\nT, TName, TProvider\\\n\n\nprovidable\nTProvider>\n\n\nCreates type might be created\n\n\nT\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType/Scope\n\n\nunique\n\n\nsingleton\n\n\ninstance\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\n\n\n\n\nT\n\n\n-\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\n\n\n\n\nconst T\n\n\n\u2714 (temporary)\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\n\n\n\n\nT* (transfer ownership)\n\n\n\u2714\n\n\n-\n\n\n-\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\nconst T*\n\n\n\u2714\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n-\n\n\n\n\n\n\n\n\n\n\nunique_ptr\n\n\n\u2714\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\n\n\n\n\nshared_ptr\n\n\n\u2714\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\n\n\n\n\nweak_ptr\n\n\n-\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\n\n\n\n\n\n\nTest\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n\n\n\n\n--- \ndi::deduce (default)\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nDefault scope which will be converted to one of the scopes depending on the type.\n\n\n\n\n\n\n\n\nType\n\n\ndeduce\n\n\n\n\n\n\n\n\n\n\nT\n\n\nunique\n\n\n\n\n\n\nT\n\n\nsingleton\n\n\n\n\n\n\nconst T\n\n\nunique\n (temporary)/singleton\n\n\n\n\n\n\nT*\n\n\nunique\n (ownership transfer)\n\n\n\n\n\n\nconst T*\n\n\nunique\n (ownership transfer)\n\n\n\n\n\n\nT\n\n\nunique\n\n\n\n\n\n\nunique_ptr\n\n\nunique\n\n\n\n\n\n\nshared_ptr\n\n\nsingleton\n\n\n\n\n\n\nweak_ptr\n\n\nsingleton\n\n\n\n\n\n\n\n\nSemantics\n\n\nnamespace scopes {\n  struct deduce {\n    template \nclass TExpected, class TGiven\n\n    struct scope {\n      template \nclass T\n\n      using is_referable;\n\n      template \nclass T, class TName, class TProvider\n\n      static auto try_create(const TProvider\n);\n\n      template \nclass T, class TName, class TProvider\n\n      auto create(const TProvider\n);\n    };\n  };\n}\n\nscopes::deduce deduce;\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTExpected\n\n\n-\n\n\n'Interface' type\n\n\n-\n\n\n\n\n\n\nTGiven\n\n\n-\n\n\n'Implementation' type\n\n\n-\n\n\n\n\n\n\nis_referable\nT\\\n\n\n-\n\n\nVerifies whether scope value might be converted to a reference\n\n\nstd::true_type/std::false_type\n\n\n\n\n\n\ntry_create\nT, TName, TProvider\\\n\n\nprovidable\nTProvider>\n\n\nVerifies whether type might be created\n\n\nstd::true_type/std::false_type\n\n\n\n\n\n\ncreate\nT, TName, TProvider\\\n\n\nprovidable\nTProvider>\n\n\nCreates type might be created\n\n\nT\n\n\n\n\n\n\n\n\nTest\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n--- \ndi::instance (di::bind\n.to(value))\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nScope representing values - passed by user. The life time of the object depends on the user.\nBoost.DI is not managing life time of passed objects, however values and strings will be copied and managed by the library.\n\n\n\n\n\n\n\n\nType\n\n\ninstance\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\n\n\n\nT\n\n\n-\n\n\n\n\n\n\nconst T\n\n\n\u2714 (temporary)\n\n\n\n\n\n\nT* (transfer ownership)\n\n\n\u2714\n\n\n\n\n\n\nconst T*\n\n\n\u2714\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\n\n\n\nunique_ptr\n\n\n\u2714\n\n\n\n\n\n\nshared_ptr\n\n\n\u2714\n\n\n\n\n\n\nweak_ptr\n\n\n-\n\n\n\n\n\n\n\n\nSemantics\n\n\nnamespace scopes {\n  struct instance {\n    template \nclass TExpected, class TGiven\n\n    struct scope {\n      template \nclass T\n\n      using is_referable;\n\n      template \nclass T, class TName, class TProvider\n\n      static auto try_create(const TProvider\n);\n\n      template \nclass T, class TName, class TProvider\n\n      auto create(const TProvider\n);\n    };\n  };\n}\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTExpected\n\n\n-\n\n\n'Interface' type\n\n\n-\n\n\n\n\n\n\nTGiven\n\n\n-\n\n\n'Implementation' type\n\n\n-\n\n\n\n\n\n\nis_referable\nT\\\n\n\n-\n\n\nVerifies whether scope value might be converted to a reference\n\n\nstd::true_type/std::false_type\n\n\n\n\n\n\ntry_create\nT, TName, TProvider\\\n\n\nprovidable\nTProvider>\n\n\nVerifies whether type might be created\n\n\nstd::true_type/std::false_type\n\n\n\n\n\n\ncreate\nT, TName, TProvider\\\n\n\nprovidable\nTProvider>\n\n\nCreates type might be created\n\n\nT\n\n\n\n\n\n\n\n\nTest\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n--- \ndi::singleton\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nScope representing shared value between all instances and between threads.\nSingleton scope will be deduced in case of shared_ptr or weak_ptr.\n\n\n\n\n Note\n\nSingleton scope will convert between std::shared_ptr and boost::shared_ptr if required.\n\n\n\n\n\n\n\n\n\n\nType\n\n\nsingleton\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\n\n\n\nT\n\n\n-\n\n\n\n\n\n\nconst T\n\n\n\u2714 (temporary)\n\n\n\n\n\n\nT* (transfer ownership)\n\n\n\u2714\n\n\n\n\n\n\nconst T*\n\n\n\u2714\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\n\n\n\nunique_ptr\n\n\n\u2714\n\n\n\n\n\n\nshared_ptr\n\n\n\u2714\n\n\n\n\n\n\nweak_ptr\n\n\n-\n\n\n\n\n\n\n\n\nSemantics\n\n\nnamespace scopes {\n  struct singleton {\n    template \nclass TExpected, class TGiven\n\n    struct scope {\n      template \nclass T\n\n      using is_referable;\n\n      template \nclass T, class TName, class TProvider\n\n      static auto try_create(const TProvider\n);\n\n      template \nclass T, class TName, class TProvider\n\n      auto create(const TProvider\n);\n    };\n  };\n}\n\nscopes::singleton singleton;\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTExpected\n\n\n-\n\n\n'Interface' type\n\n\n-\n\n\n\n\n\n\nTGiven\n\n\n-\n\n\n'Implementation' type\n\n\n-\n\n\n\n\n\n\nis_referable\nT\\\n\n\n-\n\n\nVerifies whether scope value might be converted to a reference\n\n\nstd::true_type/std::false_type\n\n\n\n\n\n\ntry_create\nT, TName, TProvider\\\n\n\nprovidable\nTProvider>\n\n\nVerifies whether type might be created\n\n\nstd::true_type/std::false_type\n\n\n\n\n\n\ncreate\nT, TName, TProvider\\\n\n\nprovidable\nTProvider>\n\n\nCreates type might be created\n\n\nT\n\n\n\n\n\n\n\n\nTest\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n--- \ndi::unique\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nScope representing unique/per request value.\n\n\n\n\n\n\n\n\nType\n\n\nunique\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\n\n\n\nT\n\n\n-\n\n\n\n\n\n\nconst T\n\n\n\u2714 (temporary)\n\n\n\n\n\n\nT* (transfer ownership)\n\n\n\u2714\n\n\n\n\n\n\nconst T*\n\n\n\u2714\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\n\n\n\nunique_ptr\n\n\n\u2714\n\n\n\n\n\n\nshared_ptr\n\n\n\u2714\n\n\n\n\n\n\nweak_ptr\n\n\n-\n\n\n\n\n\n\n\n\nSemantics\n\n\nnamespace scopes {\n  struct unique {\n    template \nclass TExpected, class TGiven\n\n    struct scope {\n      template \nclass T\n\n      using is_referable;\n\n      template \nclass T, class TName, class TProvider\n\n      static auto try_create(const TProvider\n);\n\n      template \nclass T, class TName, class TProvider\n\n      auto create(const TProvider\n);\n    };\n  };\n}\n\nscopes::unique unique;\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTExpected\n\n\n-\n\n\n'Interface' type\n\n\n-\n\n\n\n\n\n\nTGiven\n\n\n-\n\n\n'Implementation' type\n\n\n-\n\n\n\n\n\n\nis_referable\nT\\\n\n\n-\n\n\nVerifies whether scope value might be converted to a reference\n\n\nstd::true_type/std::false_type\n\n\n\n\n\n\ntry_create\nT, TName, TProvider\\\n\n\nprovidable\nTProvider>\n\n\nVerifies whether type might be created\n\n\nstd::true_type/std::false_type\n\n\n\n\n\n\ncreate\nT, TName, TProvider\\\n\n\nprovidable\nTProvider>\n\n\nCreates type might be created\n\n\nT\n\n\n\n\n\n\n\n\nTest\n\n\n\n\nExample\n\n\n\n\n\n\nModules\n\n\n\n\nauto module = [] { return di::make_injector(...); };\n\n\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nModules allow to split the configuration into smaller injectors.\nModule might be installed by passing it into [make_injector].\n\n\nSemantics\n\n\nauto module = di::make_injector(...);\n\n\n\nTest\n\n\n\n\n\n\n\n\n\n\n\n\nExample\n\n\n\n\n\n\nProviders\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nProviders are responsible for creating objects using given configuration.\n\n\nSemantics\n\n\nnamespace type_traits {\n  struct direct; // T(...)\n  struct uniform; // T{...}\n  struct heap; // new T\n  struct stack; // T\n}\n\nnamespace providers {\n  class provider {\n    public:\n      template \nclass T, class... TArgs\n\n      struct is_creatable;\n\n      template \n\n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n      \n auto get(const TInit\n, const TMemory\n, TArgs\n... args) const;\n  };\n}\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nis_creatable\nT, TArgs...\\\n\n\ncreatable\nTArgs...>\n\n\nVerify whether \nT\n is creatable with \nTArgs...\n\n\nT\n\n\n\n\n\n\nget\nT, TInitialization, TMemory, TArgs\\\n(const TInitialization\n, const TMemory\n, TArgs\n...)\n\n\nTInitialization\n is direct\\\n\n\nuniform \n \nTMemory\n is heap\\\n\n\nstack\n\n\n\n\n\n\n\n\nTest\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n--- \ndi::providers::stack_over_heap (default)\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nCreates objects on the stack whenever possible, otherwise on the heap.\n\n\nSemantics\n\n\nnamespace providers {\n  class stack_over_heap {\n    public:\n      template \nclass T, class... TArgs\n\n      struct is_creatable;\n\n      template \n\n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n      \n auto get(const TInit\n, const TMemory\n, TArgs\n... args) const;\n  };\n}\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nis_creatable\nT, TArgs...\\\n\n\ncreatable\nTArgs...>\n\n\nVerify whether \nT\n is creatable with \nTArgs...\n\n\nT\n\n\n\n\n\n\nget\nT, TInitialization, TMemory, TArgs\\\n(const TInitialization\n, const TMemory\n, TArgs\n...)\n\n\nTInitialization\n is direct\\\n\n\nuniform \n \nTMemory\n is heap\\\n\n\nstack\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\n\n\nTMemory\n\n\n\n\n\n\n\n\n\n\nT\n\n\nstack\n\n\n\n\n\n\nT\n\n\nstack\n\n\n\n\n\n\nconst T\n\n\nstack\n\n\n\n\n\n\nT*\n\n\nstack\n\n\n\n\n\n\nconst T*\n\n\nstack\n\n\n\n\n\n\nT\n\n\nstack\n\n\n\n\n\n\nunique_ptr\n\n\nstack\n\n\n\n\n\n\nshared_ptr\n\n\nstack\n\n\n\n\n\n\nweak_ptr\n\n\nstack\n\n\n\n\n\n\n\n\nTest\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n--- \ndi::providers::heap\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nBasic provider creates objects on the heap.\n\n\nSemantics\n\n\nnamespace providers {\n  class stack_over_heap {\n    public:\n      template \nclass T, class... TArgs\n\n      struct is_creatable;\n\n      template \n\n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n      \n auto get(const TInit\n, const TMemory\n, TArgs\n... args) const;\n  };\n}\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nis_creatable\nT, TArgs...\\\n\n\ncreatable\nTArgs...>\n\n\nVerify whether \nT\n is creatable with \nTArgs...\n\n\nT\n\n\n\n\n\n\nget\nT, TInitialization, TMemory, TArgs\\\n(const TInitialization\n, const TMemory\n, TArgs\n...)\n\n\nTInitialization\n is direct\\\n\n\nuniform \n \nTMemory\n is heap\\\n\n\nstack\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\n\n\nTMemory\n\n\n\n\n\n\n\n\n\n\nT\n\n\nstack\n\n\n\n\n\n\nT\n\n\nstack\n\n\n\n\n\n\nconst T\n\n\nstack\n\n\n\n\n\n\nT*\n\n\nstack\n\n\n\n\n\n\nconst T*\n\n\nstack\n\n\n\n\n\n\nT\n\n\nstack\n\n\n\n\n\n\nunique_ptr\n\n\nstack\n\n\n\n\n\n\nshared_ptr\n\n\nstack\n\n\n\n\n\n\nweak_ptr\n\n\nstack\n\n\n\n\n\n\n\n\nTest\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nPolicies\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nPolicies operates on dependencies in order to limit allowed behaviour or visit created types during run-time.\nPolicies are set up via [di::config].\n\n\n\n\n Note\n\nBy default Boost.DI has no policies enabled.\n\n\n\n\nSemantics\n\n\ntemplate \n requires callable\n\n  auto make_policies(TPolicies... args) noexcept;\n\n\nstruct config : di::config {\n    static auto policies(...) noexcept { return make_policies(...); }\n  };\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nmake_policies\nTPolicies...\\\n\n\ncallable\nTPolicies...>\n\n\nCreates policies\n\n\ncallable\n list\n\n\n\n\n\n\n\n\n\n\n Note\n\nIn order for injector to verify policies they have to be created using di::config and passed via `TConfig` in make_injector or set globally via BOOST_DI_CFG.\n\n\n\n\nTest\n\n\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n\n\n--- \ndi::policies::constructible\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nPolicy limits constructor parameters to explicitly allowed.\n\n\n\n\n Note\n\nBy default constructible policy disables creation of any constructor parameters.\n\n\n\n\nSemantics\n\n\nnamespace policies {\n  struct _ { }; // placeholder\n\n  template\nclass T\n\n  struct is_bound; // true when type is bound with 'di::bind\nT\n'\n\n  template \nclass T\n\n  struct is_injected; // true when type is injected using 'BOOST_DI_INJECT' or is 'fundamental'\n\n  template\nclass T\n\n  auto constructible(const T\n) noexcept;\n}\n\nnamespace operators {\n  template\nclass X\n\n  inline auto operator!(const X\n)\n\n  template\nclass X, class Y\n\n  inline auto operator\n(const X\n, const Y\n);\n\n  template\nclass X, class Y\n\n  inline auto operator||(const X\n, const Y\n);\n}\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nis_bound\nT\\\n\n\n-\n\n\nVerify whether type \nT\n is bound\n\n\ntrue_type/false_type\n\n\n\n\n\n\nis_injected\nT\\\n\n\n-\n\n\nVerify whether type \nT\n is injected via \nBOOST_DI_INJECT\n\n\ntrue_type/false_type\n\n\n\n\n\n\n\n\n\n\n Note\n\nIn order to allow logic operators using namespace boost::di::policies::operators has to be used\n\n\n\n\nTest\n\n\n\n\n\n\n\n\n Note\n\nSTL type traits are supported and might be combined with Boost.DI traits in order to limit constructor types\nFor example, std::is_same\n<\n_, int>{} || std::is_constructible\n<\n_, int, int>{} || std::is_base_of\n<int\n, _>{}, etc...\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nConcepts\n\n\nConcepts are types constraints which ensure that only given types which are satisfied by the constraint will be allowed.\nIf type doesn't satisfy the concept short and descriptive error message is provided.\n\n\n\n--- \ndi::concepts::boundable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nBindings type requirement.\n\n\nSynopsis\n\n\ntemplate \nclass TExpected, class TGiven\n\nconcept bool boundable() {\n  return is_complete\nTExpected\n()\n      \n is_complete\nTGiven\n()\n      \n (is_base_of\nTExpected, TGiven\n() || is_convertible\nTGiven, TExpected\n());\n}\n\ntemplate \nclass... Ts\n\nconcept bool boundable() {\n  return is_supported\nTs\n()... \n      \n is_movable\nTs\n()...\n      \n (is_base_of\ninjector, Ts\n()... || is_base_of\ndependency, Ts\n()...);\n}\n\n\n\nSemantics\n\n\nboundable\nT\n\nboundable\nTs...\n\n\n\n\n\n\n\n\n\n\nExpression\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTs...\n\n\nBindings to be verified\n\n\ntrue_type if constraint is satisfied, \nerror\n otherwise\n\n\n\n\n\n\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::has_disallowed_qualifiers\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n has disallowed qualifiers\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::is_abstract\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n is abstract\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0, 1 -\n no additional info, 2 -\n info about why type \nT\n is abstract\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::is_not_related_to\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n is not related to type \nU\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::is_bound_more_than_once\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n is bound more than once\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::is_neither_a_dependency_nor_an_injector\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n is neither a dependency nor an injector\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n--- \ndi::concepts::callable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nPolicies type requirement.\n\n\nSynopsis\n\n\ntemplate \nclass T\n\nconcept bool callable() {\n  return requires(T object) {\n    { object(...) };\n  }\n}\n\n\n\nSemantics\n\n\ncallable\nT\n\n\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\npolicy\nTPolicy\n::requires_\ncall_operator\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\npolicy \nTPolicy\n requires a call operator\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n--- \ndi::concepts::configurable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nSynopsis\n\n\ntemplate \nclass T\n\nconcept bool configurable() {\n  return requires(T object) {\n    return providable\ndecltype(T::provider(...))\n \n callable\ndecltype(T::policies(...))\n();\n  }\n}\n\n\n\nSemantics\n\n\nconfigurable\nT\n\n\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\nconfig\nTConfig\n::requires_\nprovider\nprovidable_type (...)\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nconfig \nT\n requires only providable and callable types\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n--- \ndi::concepts::creatable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nType creation requirement.\n\n\nSynopsis\n\n\ntemplate \nclass T, class... TBindings\n\nconcept bool creatable() {\n  return is_recursively_constructible\nT, TBindings...\n();\n}\n\n\n\nSemantics\n\n\ncreatable\nT, TBindings...\n\n\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\nabstract_type\nT\n::is_not_bound\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nconfig \nT\n requires only providable and callable types\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0 -\n 'constraint not satisfied', 1 -\n (0) + abstract type is not bound, 2 -\n (1) + creation tree\n\n\n\n\n\n\nSuggestion\n\n\n'type is not bound, did you forget to add: 'di::bind\n.to\n()'?'\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::has_ambiguous_number_of_constructor_parameters::given\nGiven\n::expected\nExpected\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n has ambiguous number of constructor parameters where \nGiven\n were provided but \nExpected\n were expected\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0 -\n 'constraint not satisfied', 1 -\n (0) + abstract type is not bound, 2 -\n (1) + creation tree\n\n\n\n\n\n\nSuggestion\n\n\n'verify BOOST_DI_INJECT_TRAITS or di::ctor_traits'\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::has_to_many_constructor_parameters::max\nMax\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n has to many constructor parameter where maximum number is \nMax\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0 -\n 'constraint not satisfied', 1 -\n (0) + abstract type is not bound, 2 -\n (1) + creation tree\n\n\n\n\n\n\nSuggestion\n\n\n'increase BOOST_DI_CFG_CTOR_LIMIT_SIZE value or reduce number of constructor parameters'\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError\n\n\nscoped\nTScope\n::is_not_convertible_to\nT\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nscope \nTScope\n is not convertible to type \nT\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0 -\n 'constraint not satisfied', 1 -\n (0) + abstract type is not bound, 2 -\n (1) + creation tree\n\n\n\n\n\n\nSuggestion\n\n\n'scoped object is not convertible to the requested type, did you mistake the scope: 'di::bind\n.in(scope)'?'\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError\n\n\nscoped\ninstance\n::is_not_convertible_to\nT\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ninstance is not convertible to type \nT\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0 -\n 'constraint not satisfied', 1 -\n (0) + abstract type is not bound, 2 -\n (1) + creation tree\n\n\n\n\n\n\nSuggestion\n\n\n'instance is not convertible to the requested type, verify binding: 'di::bind\n.to(value)'?'\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n Note\n\nSuggestions are not supported/displayed by MSVC-2015.\n\n\n\n\n\n\n\n--- \ndi::concepts::providable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nProvider type requirement.\n\n\nSynopsis\n\n\ntemplate \nclass T\n\nconcept bool providable() {\n  return requires(T object) {\n    { object.template get\n_\n(direct/uniform{}, stack/heap{}, ...) };\n    { object.template is_creatable\n_\n(direct/uniform{}, stack/heap{}, ...) };\n  }\n}\n\n\n\nSemantics\n\n\nprovidable\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\nprovider\nTProvider\n::requires_\nget\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nprovider \nTProvider\n requires \nget\n method\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n--- \ndi::concepts::scopable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nScope type requirement.\n\n\nSynopsis\n\n\ntemplate \nclass T\n\nconcept bool scopable() {\n  return requires(T) {\n    typename scope\n_, _\n::is_referable;\n    { T::scope\n_, _\n{}.try_create() };\n    { T::scope\n_, _\n{}.create() };\n  }\n}\n\n\n\nSemantics\n\n\nscopable\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\nscope\nTScope\n::requires_\ncreate\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nscope \nTScope\n requires \ncreate\n method\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\nConfiguration\n\n\n\n--- \ndi::config\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nInjector configuration.\n\n\nSynopsis\n\n\nstruct config {\n  static auto provider(...) noexcept;\n  static auto policies(...) noexcept;\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nprovider()\n\n\nprovidable\n\n\nCreates provider\n\n\nprovidable\n\n\n\n\n\n\npolicies()\n\n\ncallable\n\n\nCreates policies\n\n\ncallable\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExpression\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBOOST_DI_CFG\n\n\nGlobal configuration allows to customize provider and policies\n\n\n\n\n\n\n\n\nSemantics\n\n\ndi::make_injector\nconfig\n(...)\n// or\n#define BOOST_DI_CFG config // change default\ndi::make_injector(...)\n\n\n\nTest\n\n\n\n\nExample", 
            "title": "User Guide"
        }, 
        {
            "location": "/user_guide/index.html#injector", 
            "text": "---  di::make_injector  ---  Header  #include  boost/di.hpp   Description  Creates  injector  type.  Semantics  template class... TDeps  requires boundable TDeps... \nclass injector {\npublic:\n  using deps; // list of dependencies\n  using config; // configuration\n\n  injector(injector ) = default;\n  template  class... Ts  // no requirements\n  injector(core::injector Ts... ) noexcept;\n  explicit injector(const TDeps ...) noexcept;\n\n  template class T  requires creatable T \n  T create() const;\n\n  template  class T  requires creatable T \n  operator T() const;\n};     Expression  Requirement  Description  Returns      TDeps...  boundable TDeps...>  [Bindings] to be used as configuration  -    create T ()  creatable T>  Creates type  T  T    operator T()  creatable T>  Creates type  T  T        Type  T  Is allowed?  Note      T  \u2714  -    T*  \u2714  Ownerhsip transfer!    const T*  \u2714  Ownerhsip transfer!    T  \u2714  -    const T  \u2714  -    T  \u2714  -    std::unique_ptr T  \u2714  -    std::shared_ptr T  \u2714  -    std::weak_ptr T  \u2714  -    boost_shared_ptr T  \u2714  -     template \n  class TConfig = di::config\n, class... TBindings  requires boundable TBindings...    configurable TConfig \nauto make_injector(const TBindings ...) noexcept;     Expression  Requirement  Description  Returns      TConfig  configurable TConfig>  Configuration  -    make_injector(const TBindings ...)  boundable TBindings...>  Creates  injector  with given [Bindings]  injector     Test   Example", 
            "title": "Injector"
        }, 
        {
            "location": "/user_guide/index.html#bindings", 
            "text": "Bindings define dependencies configuration which basically means what types will be created\nand what values will be passed into them.  \n---  di::bind  ---  Header  #include  boost/di.hpp   Description  Allows to bind interface to implementation and associate value with it.  Semantics  struct override; // overrides given configuration\n\nnamespace detail {\n  template class... Ts  requires boundable Ts... \n  struct bind {\n    bind(bind ) noexcept = default;\n\n    template class T  requires boundable T \n    auto to() noexcept;\n\n    template class T  requires boundable T \n    auto to(T ) noexcept;\n\n    template class TScope  requires scopable TScope \n    auto in(const TScope  = di::deduce) noexcept;\n\n    template class TName  // no requirements\n    auto named(const TName  = {}) noexcept;\n\n    auto operator[](const override ) noexcept;\n  };\n} // detail\n\ntemplate class... Ts  requires boundable Ts... \ndetail::bind Ts...  bind{};     Expression  Requirement  Description  Returns      Ts...  boundable Ts...>  'Interface' types  -    to T\\  boundable T>  Binds  Ts...  to  T  type  boundable    to(T )  boundable T>  Binds  Ts...  to  T  object  boundable    in(const TScope )  scopable TScope>  Binds  Ts...  into  TScope  boundable    named(const TName )  -  Binds  Ts...  using 'Named' annotation  boundable    operator[](const override )  -  Overrides given binding  boundable     Test         Example", 
            "title": "Bindings"
        }, 
        {
            "location": "/user_guide/index.html#injections", 
            "text": "Constructor Injection  is the most powerful of available injections.\nIt guarantees initialized state of data members. Boost.DI constructor injection is achieved without any additional work from the user.  \n---  automatic (default)  ---  Header  #include  boost/di.hpp   Description  Boost.DI will deduce the best available constructor to be used for injection - unique constructor with the longest parameter list.\nIf the default behavior should be changed constructor has to be explicitly marked with  BOOST_DI_INJECT  or  BOOST_DI_INJECT_TRAITS .", 
            "title": "Injections"
        }, 
        {
            "location": "/user_guide/index.html#annotations", 
            "text": "Annotations are intrusive, additional informations specified along with the type in order to refer to given type by the\nannotation instead of type it self. Useful, when there are more than one type of the same parameters in constructor parameters.  \n---  (named = name)  ---  Header  #include  boost/di.hpp   Description  Named parameters are useful when constructor has more parameters of the same type.    T(int value1, int value2);  In order to inject proper values into  value1  and  value2  they have to be distinguished somehow.\nBoost.DI solution for that problem are annotations.", 
            "title": "Annotations"
        }, 
        {
            "location": "/user_guide/index.html#scopes", 
            "text": "Header  #include  boost/di.hpp   Description  Scopes are responsible for creating and maintaining life time of dependencies.\nIf no scope will be given, deduce scope will be assumed.  Semantics  template  class TExpected, class TGiven \nstruct scope {\n  template  class T \n  using is_referable;\n\n  template  class T, class TName, class TProvider \n  static auto try_create(const TProvider );\n\n  template  class T, class TName, class TProvider \n  auto create(const TProvider );\n};     Expression  Requirement  Description  Returns      TExpected  -  'Interface' type  -    TGiven  -  'Implementation' type  -    is_referable T\\  -  Verifies whether scope value might be converted to a reference  std::true_type/std::false_type    try_create T, TName, TProvider\\  providable TProvider>  Verifies whether type might be created  std::true_type/std::false_type    create T, TName, TProvider\\  providable TProvider>  Creates type might be created  T        Type/Scope  unique  singleton  instance        T  \u2714  -  \u2714      T  -  \u2714  \u2714      const T  \u2714 (temporary)  \u2714  \u2714      T* (transfer ownership)  \u2714  -  -  -  \u2714    const T*  \u2714  -  \u2714      T  \u2714  -  -      unique_ptr  \u2714  -  \u2714      shared_ptr  \u2714  \u2714  \u2714      weak_ptr  -  \u2714  \u2714       Test   Example       \n---  di::deduce (default)  ---  Header  #include  boost/di.hpp   Description  Default scope which will be converted to one of the scopes depending on the type.     Type  deduce      T  unique    T  singleton    const T  unique  (temporary)/singleton    T*  unique  (ownership transfer)    const T*  unique  (ownership transfer)    T  unique    unique_ptr  unique    shared_ptr  singleton    weak_ptr  singleton     Semantics  namespace scopes {\n  struct deduce {\n    template  class TExpected, class TGiven \n    struct scope {\n      template  class T \n      using is_referable;\n\n      template  class T, class TName, class TProvider \n      static auto try_create(const TProvider );\n\n      template  class T, class TName, class TProvider \n      auto create(const TProvider );\n    };\n  };\n}\n\nscopes::deduce deduce;     Expression  Requirement  Description  Returns      TExpected  -  'Interface' type  -    TGiven  -  'Implementation' type  -    is_referable T\\  -  Verifies whether scope value might be converted to a reference  std::true_type/std::false_type    try_create T, TName, TProvider\\  providable TProvider>  Verifies whether type might be created  std::true_type/std::false_type    create T, TName, TProvider\\  providable TProvider>  Creates type might be created  T     Test   Example     \n---  di::instance (di::bind .to(value))  ---  Header  #include  boost/di.hpp   Description  Scope representing values - passed by user. The life time of the object depends on the user.\nBoost.DI is not managing life time of passed objects, however values and strings will be copied and managed by the library.     Type  instance      T  \u2714    T  -    const T  \u2714 (temporary)    T* (transfer ownership)  \u2714    const T*  \u2714    T  \u2714    unique_ptr  \u2714    shared_ptr  \u2714    weak_ptr  -     Semantics  namespace scopes {\n  struct instance {\n    template  class TExpected, class TGiven \n    struct scope {\n      template  class T \n      using is_referable;\n\n      template  class T, class TName, class TProvider \n      static auto try_create(const TProvider );\n\n      template  class T, class TName, class TProvider \n      auto create(const TProvider );\n    };\n  };\n}     Expression  Requirement  Description  Returns      TExpected  -  'Interface' type  -    TGiven  -  'Implementation' type  -    is_referable T\\  -  Verifies whether scope value might be converted to a reference  std::true_type/std::false_type    try_create T, TName, TProvider\\  providable TProvider>  Verifies whether type might be created  std::true_type/std::false_type    create T, TName, TProvider\\  providable TProvider>  Creates type might be created  T     Test   Example     \n---  di::singleton  ---  Header  #include  boost/di.hpp   Description  Scope representing shared value between all instances and between threads.\nSingleton scope will be deduced in case of shared_ptr or weak_ptr.", 
            "title": "Scopes"
        }, 
        {
            "location": "/user_guide/index.html#modules", 
            "text": "auto module = [] { return di::make_injector(...); };  Header  #include  boost/di.hpp   Description  Modules allow to split the configuration into smaller injectors.\nModule might be installed by passing it into [make_injector].  Semantics  auto module = di::make_injector(...);  Test       Example", 
            "title": "Modules"
        }, 
        {
            "location": "/user_guide/index.html#providers", 
            "text": "Header  #include  boost/di.hpp   Description  Providers are responsible for creating objects using given configuration.  Semantics  namespace type_traits {\n  struct direct; // T(...)\n  struct uniform; // T{...}\n  struct heap; // new T\n  struct stack; // T\n}\n\nnamespace providers {\n  class provider {\n    public:\n      template  class T, class... TArgs \n      struct is_creatable;\n\n      template  \n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n        auto get(const TInit , const TMemory , TArgs ... args) const;\n  };\n}     Expression  Requirement  Description  Returns      is_creatable T, TArgs...\\  creatable TArgs...>  Verify whether  T  is creatable with  TArgs...  T    get T, TInitialization, TMemory, TArgs\\ (const TInitialization , const TMemory , TArgs ...)  TInitialization  is direct\\  uniform    TMemory  is heap\\  stack     Test   Example     \n---  di::providers::stack_over_heap (default)  ---  Header  #include  boost/di.hpp   Description  Creates objects on the stack whenever possible, otherwise on the heap.  Semantics  namespace providers {\n  class stack_over_heap {\n    public:\n      template  class T, class... TArgs \n      struct is_creatable;\n\n      template  \n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n        auto get(const TInit , const TMemory , TArgs ... args) const;\n  };\n}     Expression  Requirement  Description  Returns      is_creatable T, TArgs...\\  creatable TArgs...>  Verify whether  T  is creatable with  TArgs...  T    get T, TInitialization, TMemory, TArgs\\ (const TInitialization , const TMemory , TArgs ...)  TInitialization  is direct\\  uniform    TMemory  is heap\\  stack        Type  TMemory      T  stack    T  stack    const T  stack    T*  stack    const T*  stack    T  stack    unique_ptr  stack    shared_ptr  stack    weak_ptr  stack     Test   Example     \n---  di::providers::heap  ---  Header  #include  boost/di.hpp   Description  Basic provider creates objects on the heap.  Semantics  namespace providers {\n  class stack_over_heap {\n    public:\n      template  class T, class... TArgs \n      struct is_creatable;\n\n      template  \n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n        auto get(const TInit , const TMemory , TArgs ... args) const;\n  };\n}     Expression  Requirement  Description  Returns      is_creatable T, TArgs...\\  creatable TArgs...>  Verify whether  T  is creatable with  TArgs...  T    get T, TInitialization, TMemory, TArgs\\ (const TInitialization , const TMemory , TArgs ...)  TInitialization  is direct\\  uniform    TMemory  is heap\\  stack        Type  TMemory      T  stack    T  stack    const T  stack    T*  stack    const T*  stack    T  stack    unique_ptr  stack    shared_ptr  stack    weak_ptr  stack     Test   Example", 
            "title": "Providers"
        }, 
        {
            "location": "/user_guide/index.html#policies", 
            "text": "Header  #include  boost/di.hpp   Description  Policies operates on dependencies in order to limit allowed behaviour or visit created types during run-time.\nPolicies are set up via [di::config].", 
            "title": "Policies"
        }, 
        {
            "location": "/user_guide/index.html#concepts", 
            "text": "Concepts are types constraints which ensure that only given types which are satisfied by the constraint will be allowed.\nIf type doesn't satisfy the concept short and descriptive error message is provided.  \n---  di::concepts::boundable  ---  Header  #include  boost/di.hpp   Description  Bindings type requirement.  Synopsis  template  class TExpected, class TGiven \nconcept bool boundable() {\n  return is_complete TExpected ()\n        is_complete TGiven ()\n        (is_base_of TExpected, TGiven () || is_convertible TGiven, TExpected ());\n}\n\ntemplate  class... Ts \nconcept bool boundable() {\n  return is_supported Ts ()... \n        is_movable Ts ()...\n        (is_base_of injector, Ts ()... || is_base_of dependency, Ts ()...);\n}  Semantics  boundable T \nboundable Ts...      Expression  Description  Returns      Ts...  Bindings to be verified  true_type if constraint is satisfied,  error  otherwise     Example     Error  type T ::has_disallowed_qualifiers      Description  type  T  has disallowed qualifiers    Expression         Error  type T ::is_abstract      Description  type  T  is abstract    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0, 1 -  no additional info, 2 -  info about why type  T  is abstract    Expression         Error  type T ::is_not_related_to      Description  type  T  is not related to type  U    Expression         Error  type T ::is_bound_more_than_once      Description  type  T  is bound more than once    Expression         Error  type T ::is_neither_a_dependency_nor_an_injector      Description  type  T  is neither a dependency nor an injector    Expression       \n---  di::concepts::callable  ---  Header  #include  boost/di.hpp   Description  Policies type requirement.  Synopsis  template  class T \nconcept bool callable() {\n  return requires(T object) {\n    { object(...) };\n  }\n}  Semantics  callable T   Example     Error  policy TPolicy ::requires_ call_operator      Description  policy  TPolicy  requires a call operator    Expression       \n---  di::concepts::configurable  ---  Header  #include  boost/di.hpp   Description  Synopsis  template  class T \nconcept bool configurable() {\n  return requires(T object) {\n    return providable decltype(T::provider(...))    callable decltype(T::policies(...)) ();\n  }\n}  Semantics  configurable T   Example     Error  config TConfig ::requires_ provider providable_type (...)      Description  config  T  requires only providable and callable types    Expression       \n---  di::concepts::creatable  ---  Header  #include  boost/di.hpp   Description  Type creation requirement.  Synopsis  template  class T, class... TBindings \nconcept bool creatable() {\n  return is_recursively_constructible T, TBindings... ();\n}  Semantics  creatable T, TBindings...   Example     Error  abstract_type T ::is_not_bound      Description  config  T  requires only providable and callable types    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0 -  'constraint not satisfied', 1 -  (0) + abstract type is not bound, 2 -  (1) + creation tree    Suggestion  'type is not bound, did you forget to add: 'di::bind .to ()'?'    Expression     Expression         Error  type T ::has_ambiguous_number_of_constructor_parameters::given Given ::expected Expected      Description  type  T  has ambiguous number of constructor parameters where  Given  were provided but  Expected  were expected    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0 -  'constraint not satisfied', 1 -  (0) + abstract type is not bound, 2 -  (1) + creation tree    Suggestion  'verify BOOST_DI_INJECT_TRAITS or di::ctor_traits'    Expression         Error  type T ::has_to_many_constructor_parameters::max Max      Description  type  T  has to many constructor parameter where maximum number is  Max    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0 -  'constraint not satisfied', 1 -  (0) + abstract type is not bound, 2 -  (1) + creation tree    Suggestion  'increase BOOST_DI_CFG_CTOR_LIMIT_SIZE value or reduce number of constructor parameters'    Expression         Error  scoped TScope ::is_not_convertible_to T      Description  scope  TScope  is not convertible to type  T    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0 -  'constraint not satisfied', 1 -  (0) + abstract type is not bound, 2 -  (1) + creation tree    Suggestion  'scoped object is not convertible to the requested type, did you mistake the scope: 'di::bind .in(scope)'?'    Expression         Error  scoped instance ::is_not_convertible_to T      Description  instance is not convertible to type  T    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0 -  'constraint not satisfied', 1 -  (0) + abstract type is not bound, 2 -  (1) + creation tree    Suggestion  'instance is not convertible to the requested type, verify binding: 'di::bind .to(value)'?'    Expression", 
            "title": "Concepts"
        }, 
        {
            "location": "/user_guide/index.html#configuration", 
            "text": "---  di::config  ---  Header  #include  boost/di.hpp   Description  Injector configuration.  Synopsis  struct config {\n  static auto provider(...) noexcept;\n  static auto policies(...) noexcept;\n};     Expression  Requirement  Description  Returns      provider()  providable  Creates provider  providable    policies()  callable  Creates policies  callable        Expression  Description      BOOST_DI_CFG  Global configuration allows to customize provider and policies     Semantics  di::make_injector config (...)\n// or\n#define BOOST_DI_CFG config // change default\ndi::make_injector(...)  Test   Example", 
            "title": "Configuration"
        }, 
        {
            "location": "/examples/index.html", 
            "text": "Hello World\n\n\nBindings\n\n\nDynamic Bindings\n\n\nForward Bindings\n\n\nMultiple Bindings\n\n\nBinding Non-owning Pointer\n\n\nAutomatic Injection\n\n\nConstructor Signature\n\n\nConstructor Injection\n\n\nMultiple Interface\n\n\nAnnotations\n\n\nDeduce Scope\n\n\nCustom Scope\n\n\nEager Singletons\n\n\nModules\n\n\nModules (hpp/cpp)\n\n\nCustom Policy\n\n\nCustom Provider\n\n\nPool Provider\n\n\nConfiguration\n\n\n\n\n\n\nHello World\n\n\n\n\nBindings\n\n\n\n\nDynamic Bindings\n\n\n\n\nForward Bindings\n\n\n\n\nMultiple Bindings\n\n\n\n\nBinding Non-owning Pointer\n\n\n\n\nAutomatic Injection\n\n\n\n\nConstructor Signature\n\n\n\n\nConstructor Injection\n\n\n\n\nMultiple Interface\n\n\n\n\nAnnotations\n\n\n\n\nDeduce Scope\n\n\n\n\nCustom Scope\n\n\n\n\nEager Singletons\n\n\n\n\nModules\n\n\n\n\nModules (hpp/cpp)\n\n\n\n\nSee \nhttps://github.com/boost-experimental/di/tree/cpp14/example/modules\n\n\n\n\nCustom Policy\n\n\n\n\nCustom Provider\n\n\n\n\nPool Provider\n\n\n\n\nConfiguration", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/index.html#hello-world", 
            "text": "", 
            "title": "Hello World"
        }, 
        {
            "location": "/examples/index.html#bindings", 
            "text": "", 
            "title": "Bindings"
        }, 
        {
            "location": "/examples/index.html#dynamic-bindings", 
            "text": "", 
            "title": "Dynamic Bindings"
        }, 
        {
            "location": "/examples/index.html#forward-bindings", 
            "text": "", 
            "title": "Forward Bindings"
        }, 
        {
            "location": "/examples/index.html#multiple-bindings", 
            "text": "", 
            "title": "Multiple Bindings"
        }, 
        {
            "location": "/examples/index.html#binding-non-owning-pointer", 
            "text": "", 
            "title": "Binding Non-owning Pointer"
        }, 
        {
            "location": "/examples/index.html#automatic-injection", 
            "text": "", 
            "title": "Automatic Injection"
        }, 
        {
            "location": "/examples/index.html#constructor-signature", 
            "text": "", 
            "title": "Constructor Signature"
        }, 
        {
            "location": "/examples/index.html#constructor-injection", 
            "text": "", 
            "title": "Constructor Injection"
        }, 
        {
            "location": "/examples/index.html#multiple-interface", 
            "text": "", 
            "title": "Multiple Interface"
        }, 
        {
            "location": "/examples/index.html#annotations", 
            "text": "", 
            "title": "Annotations"
        }, 
        {
            "location": "/examples/index.html#deduce-scope", 
            "text": "", 
            "title": "Deduce Scope"
        }, 
        {
            "location": "/examples/index.html#custom-scope", 
            "text": "", 
            "title": "Custom Scope"
        }, 
        {
            "location": "/examples/index.html#eager-singletons", 
            "text": "", 
            "title": "Eager Singletons"
        }, 
        {
            "location": "/examples/index.html#modules", 
            "text": "", 
            "title": "Modules"
        }, 
        {
            "location": "/examples/index.html#modules-hppcpp", 
            "text": "See  https://github.com/boost-experimental/di/tree/cpp14/example/modules", 
            "title": "Modules (hpp/cpp)"
        }, 
        {
            "location": "/examples/index.html#custom-policy", 
            "text": "", 
            "title": "Custom Policy"
        }, 
        {
            "location": "/examples/index.html#custom-provider", 
            "text": "", 
            "title": "Custom Provider"
        }, 
        {
            "location": "/examples/index.html#pool-provider", 
            "text": "", 
            "title": "Pool Provider"
        }, 
        {
            "location": "/examples/index.html#configuration", 
            "text": "", 
            "title": "Configuration"
        }, 
        {
            "location": "/extensions/index.html", 
            "text": "Constructor Bindings\n\n\nAssisted Injection\n\n\nConcepts\n\n\nLazy\n\n\nNamed Parameters\n\n\nXML Injection\n\n\nTypes Dumper\n\n\nUML Dumper\n\n\nMocks Provider\n\n\nScoped Scope\n\n\nSession Scope\n\n\nShared Scope\n\n\n\n\n\n\nConstructor Bindings\n\n\n\n\nAssisted Injection\n\n\n\n\nConcepts\n\n\n\n\nLazy\n\n\n\n\nNamed Parameters\n\n\n\n\nXML Injection\n\n\n\n\nTypes Dumper\n\n\n\n\nUML Dumper\n\n\n\n\nMocks Provider\n\n\n\n\nScoped Scope\n\n\n\n\nSession Scope\n\n\n\n\nShared Scope", 
            "title": "Extensions"
        }, 
        {
            "location": "/extensions/index.html#constructor-bindings", 
            "text": "", 
            "title": "Constructor Bindings"
        }, 
        {
            "location": "/extensions/index.html#assisted-injection", 
            "text": "", 
            "title": "Assisted Injection"
        }, 
        {
            "location": "/extensions/index.html#concepts", 
            "text": "", 
            "title": "Concepts"
        }, 
        {
            "location": "/extensions/index.html#lazy", 
            "text": "", 
            "title": "Lazy"
        }, 
        {
            "location": "/extensions/index.html#named-parameters", 
            "text": "", 
            "title": "Named Parameters"
        }, 
        {
            "location": "/extensions/index.html#xml-injection", 
            "text": "", 
            "title": "XML Injection"
        }, 
        {
            "location": "/extensions/index.html#types-dumper", 
            "text": "", 
            "title": "Types Dumper"
        }, 
        {
            "location": "/extensions/index.html#uml-dumper", 
            "text": "", 
            "title": "UML Dumper"
        }, 
        {
            "location": "/extensions/index.html#mocks-provider", 
            "text": "", 
            "title": "Mocks Provider"
        }, 
        {
            "location": "/extensions/index.html#scoped-scope", 
            "text": "", 
            "title": "Scoped Scope"
        }, 
        {
            "location": "/extensions/index.html#session-scope", 
            "text": "", 
            "title": "Session Scope"
        }, 
        {
            "location": "/extensions/index.html#shared-scope", 
            "text": "", 
            "title": "Shared Scope"
        }, 
        {
            "location": "/CHANGELOG/index.html", 
            "text": "1.0.0\n - TBD\n\n\n\n\nSupport for MSVC-2015+\n\n\nSupport for GCC-5+\n\n\nSupport for CMake 2.8+\n\n\nSupport for libc++, libstdc++\n\n\nSupport for clang-format\n\n\n\n\n0.5.0\n - 2015-01-12\n\n\n\n\nC++14 version\n\n\nSupport for Clang3.4+\n\n\n\n\n0.1.0\n - 2014-08-15\n\n\n\n\nC++03/C++11 version\n\n\nSupport for Clang3.2+", 
            "title": "CHANGELOG"
        }, 
        {
            "location": "/CHANGELOG/index.html#100-tbd", 
            "text": "Support for MSVC-2015+  Support for GCC-5+  Support for CMake 2.8+  Support for libc++, libstdc++  Support for clang-format", 
            "title": "1.0.0 - TBD"
        }, 
        {
            "location": "/CHANGELOG/index.html#050-2015-01-12", 
            "text": "C++14 version  Support for Clang3.4+", 
            "title": "0.5.0 - 2015-01-12"
        }, 
        {
            "location": "/CHANGELOG/index.html#010-2014-08-15", 
            "text": "C++03/C++11 version  Support for Clang3.2+", 
            "title": "0.1.0 - 2014-08-15"
        }, 
        {
            "location": "/TODO/index.html", 
            "text": "", 
            "title": "TODO"
        }
    ]
}