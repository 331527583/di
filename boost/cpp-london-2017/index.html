<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Boost your design with C++14 dependency injection</title>

		<meta name="description" content="Boost your design with C++14 dependency injection">
		<meta name="author" content="Kris Jusiak">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/league.css" id="theme">

		<!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<div class="slides">

          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$"
                   data-notes="^Note:">
					<script type="text/template">

C++ London Feb-2017

#Boost your design with dependency injection

Kris Jusiak

---

[kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)

==============================================================================

##Disclaimer

###Simple examples but let's think large scale.

Let's think about big team projects.

----

#Story:  (BDD Style)

Scenario 1:

----

#In search of the best design!

----

## KISS - ~~Keep it simple~~, STUPID

```cpp
int main() {
  auto value = 0;
  {
    std::filestream file{"input.txt"};
    file >> value;
  }
  std::cout << value << '\n';
}
```

----

* (+) Does it job!
* (-) Hard to test
* (-) Hard to do TDD and/or BDD

Good pracieses are good practices for a reason!

----

##Let's introduce some abstractions

```cpp
class Reader {
  static constexpr auto name = "input.txt";
  std::filestream file{name};

public:
  auto read() {
    auto value = 0;
    file >> value;
    return value;
  }
};
```

```cpp
class Viewer {
  public:
    void show(int value) {
      std::cout << value << '\n';
    }
};
```

----

##Let's introduce some abstractions

```cpp
class App {
  Reader reader;
  Viewer viewer;

  void run() {
    viewer.show(reader.read());
  }
};
```

```cpp
int main() {
  App{}.run();
}
```

----

![app0](images/app0.png)

----

* (+) Does it job!
* (-) Hard to test
* (-) Hard to do TDD and/or BDD

----

##Composition Root

> Unique location in an application where modules are composed together

```cpp
int main() {
  App{}.run();
}
```

----

###First injection

```cpp
class Reader;
class Viewer;
```

```cpp
class App {
 Reader reader;
 Viewer viewer;

 public:
  App(Reader&& reader, Viewer&& viewer)
    : reader(std::move(reader))
    , viewer(std::move(viewer))
  { }

  void run() {
    viewer.show(reader.read());
  }
};
```

```cpp
int main() {
  Reader reader;
  Viewer viewer;
  App app{std::move(reader), std::move(viewer)};

}
```

----

![app1](images/app1.png)

----

* (+) Does it job!
* (-) Hard to test
* (-) Hard to do TDD and/or BDD

----

##Policy Design (Duck typing)

```cpp
class Reader;
class Viewer;
```

```cpp
template<class TReader, class TViewer>
class App {
  TReader reader;
  TViewer viewer;

public:
  App(TReader& reader, TViewer& viewer)
    : reader(reader), viewer(viewer)
  { }

  void run() {
    viewer.show(reader.read());
  }
};
```

```cpp
int main() {
  Reader reader;
  Viewer viewer;
  App<Reader, Viewer> app{reader, viewer};
  app.run();
}
```

----

* (-) template propages
```cpp
Viewer request a type has to be passed via App
```
* (-) oOmpilation times (POI)
* (-) Not meaningufl errors (Duck typing)
* (+) Easier to test, although we don'tknow what

----

##Static Polymorphism
####Curiously recurring template pattern (CRTP)

```cpp
template<class T> 
struct Reader {
  void read() {
    static_cast<T*>(this)->read(value);
  }
}
```

```cpp
template<class T> 
struct Viewer {
  void show(int value) {
    static_cast<T*>(this)->show(value);
  }
}
```

```cpp
class App {
  // TODO
};
```

----

* (-) template propages
```cpp
Viewer request a type has to be passed via App
```
* (-) oOmpilation times (POI)
* (-) Not meaningufl errors (Duck typing)
* (+) Easier to test, although we don'tknow what

----

##Dynamic Polymorphism

```cpp
class IReader {
public:
  virtual ~IReader() noexcept = default;
  virtual int read() = 0;
};
```

```cpp
class FileReader : public IReader {
public:
  FileReader(std::string_view path);
  void read() override;
};
```

```cpp
class IViewer {
public:
  virtual ~IViewer() noexcept = default;
  virtual void show(int) = 0;
};
```

```cpp
class ConsoleViewer : public IViewer {
  void show(int) override;
};
```

----

##Single responsibility principle

> "A class should have only one reason to change" Unclue Bob

----

```cpp
class App {
  std::unique_ptr<IReader<int>> reader =
    std::make_uniqe<FileReader>("input.txt");

  std::unique_ptr<IViewer<int>> viewer =
    std::make_uniqe<ConsoleViewer>();

public:
  void run() {
    viewer->show(reader->read());
  }

};
```

```cpp
int main() {
  App{}.run();
}
```

----

![app](images/app.png)

* Loosely coupled
* easy to test

----

* (-) Peformance?
* (-) oOmpilation times (POI)
* (-) Not meaningufl errors (Duck typing)
* (+) Easier to test, although we don'tknow what

----

##Dynamic Polymorphism performance
####final keyword and Devirtualization

![final](images/final.png)
https://godbolt.org/g/e8olYN

----

##Static factory

```cpp
class IReader; class FileReader;
class IViewer; class ConsoleViewer;
```

```cpp
struct ReaderFactory {
  static auto create(std::string_view input) {
    return std::make_unique<FileReader>(input);
  }
};
```

```cpp
struct ViewerFactory {
  static auto create() {
    return std::make_unique<ConsoleViewer>();
  }
};
```

----

```cpp
class App {
public:
  void run() {
    ViewerFactory::create()->show(
      ReaderFactory::create("input.txt")->read()
    );
  }

};
```

```cpp
int main() {
  App{}.run();
}
```

----

* (-) Peformance?
* (-) oOmpilation times (POI)
* (-) Not meaningufl errors (Duck typing)
* (+) Easier to test, although we don'tknow what

----

```cpp
class IReader; class FileReader;
class IViewer; class ConsoleViewer;
```

```cpp
class App {
  IReader& reaer;
  IViewer& viewer;

public:
  App(IReader& reader, IViewer& viewer)
    : reader(reader), viewer(viewer) {}

  void run() {
    viewer.show(reader.read());
  }
};
```

```cpp
int main() {
  auto reader = std::make_unique<FileReader>("input.txt");
  auto viewer = std::make_unique<ConsoleViewer>());

  App{*reader, *viewer}.run();
}
```

----

* (-) Wiring Mess
* (+) TDD/BDD easy to mock
* (+) Reusable

----

##Dependency Injection (DI)

> "Don't call us, we'll call you", Hollywood principle

----

> It's all about the construction!

----

##Testing

> "If you liked it then you should have put a test on it", Beyonce rule

----

```cpp
"should show read text"_test = [] {
  constexpr auto value = 42;

  auto [sut, mocks] = make<App>();

  InSequence sequence;
  EXPECT_CALL(mocks<IReader>, read()).WillOnce(Return(value));
  EXPECT_CALL(mocks<IViewer>, show(value));

  sut.run();
};
```

----

##Weak vs Strong interface

```cpp
class QtViewer {
public:
  QtViewer(int width, int height); // weak
};

QtViewer(600, 800); // Okay
QtViewer(800, 600); //oops

class QtViewer {
public:
  QtViewer(width, height); // strong types
};

QtViewer(witdth{500}, height{800}); // Okay
QtViewer(height{500}, width{800}); // COmpile error
QtViewer(500, 800); // COmpile error
```

----

##C++2X?

```cpp
template <class T>
concept bool Readable() {
  return requires(T reader) {
    { reader.read(std::string_view{}) } -> auto;
  }
};
```

```cpp
template <class T>
concept bool Viewable() {
  return requires(T viewer) {
    { viewer.show() };
  }
};
```

----

```cpp
class App {
  virtual Readable reaer; // stack, Small Buffer Optimization
  virtual Viewable viewer; // type erasure

public:
  App(Readable reader, Viewable viewer) // template<Readable...
    : reader(reader), viewer(viewer) {}

  void run() {
    viewer.show(reader.read());
  }
};
```

----

```cpp
int main() {
  Readable reader = FileReader{"input.txt"};
  Viewable viwer = ConsoleViewer();

  App{reader, viewer}.run();
}
```

| | |
|-|-|
|Concepts lite | http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3580.pdf |
|Virtual concepts | https://github.com/andyprowl/virtual-concepts/blob/master/draft/Dynamic%20Generic%20Programming%20with%20Virtual%20Concepts.pdf |

----

* ###Single Responsiliby = A lot of classes = A lot wiring = Wiring Mess

* ###Wiring mess = Hard to exend = woraround under preasure

-----

###Solution => Automate that => [Boost].DI

> Separate creation logic from business logic, which means that your code
should be free of object creation inside other objects.

==============================================================================

##[Boost].DI

* One header - 3k LOC - (boost/di.hpp) / generated
* Neither Boost nor STL is required
* No 'if's, 'virtual', 'exceptions' (-fno-rtti, -fno-exceptions)
* Non-intrusive (constructor parameters deduction)
* Compile-time creation guarantee (no run-time errors)
* Supported compilers (C++14)
  * [Clang-3.4+](https://travis-ci.org/boost-experimental/di), [XCode-6.1+](https://travis-ci.org/boost-experimental/di), [GCC-5.2+](https://travis-ci.org/boost-experimental/di), [MSVC-2015+](https://ci.appveyor.com/project/krzysztof-jusiak/di)

----

##[Boost].DI - Removing the wiring mess

```cpp
#include <boost/di.hpp>
namespace di = boost::di;
```

```cpp
class IReader;
class IViewer;
```

```cpp
class App {
 public:
  App(const IReader&, const IViewer&); // DI handles
};                  ^       ^          // order and types
                    |       \----------------------\
                    \-----------------------\      |
int main() {                                |      |
  const auto injector = di::make_injector(  |      |
     di::bind<IReader>.to<FileReader>(), ---/      |
     di::bind<IViewer>.to<ConsoleViewer>() --------/
  );

  injector.create<App>().run();
}
```

----

##[Boost].DI - Performance

```sh
time $CXX -std=c++14 app.cpp # 0.092s
```

####ASM x86-64

```
push   %rbx
mov    %rdi,%rbx
mov    $0x8,%edi
callq  0x4009f0 <_Znwm@plt>
movq   $0x400e78,(%rax)
mov    %rax,(%rbx)
mov    %rbx,%rax
pop    %rbx
retq
```

####Same as

```cpp
return make_unique<App>(...);
```

----

##Benchmarks (GCC-6/Java8)

| 64 types, 1-4 ctor params, 1024 iterations | **[Boost].DI** | **Guice** | **Dagger2** |
| --------------------- | ------------ | ---------------- | ------------- |
| Compilation time    | 0.376s       |  0.570s            | 1.411s        |
| Execution time      | 0.002s       |  0.528s            | 0.157s        |

---

| 256 types, 1-4 ctor params, 1024 iterations | **[Boost].DI** | **Guice** | **Dagger2** |
| --------------------- | ------------ | ---------------- | ------------- |
| Compilation time    | 0.706s       | 0.642s             | 1.903s        |
| Execution time      | 0.002s       | 0.544s             | 0.210s        |

----

##[Boost].DI - Compile-time errors

```cpp
const auto injector = di::make_injector(
// di::bind<IViewer>.to<ConsoleViewer>(), // missing 'IViewer' binding
   di::bind<IReader>.to<FileReader>()
);
auto app = injector.create<App>();
```

####Full Compilation-Time Error Message

```cpp
error: 'create<App>' is deprecated: creatable constraint
  injector.create<App>();           not satisfied
           ^
note 'create<App>' has been explicitly marked deprecated here
  create
  ^
error: inline function 'abstract_type<IViewer>::is_not_bound::error'
 error(_ = "type is not bound, did you forget to add:
           'di::bind<interface>.to<implementation>()'?");
```

----

##[Boost].DI - API

###Injector
```cpp
template<class... TDeps> requires boundable<TDeps...>()
class injector {
public:
  explicit injector(TDeps&&...) noexcept;
  injector(injector&&) = default;
  injector& operator=(injector&&) = default;

  template<class T> requires creatable<T>()
  constexpr T create() const;
};
```

###Make injector
```cpp
template<class TConfig = di::config, class... TDeps>
  requires configurable<TConfig>() && boundable<TDeps...>()
auto make_injector(TDeps&&...) noexcept;
```

----

###Injection

##Let's come back to our example
```cpp
class Reader;
class Viewer;
```

```cpp
class App {
 Reader reader;
 Viewer viewer;

public:
  App(Reader&& reader, Viewer&& viewer)
    : reader(std::move(reader))
    , viewer(std::move(viewer))
  {}

  void run() {
    viewer.show(reader.read());
  }
};
```

----

##Manual DI
```cpp
int main() {
  Reader reader;
  Viewer viewer;
  App app{std::move(reader), std::move(viewer)};
  app.run();
}
```

##[Boost].DI
```cpp
int main() {
  di::make_injector().create<App>().run();
}
```

----

##Refactoring fore free!

####Let's change App constructor

```cpp
  App(Viewer& viewer, std::unique_ptr<Reader> reader)
    : viewer(viewer)
    , reader(std::move(reader))
  {}
```

----

##Manual DI
```cpp
int main() {
  auto reader = std::make_unique<Reader>{};
  Viewer viewer;
  App app{viewer, std::move(reader)};
  app.run();
}
```

##[Boost].DI
```cpp
int main() {
  di::make_injector().create<App>().run(); // same as before!
}
```

----

##Scoped deduction

###Unique scope
```cpp
assert(injector.create<std::unique_ptr<IViewer>>().get()
    != injector.create<std::unique_ptr<IViewer>>().get());
```

###Singleton scope
```cpp
assert(injector.create<std::shared_ptr<IViewer>>() 
    == injector.create<std::shared_ptr<IViewer>>());
```

```cpp
assert(&injector.create<IViewer&>>() 
    == injector.create<std::shared_ptr<IViewer>>().get());
```

----

##Scoped deduction

| Type | Scope |
|------|-------|
| `T`, `T&&`, `owner<T*>`,  `unique_ptr<T>` | [Unique scope](http://boost-experimental.github.io//di/user_guide/index.html#di_unique) |
| `T&`, `const T&`, `T*`, `const T*`, `shared_ptr<T>`, `boost::shared_ptr<T>`, `weak_ptr<T>` | [Singleton scope](http://boost-experimental.github.io//di/user_guide/index.html#di_singleton) |

----

##Implementing features by wiring

Scenario 2
If command line 
New Scenario

----

###Configuration module
```cpp
const auto config = [](std::string_view view) {
  return di::make_injector(
     di::bind<IReader>.to<FileReader>(),
     di::bind<IViewer>.to([&](const auto& injector) {
       if (argv[1] == "QtViewer") {
          return injector.create<QtViewer&>();
       } else if (argv[1] == "ConsoleViewer") {
          return injector.create<ConsoleViewer&>();
       }
     })
  );
};
```

```cpp
int main(int argc, char** argv) {
  assert(2 == argc);
  config(argv[1]).create<App>().run();
}
```

----

Functional DI?

```cpp
using fview = std::function<void(int)>;
using fread = std::function<int()>;
```

```cpp
const auto fileRead = [](std::string_view path) {
  return [=] {
    auto value = 0;
    {
      std::fstream file{path};
      file >> value;
    }
    return value;
  };
};
```

```cpp
const auto consoleView = [](int value) {
  std::cout << value << '\n';
};
```

----

```cpp
class App {
  fview view;
  fread read;

 public:
   App(const fview& view, const fread& read)
     : view(view), read(read)
   { }

   void run() {
     view(read());
   }
};
```

```cpp
const auto injector = di::make_injector(
    di::bind<fview>.to(consoleView)
  , di::bind<fread>.to(fileRead("input.txt"))
);

injector.create<App>().run();
```

----

##More features

* Policies
  * Example - Disallow passing by raw pointer without markup ownership explicitly 
* Automatic mocks injection
  * Creates and inject mocks automatically
* Serialization
  * Serialize all POD's in the App
* Dependencies diagram generation

==============================================================================

##Summary

----

##STUPID vs SOLID

<table><tr>
 <td>
  <table>
    <tr><td><b>S</b></td><td>Singleton</td></tr>
    <tr><td><b>T</b></td><td>Tight Coupling</td></tr>
    <tr><td><b>U</b></td><td>Untestability</td></tr>
    <tr><td><b>P</b></td><td>Premature Optimization</td></tr>
    <tr><td><b>I</b></td><td>Indescriptive Naming</td></tr>
    <tr><td><b>D</b></td><td>Duplication</td></tr>
  </table>
 </td>

 <td>
  <table>
    <tr><td><b>S</b></td><td><b>Single Responsibility</b></td></tr>
    <tr><td><b>O</b></td><td>Open-close</td></tr>
    <tr><td><b>L</b></td><td>Liskov substitution</td></tr>
    <tr><td><b>I</b></td><td>Interface segregation</td></tr>
    <tr><td><b>D</b></td><td><b>Dependency injection</b></td></tr>
  </table>
 </td>

 </tr>
</table>
> "Clean Code", Unclue Bob

----

##Dependency Injection

* A powerful design pattern helping with creating
  * Loosely Coupling
  * Easy to test code (TDD)

* [Boost].DI
  * Removes wiring mess (boilerplate code)
  * Simplify refactoring
  * Make testing easier (automatic mocks injection)

==============================================================================

##Questions?

| [Boost].DI |  |
| ------- | ------------- |
| Documentation | http://boost-experimental.github.io/di |
| Source Code | https://github.com/boost-experimental/di |
| Try it online! | http://boost-experimental.github.io/di/try_it/index.html |
|                | https://godbolt.org/g/dvjJFI |
<!-- .element: style="margin-left:-13%; width:125%" -->

-

[kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)


					</script>
				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({

        // Display controls in the bottom right corner
        controls: true,

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: true,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'convex', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
