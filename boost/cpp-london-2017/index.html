<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Boost your design with C++14 dependency injection</title>

		<meta name="description" content="Boost your design with C++14 dependency injection">
		<meta name="author" content="Kris Jusiak">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/league.css" id="theme">

		<!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<div class="slides">

          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$"
                   data-notes="^Note:">
					<script type="text/template">

C++ London Feb-2017

#Boost your design with dependency injection

Kris Jusiak

---

[kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)

==============================================================================

##Agenda

* In search of the best design
  * Solutions
    * Naive
    * Policy Design
    * Static Polymorphism
    * Dynamic Polymorphism
      * Static factory
    * Concepts (C++2X)
* Dependency Injection
  * [Boost].DI
* Summary

----

##Disclaimer

---

* ###We will focus on simple example
###but let's think large scale (big team projects)

==============================================================================

##Story:  (BDD Style)

Scenario 1:

----

#In search of the best design!

* Loosely coupeled
* Testable

----

## KISS - ~~Keep it simple~~, STUPID

```cpp
int main() {
  auto value = 0;
  {
    std::fstream file{"input.txt"};
    file >> value;
  }
  std::cout << value << '\n';
}
```

* (+) Does the job?
* (-) Hard to extend/maintain
* (-) Hard to test, do TDD and/or BDD

----

##Good practises are good practices for a reason

----

##Let's introduce some abstractions (V1)

```cpp
class Reader {
  static constexpr auto name = "input.txt";
  std::fstream file{name};

public:
  auto read() {
    auto value = 0;
    file >> value;
    return value;
  }
};
```

```cpp
class Viewer {
  public:
    void show(int value) {
      std::cout << value << '\n';
    }
};
```

----

##Let's introduce some abstractions (V1)

```cpp
class App {
  Reader reader;
  Viewer viewer;

  void run() {
    viewer.show(reader.read());
  }
};
```

```cpp
int main() {
  App{}.run();
}
```

----

##Let's introduce some abstractions (V1)

![app0](images/app0.png)

* (+) Still does the job
* (+/-) We can somewhat test it in isolation (can't test the App)
* (-) Reader/Viewer tightly coupled to App

----

##Composition Root

> Unique location in an application where modules are composed together

```cpp
int main() {
  App{}.run();
}
```

----

##Let's inject some abstractions (V2)

```cpp
class Reader;
class Viewer;
```

```cpp
class App {
 Reader reader;
 Viewer viewer;

 public:
  App(Reader&& reader, Viewer&& viewer)
    : reader(std::move(reader))
    , viewer(std::move(viewer))
  { }

  void run() {
    viewer.show(reader.read());
  }
};
```

```cpp
int main() {
  Reader reader;
  Viewer viewer;
  App app{std::move(reader), std::move(viewer)};

}
```

----

##Let's inject some abstractions (V2)

![app1](images/app1.png)

* (+) Still does the job
* (+) We can test it in isolation (including App) but it's hard
* (+) Reader/Viewer are not tightly coupled to App
* (-) Can't inject different Readers/Viewers

----

##There we have it - Dependency Injection (DI)

> "Don't call us, we'll call you", Hollywood principle

-

> Separates creation logic from business logic

----

##Let's make it more generic - Policy Design / Duck Typing (V3)

```cpp
class Reader;
class Viewer;
```

```cpp
template<class TReader, class TViewer>
class App {
  TReader reader;
  TViewer viewer;

public:
  App(TReader& reader, TViewer& viewer)
    : reader(reader), viewer(viewer)
  { }

  void run() {
    viewer.show(reader.read());
  }
};
```

----

```cpp
int main() {
  Reader reader;
  Viewer viewer;
  App<Reader, Viewer> app{reader, viewer};
  app.run();
}
```

* (+) Still does the job
* (+) We can test it in isolation (including App) but it's hard
* (+) Reader/Viewer are not tightly coupled to App
* (+) Can't inject different Readers/Viewers
* (-) We are limited to header files
* (-) Slower compilation times (Point of instantiation - POI)
* (-) Code bloat (executable size)
* (-) Horrible error messages

----

##Let's make it more open by using static polymorphism (V4)
####Curiously recurring template pattern (CRTP)

```cpp
template<class T> 
struct Reader {
  void read() {
    static_cast<T*>(this)->read(value);
  }
}
```

```cpp
template<class T> 
struct Viewer {
  void show(int value) {
    static_cast<T*>(this)->show(value);
  }
}
```

```cpp
class App {
  // TODO
};
```

----

* (+) Still does the job
* (+) We can test it in isolation (including App) but it's hard
* (+) Reader/Viewer are not tightly coupled to App
* (+) Can't inject different Readers/Viewers
* (-) We are limited to header files
* (-) Slower compilation times (Point of instantiation - POI)
* (-) Bigger executable size
* (-) Horrible error messages

----

##Concepts to the rescue? (C++2X?)

```cpp
template <class T>
concept bool Readable() {
  return requires(T reader) {
    { reader.read(std::string_view{}) } -> int;
  }
};
```

```cpp
template <class T>
concept bool Viewable() {
  return requires(T viewer) {
    { viewer.show() };
  }
};
```

----

##Concepts to the rescue? (C++2X?)

```cpp
class App {
  virtual Readable reader; // stack, Small Buffer Optimization
  virtual Viewable viewer; // type erasure

public:
  App(Readable reader, Viewable viewer) // template<Readable...
    : reader(reader), viewer(viewer) {}

  void run() {
    viewer.show(reader.read());
  }
};
```

```cpp
int main() {
  Readable reader = FileReader{"input.txt"};
  Viewable viwer = ConsoleViewer();

  App{reader, viewer}.run();
}
```

----

##Concepts to the rescue? (C++2X?)

| | | |
|-|-|-|
|Concepts lite     | Constrating templates        | [http://www.open-std.org/.../n3580.pdf](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3580.pdf) |
|Virtual concepts  | Type-erasure                 | [https://github.com/.../VirtualConcepts.pdf](https://github.com/andyprowl/virtual-concepts/blob/master/draft/Dynamic%20Generic%20Programming%20with%20Virtual%20Concepts.pdf) |
|Static reflection | Fakes/Stubs/Mocks generation | [www.open-std.org/.../p0194r0.pdf](www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0194r0.pdf) |

----

##Let's make it more open by using dynamic polymorphism (V5)

```cpp
class IReader {
public:
  virtual ~IReader() noexcept = default;
  virtual int read() = 0;
};
```

```cpp
class FileReader final : public IReader {
public:
  FileReader(std::string_view path);
  void read() override;
};
```

----

##Let's make it more open by using dynamic polymorphism (V5)

```cpp
class IViewer {
public:
  virtual ~IViewer() noexcept = default;
  virtual void show(int) = 0;
};
```

```cpp
class ConsoleViewer final : public IViewer {
  void show(int) override;
};
```

----

##Single responsibility principle

> "A class should have only one reason to change" Unclue Bob

----

##Let's make it more open by using dynamic polymorphism (V5)

```cpp
class App {
  std::unique_ptr<IReader<int>> reader =
    std::make_uniqe<FileReader>("input.txt");

  std::unique_ptr<IViewer<int>> viewer =
    std::make_uniqe<ConsoleViewer>();

public:
  void run() {
    viewer->show(reader->read());
  }

};
```

```cpp
int main() {
  App{}.run();
}
```

----

##Let's make it more open by using dynamic polymorphism (V5)

* (+) Still does the job
* (-) We can't test App easily
* (-) Reader/Viewer are tightly coupled to App again
* (-) Can't inject different Readers/Viewers again
* (-) Performance hit due to virtual dispatch?

> Did we make a step backwards?

----

##Dynamic Polymorphism - performance
####final keyword and Devirtualization

![final](images/final.png)
https://godbolt.org/g/e8olYN

----

##Let's inject using static factory (V6)

```cpp
class IReader; class FileReader;
class IViewer; class ConsoleViewer;
```

```cpp
struct ReaderFactory {
  static auto create(std::string_view input) {
    return std::make_unique<FileReader>(input);
  }
};
```

```cpp
struct ViewerFactory {
  static auto create() {
    return std::make_unique<ConsoleViewer>();
  }
};
```

----

##Let's inject using static factory (V6)

```cpp
class App {
public:
  void run() {
    ViewerFactory::create()->show(
      ReaderFactory::create("input.txt")->read()
    );
  }

};
```

```cpp
int main() {
  App{}.run();
}
```

----

##Let's inject using static factory (V6)

* (+) Still does the job
* (+) We can test it in isolation (including App) but it's hard
* (+) Reader/Viewer are tightly coupled to App again
* (+) Can inject different Readers/Viewers
* (+/-) Performance
* (-) It's tightly coupled to the static factories
* (-) Can't test factories easily

----

| | |
|-|-|
|Static factories | MUST GO! |
|Abstract factories | Okay as long as injected |
|Smart factories/Assisted injection | Even better, inject some object up-front and some at run-time |

| | | |

----

##Let's inject using Manual DI (V7)

```cpp
class IReader; class FileReader;
class IViewer; class ConsoleViewer;
```

```cpp
class App {
  IReader& reaer;
  IViewer& viewer;

public:
  App(IReader& reader, IViewer& viewer)
    : reader(reader), viewer(viewer) {}

  void run() {
    viewer.show(reader.read());
  }
};
```

```cpp
int main() {
  auto reader = std::make_unique<FileReader>("input.txt"); // wire
  auto viewer = std::make_unique<ConsoleViewer>()); // wire

  App{*reader, *viewer}.run(); // inject
}
```

----

##Let's inject using Manual DI (V7)

![app](images/app.png)

* (+) Still does the job
* (+) We can easily do TDD/BDD (mocking)
* (+) We can inject diff readers/writers (loosely coupled)
* (-) We introduced a wiring mess (boilerplate code)

----

##Testing

> "If you liked it then you should have put a test on it", Beyonce rule

```cpp
"should show read text"_test = [] {
  constexpr auto value = 42;

  auto [sut, mocks] = make<App>();

  InSequence sequence;
  EXPECT_CALL(mocks<IReader>, read()).WillOnce(Return(value));
  EXPECT_CALL(mocks<IViewer>, show(value));

  sut.run();
};
```



----

##Manual DI Facts

* ###Single Responsibility
  =>
    * ###A lot of classes
    =>
        * ###A lot wiring
        =>
            * ###Wiring Mess

----

##Manual DI Facts

* ###Wiring mess
  =>
    * ###Hard to maintain
    =>
        * ###Workarounds

-----

##Solution

###Simplify/Remove the wiring mess
=>
### [Boost].DI


==============================================================================

##[Boost].DI

* One header - 3k LOC - (boost/di.hpp) / generated
* Neither Boost nor STL is required
* No 'if's, 'virtual', 'exceptions' (-fno-rtti, -fno-exceptions)
* Non-intrusive (constructor parameters deduction)
* Compile-time creation guarantee (no run-time errors)
* Supported compilers (C++14)
  * [Clang-3.4+](https://travis-ci.org/boost-experimental/di), [XCode-6.1+](https://travis-ci.org/boost-experimental/di), [GCC-5.2+](https://travis-ci.org/boost-experimental/di), [MSVC-2015+](https://ci.appveyor.com/project/krzysztof-jusiak/di)

----

##[Boost].DI - Removing the wiring mess

```cpp
#include <boost/di.hpp>
namespace di = boost::di;
```

```cpp
class IReader;
class IViewer;
```

```cpp
class App {
 public:
  App(const IReader&, const IViewer&); // DI handles
};                  ^       ^          // order and types
                    |       \----------------------\
                    \-----------------------\      |
int main() {                                |      |
  const auto injector = di::make_injector(  |      |
     di::bind<IReader>.to<FileReader>(), ---/      |
     di::bind<IViewer>.to<ConsoleViewer>() --------/
  );

  injector.create<std::unique_ptr<App>>().run();
}
```

----

##[Boost].DI - Performance

```sh
time $CXX -std=c++14 app.cpp # 0.092s
```

####ASM x86-64

```
push   %rbx
mov    %rdi,%rbx
mov    $0x8,%edi
callq  0x4009f0 <_Znwm@plt>
movq   $0x400e78,(%rax)
mov    %rax,(%rbx)
mov    %rbx,%rax
pop    %rbx
retq
```

####Same as

```cpp
return make_unique<App>(...);
```

----

##Benchmarks (GCC-6/Java8)

| 64 types, 1-4 ctor params, 1024 iterations | **[Boost].DI** | **Guice** | **Dagger2** |
| --------------------- | ------------ | ---------------- | ------------- |
| Compilation time    | 0.376s       |  0.570s            | 1.411s        |
| Execution time      | 0.002s       |  0.528s            | 0.157s        |

---

| 256 types, 1-4 ctor params, 1024 iterations | **[Boost].DI** | **Guice** | **Dagger2** |
| --------------------- | ------------ | ---------------- | ------------- |
| Compilation time    | 0.706s       | 0.642s             | 1.903s        |
| Execution time      | 0.002s       | 0.544s             | 0.210s        |

----

##[Boost].DI - Compile-time errors

```cpp
const auto injector = di::make_injector(
// di::bind<IViewer>.to<ConsoleViewer>(), // missing 'IViewer' binding
   di::bind<IReader>.to<FileReader>()
);
auto app = injector.create<App>();
```

####Full Compilation-Time Error Message

```cpp
error: 'create<App>' is deprecated: creatable constraint
  injector.create<App>();           not satisfied
           ^
note 'create<App>' has been explicitly marked deprecated here
  create
  ^
error: inline function 'abstract_type<IViewer>::is_not_bound::error'
 error(_ = "type is not bound, did you forget to add:
           'di::bind<interface>.to<implementation>()'?");
```

----

##[Boost].DI - API

###Injector
```cpp
template<class... TDeps> requires boundable<TDeps...>()
class injector {
public:
  explicit injector(TDeps&&...) noexcept;
  injector(injector&&) = default;
  injector& operator=(injector&&) = default;

  template<class T> requires creatable<T>()
  constexpr T create() const;
};
```

###Make injector
```cpp
template<class TConfig = di::config, class... TDeps>
  requires configurable<TConfig>() && boundable<TDeps...>()
auto make_injector(TDeps&&...) noexcept;
```

----

##Let's come back to our example (V2)

###Automatic Injection

```cpp
class Reader;
class Viewer;
```

```cpp
class App {
 Reader reader;
 Viewer viewer;

public:
  App(Reader&& reader, Viewer&& viewer)
    : reader(std::move(reader))
    , viewer(std::move(viewer))
  {}

  void run() {
    viewer.show(reader.read());
  }
};
```

----

##Automatic Injection

###Manual DI
```cpp
int main() {
  Reader reader;
  Viewer viewer;
  App app{std::move(reader), std::move(viewer)};
  app.run();
}
```

###[Boost].DI
```cpp
int main() {
  di::make_injector().create<App>().run();
}
```

----

##Refactoring for free!

###Let's change App constructor
  
```cpp
Before                                | After
--------------------------------------+----------------------------------------------------
App(Reader&& reader, Viewer&& viewer) | App(Viewer& viewer, std::unique_ptr<Reader> reader)
  : reader(std::move(reader))         |  : viewer(viewer)
  , viewer(std::move(viewer))         |  , reader(std::move(reader))
{}                                    | {}
```
<!-- .element: style="margin-left:-3%; width:112%" -->

----

##Refactoring for free!

###Manual DI
```cpp
int main() {
  auto reader = std::make_unique<Reader>{};
  Viewer viewer;
  App app{viewer, std::move(reader)};
  app.run();
}
```

###[Boost].DI
```cpp
int main() {
  di::make_injector().create<App>().run(); // same as before!
}
```

----

##Implementing features by wiring

Scenario 2
If command line 
New Scenario

----

##Implementing features by wiring
###Weak vs Strong interface

```cpp
class QtViewer {
public:
  QtViewer(int width, int height); // weak interface
};
```

```cpp
QtViewer(600, 800); // Okay
QtViewer(800, 600); // Oops
```

```cpp
class QtViewer {
public:
  QtViewer(width, height); // strong types
};
```

```cpp
QtViewer(witdth{500}, height{800}); // Okay
QtViewer(height{500}, width{800});  // Compile error, YAY
QtViewer(500, 800);                 // Compile error, YAY
```

----

##Implementing features by wiring
###Configuration
```cpp
const auto config = [](std::string_view view) {
  return di::make_injector(
     di::bind<IReader>.to<FileReader>(),
     di::bind<IViewer>.to([&](const auto& injector) {
       if (argv[1] == "QtViewer") {
          return injector.create<QtViewer&>();
       } else if (argv[1] == "ConsoleViewer") {
          return injector.create<ConsoleViewer&>();
       }
     })
  );
};
```

```cpp
int main(int argc, char** argv) {
  assert(2 == argc);
  config(argv[1]).create<App>().run();
}
```

----

###What about functional DI? (V8)

```cpp
using fview = std::function<void(int)>;
using fread = std::function<int()>;
```

```cpp
const auto fileRead = [](std::string_view path) {
  return [=] {
    auto value = 0;
    {
      std::fstream file{path};
      file >> value;
    }
    return value;
  };
};
```

```cpp
const auto consoleView = [](int value) {
  std::cout << value << '\n';
};
```

----

###What about functional DI? (V8)

```cpp
class App {
  fview view;
  fread read;

 public:
   App(const fview& view, const fread& read)
     : view(view), read(read)
   { }

   void run() {
     view(read());
   }
};
```

```cpp
const auto injector = di::make_injector(
    di::bind<fview>.to(consoleView)
  , di::bind<fread>.to(fileRead("input.txt"))
);

injector.create<App>().run();
```

----

##[Boost].DI - more features

* Policies
  * Example - Disallow passing by raw pointer without markup ownership explicitly 
* Automatic mocks injection
  * Creates and inject mocks automatically
* Serialization
  * Serialize all POD's in the App
* Dependencies diagram generation

http://boost-experimental.github.io/di

==============================================================================

##Summary

----

##STUPID vs SOLID (Object Oriented design)

<table><tr>
 <td>
  <table>
    <tr><td><b>S</b></td><td>Singleton</td></tr>
    <tr><td><b>T</b></td><td>Tight Coupling</td></tr>
    <tr><td><b>U</b></td><td>Untestability</td></tr>
    <tr><td><b>P</b></td><td>Premature Optimization</td></tr>
    <tr><td><b>I</b></td><td>Indescriptive Naming</td></tr>
    <tr><td><b>D</b></td><td>Duplication</td></tr>
  </table>
 </td>

 <td>
  <table>
    <tr><td><b>S</b></td><td><b>Single Responsibility</b></td></tr>
    <tr><td><b>O</b></td><td>Open-close</td></tr>
    <tr><td><b>L</b></td><td>Liskov substitution</td></tr>
    <tr><td><b>I</b></td><td>Interface segregation</td></tr>
    <tr><td><b>D</b></td><td><b>Dependency injection</b></td></tr>
  </table>
 </td>

 </tr>
</table>
> "Clean Code", Unclue Bob

----

##Dependency Injection

* A powerful design pattern helping with creating
  * Loosely Coupling
  * Easy to test code (TDD)

* [Boost].DI
  * Removes wiring mess (boilerplate code)
  * Simplify refactoring
  * Make testing easier (automatic mocks injection)

==============================================================================

##Questions?

| [Boost].DI |  |
| ------- | ------------- |
| Documentation | http://boost-experimental.github.io/di |
| Source Code | https://github.com/boost-experimental/di |
| Try it online! | http://boost-experimental.github.io/di/try_it/index.html |
|                | https://godbolt.org/g/dvjJFI |
<!-- .element: style="margin-left:-13%; width:125%" -->

-

[kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)


					</script>
				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({

        // Display controls in the bottom right corner
        controls: true,

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: true,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'convex', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
