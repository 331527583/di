<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Motivation</title>
<link rel="stylesheet" href="../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.0">
<link rel="home" href="../index.html" title="Boost.DI (Dependency Injection) 1.0">
<link rel="up" href="../index.html" title="Boost.DI (Dependency Injection) 1.0">
<link rel="prev" href="introduction.html" title="Introduction">
<link rel="next" href="overview.html" title="Overview">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../boost.png"></td>
<td align="center"><a href="../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="introduction.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="overview.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="di.motivation"></a><a class="link" href="motivation.html" title="Motivation">Motivation</a>
</h2></div></div></div>
<p>
      In other words <span class="bold"><strong>Dependency Injection</strong></span> might
      be described as "set of software design principles and patterns that enable
      us to develop <span class="bold"><strong>loosely coupled</strong></span> code" [<a class="link" href="references.html#See11">See11</a>]. Dependency Injection allows us to separate business
      logic to object creation, which give possibility to write maintainable and
      testable code. There are many forms of dependency injection which you can read
      more about in [<a class="link" href="references.html#Van08">Van08</a>].
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          Constructor injection
        </li>
<li class="listitem">
          Interface injection
        </li>
<li class="listitem">
          Setter injection
        </li>
<li class="listitem">
          Member injection
        </li>
</ul></div>
<p>
      <span class="bold"><strong>Constructor injection</strong></span> is the most powerful
      and the cleanest way of dependency injection, it's also preferable, because
      there is no need to worry about objects arriving in an uninitialized state.
    </p>
<p>
      Dependency Injection doesn't really require Dependency Injection Framework
      (Dependency Injection Container/Inversion Of Control Container) or any sort
      of different patterns like Service Locator, Static Factory or Abstract Factory
      itself, but it make your life easier, which will be described in this introduction.
    </p>
<h3>
<a name="di.motivation.h0"></a>
      <span class="phrase"><a name="di.motivation.problem"></a></span><a class="link" href="motivation.html#di.motivation.problem">Problem</a>
    </h3>
<p>
      For the purposes of this introduction we are going to implement simple application
      with logger dependency.
    </p>
<h3>
<a name="di.motivation.h1"></a>
      <span class="phrase"><a name="di.motivation.solution"></a></span><a class="link" href="motivation.html#di.motivation.solution">Solution</a>
    </h3>
<p>
      Dependency Injection might be implemented in many different ways. Table below
      shows how Dependency Injection may be realised and how it will affects the
      source code design [<a class="link" href="references.html#Lus11">Lus11</a>].
    </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
            </th>
<th>
              <p>
                No Dependency Injection Framework
              </p>
            </th>
<th>
              <p>
                Dependency Injection Framework
              </p>
            </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                <span class="bold"><strong>No Dependency Injection</strong></span>
              </p>
            </td>
<td>
              <p>
                Highly coupled code (Spaghetti code)
              </p>
            </td>
<td>
              <p>
                Static Factory/Abstract Factory or Service Locator (Anti pattern)
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                <span class="bold"><strong>Dependency Injection</strong></span>
              </p>
            </td>
<td>
              <p>
                Manual Dependency Injection (tedious/hard to maintain in large scale)
              </p>
            </td>
<td>
              <p>
                Enhanced Dependency Injection (<span class="bold"><strong>Boost.DI</strong></span>)
              </p>
            </td>
</tr>
</tbody>
</table></div>
<p>
      Skip other solutions and go straight away to <a class="link" href="motivation.html#boost_di">Boost.DI</a>.
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
          <span class="bold"><strong>Spaghetti code</strong></span> which is highly coupled
          is really hard to change/maintain/test, therefore is not really good practice
          to write it.
        </li></ul></div>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">app</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">app</span><span class="special">()</span> <span class="special">{</span>
        <span class="keyword">auto</span> <span class="identifier">logger</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_unique</span><span class="special">&lt;</span><span class="identifier">logger</span><span class="special">&gt;();</span>
        <span class="identifier">init</span><span class="special">(</span><span class="identifier">logger</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">void</span> <span class="identifier">init</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_ptr</span><span class="special">&lt;</span><span class="identifier">ilogger</span><span class="special">&gt;);</span>
    <span class="keyword">int</span> <span class="identifier">run</span><span class="special">();</span>
<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="comment">//composition root</span>
    <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_unique</span><span class="special">&lt;</span><span class="identifier">app</span><span class="special">&gt;()-&gt;</span><span class="identifier">run</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
          <span class="bold"><strong>Manual Dependency</strong></span> Injection requires that
          all dependencies will be created by yourself, but done right will produce
          loosely coupled code. Anyway it's a tedious/boilerplate code and sooner
          or later - depending on the project scale - project will end up with some
          sort of automatization.
        </li></ul></div>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">app</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">app</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_ptr</span><span class="special">&lt;</span><span class="identifier">ilogger</span><span class="special">&gt;);</span>
    <span class="keyword">int</span> <span class="identifier">run</span><span class="special">();</span>
<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="comment">//creation of dependencies</span>
    <span class="keyword">auto</span> <span class="identifier">logger_</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_shared</span><span class="special">&lt;</span><span class="identifier">logger</span><span class="special">&gt;();</span>

    <span class="comment">//composition root</span>
    <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_unique</span><span class="special">&lt;</span><span class="identifier">app</span><span class="special">&gt;(</span><span class="identifier">logger_</span><span class="special">)-&gt;</span><span class="identifier">run</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
      If we want to support different types of logger we need to write a bit of boilerplate
      code over and over again.
    </p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="identifier">text_logger_</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_shared</span><span class="special">&lt;</span><span class="identifier">text_logger</span><span class="special">&gt;();</span>
<span class="keyword">auto</span> <span class="identifier">ci_logger_</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_shared</span><span class="special">&lt;</span><span class="identifier">ci_logger</span><span class="special">&gt;();</span>
<span class="keyword">auto</span> <span class="identifier">file_logger_</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_shared</span><span class="special">&lt;</span><span class="identifier">file_logger</span><span class="special">&gt;();</span>
<span class="special">...</span>
</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
          <span class="bold"><strong>Static Factory</strong></span> hides the choice of implementation
          and instance management of a certain component, from the objects using
          this component. The drawbacks of using them are that they we have to create
          a lot of tedious factories ourselves as well as that we can't test the
          functionality really because creation is inside the component. Despite
          that it's hard to inject dependencies into not default constructor.
        </li></ul></div>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">logger_factory</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_ptr</span><span class="special">&lt;</span><span class="identifier">ilogger</span><span class="special">&gt;</span> <span class="keyword">static</span> <span class="identifier">create</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_unique</span><span class="special">&lt;</span><span class="identifier">logger</span><span class="special">&gt;();</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">class</span> <span class="identifier">app</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">app</span><span class="special">()</span>
        <span class="special">:</span> <span class="identifier">logger</span><span class="special">(</span><span class="identifier">logger_factory</span><span class="special">::</span><span class="identifier">create</span><span class="special">())</span>
    <span class="special">{</span> <span class="special">}</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_ptr</span><span class="special">&lt;</span><span class="identifier">ilogger</span><span class="special">&gt;</span> <span class="identifier">logger</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="comment">//composition root</span>
    <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_unique</span><span class="special">&lt;</span><span class="identifier">app</span><span class="special">&gt;()-&gt;</span><span class="identifier">run</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
          <span class="bold"><strong>Abstract Factory</strong></span> solve the issues with
          creating of many static factories by first obtaining a factory of a certain
          kind, and then ask that factory for instances. With Abstract Factories
          we can easily change the implementation of the component in runtime, but
          we still have the same issues as with Static Factories. A lot of tedious/boilerplate
          code to write (which is hard to test - have you tried test factories?),
          we still have creation within a component and we still have problems with
          not default constructors. Abstract Factory is similar to Service Locator
          pattern, which is described next and which avoid creation of many tedious
          code.
        </li></ul></div>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">ilogger_factory</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">virtual</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_ptr</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">create</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">class</span> <span class="identifier">logger_factory</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_ptr</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">create</span><span class="special">()</span> <span class="keyword">const</span> <span class="identifier">override</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_unique</span><span class="special">&lt;</span><span class="identifier">logger</span><span class="special">&gt;();</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">class</span> <span class="identifier">logger_abstract_factory</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">add</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&amp;</span> <span class="identifier">name</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_ptr</span><span class="special">&lt;</span><span class="identifier">ilogger_factory</span><span class="special">&gt;</span> <span class="identifier">factory</span><span class="special">);</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_ptr</span><span class="special">&lt;</span><span class="identifier">ilogger_factory</span><span class="special">&gt;</span> <span class="identifier">get</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&amp;</span> <span class="identifier">name</span><span class="special">);</span>
<span class="special">};</span>

<span class="keyword">class</span> <span class="identifier">app</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">app</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">logger_abstract_factory</span><span class="special">&amp;</span> <span class="identifier">laf</span><span class="special">)</span>
        <span class="special">:</span> <span class="identifier">logger</span><span class="special">(</span><span class="identifier">laf</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="string">"logger_factory"</span><span class="special">).</span><span class="identifier">create</span><span class="special">())</span>
    <span class="special">{</span> <span class="special">}</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_ptr</span><span class="special">&lt;</span><span class="identifier">ilogger</span><span class="special">&gt;</span> <span class="identifier">logger</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="comment">//Abstract Factory configuration</span>
    <span class="identifier">logger_abstract_factory</span> <span class="identifier">laf</span><span class="special">;</span>
    <span class="identifier">laf</span><span class="special">.</span><span class="identifier">add</span><span class="special">(</span><span class="string">"logger_factory"</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_unique</span><span class="special">&lt;</span><span class="identifier">logger_factory</span><span class="special">&gt;());</span>

    <span class="comment">//composition root</span>
    <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_unique</span><span class="special">&lt;</span><span class="identifier">app</span><span class="special">&gt;(*</span><span class="identifier">laf</span><span class="special">)-&gt;</span><span class="identifier">run</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
          <span class="bold"><strong>Service Locator</strong></span> by many (including me)
          is consider as anti-pattern, because it follows principle in which components
          asks for its dependencies instead of be given them. On the other hand Service
          Locator pattern is usually very intrusive, requiring components having
          the same constructor with Service Locator being passed. It force unnatural
          code structure and a lot of resolve calls. Because always whole Service
          Locator is passed it's harder to find out which dependencies are needed
          for the class which testing unclear and harder.
        </li></ul></div>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">app</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">app</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">service_locator</span><span class="special">&amp;</span> <span class="identifier">sl</span><span class="special">)</span>
        <span class="special">:</span> <span class="identifier">logger</span><span class="special">(</span><span class="identifier">sl</span><span class="special">.</span><span class="identifier">resolve</span><span class="special">&lt;</span><span class="identifier">ilogger</span><span class="special">&gt;())</span>
    <span class="special">{</span> <span class="special">}</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_ptr</span><span class="special">&lt;</span><span class="identifier">ilogger</span><span class="special">&gt;</span> <span class="identifier">logger</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="comment">//service locator configuration</span>
    <span class="identifier">service_locator</span> <span class="identifier">sl</span><span class="special">;</span>
    <span class="identifier">sl</span><span class="special">.</span><span class="identifier">register_singleton</span><span class="special">&lt;</span><span class="identifier">ilogger</span><span class="special">&gt;().</span><span class="identifier">to</span><span class="special">&lt;</span><span class="identifier">logger</span><span class="special">&gt;();</span>

    <span class="comment">//composition root</span>
    <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_unique</span><span class="special">&lt;</span><span class="identifier">app</span><span class="special">&gt;(</span><span class="identifier">sl</span><span class="special">)-&gt;</span><span class="identifier">run</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
          <span class="bold"><strong>Enhanced Dependency Injection</strong></span> done right
          still will be just a Dependency Injection with automation behind the scenes.
          Dependencies should be automatically resolved and it should be as less
          intrusive as possible, which means that if framework will be changed or
          removed code shouldn't require any changes. Remember DI should "enable
          us to develop loosely coupled code" and this rule applies to the framework
          itself as well. To sum up framework shouldn't affect the design/implementation/structure
          of the code except for well-defined cases like "composition root".
        </li></ul></div>
<a name="boost_di"></a><div class="informaltable"><table class="table">
<colgroup><col></colgroup>
<thead><tr><th>
              <p>
                Motivation Example
              </p>
            </th></tr></thead>
<tbody>
<tr><td>
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting"><span class="keyword">class</span> <span class="identifier">app</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">app</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_ptr</span><span class="special">&lt;</span><span class="identifier">ilogger</span><span class="special">&gt;);</span>
    <span class="keyword">int</span> <span class="identifier">run</span><span class="special">();</span>
<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="comment">// dependency injection configuration</span>
    <span class="keyword">auto</span> <span class="identifier">injector</span> <span class="special">=</span> <a class="link" href="concepts/injectors/make_injector.html" title="make_injector">di::make_injector</a><span class="special">(</span>
        <a class="link" href="concepts/bindings/bind.html" title="bind">di::bind</a><span class="special">&lt;</span><span class="identifier">ilogger</span><span class="special">,</span> <span class="identifier">logger</span><span class="special">&gt;()</span>
    <span class="special">);</span>

    <span class="comment">// composition root</span>
    <span class="keyword">return</span> <span class="identifier">injector</span><span class="special">.</span><span class="identifier">create</span><span class="special">&lt;</span><span class="identifier">app</span><span class="special">&gt;().</span><span class="identifier">run</span><span class="special">();</span>
<span class="special">}</span>
</pre>
            </td></tr>
<tr><td>
              <p>
                Notice similarities to manual dependency injection. Of course for
                such a small example DI might be consider a bit of overhead, but
                it will shows its strength in more complex examples. Remember though
                that dependency Injection Framework is not a remedy for everything.
                Used wrong will make code highly coupled code / hard to test and
                maintain, which is presented below.
              </p>
            </td></tr>
</tbody>
</table></div>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../../../doc/src/images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
        Good practice: composition root is a (preferably) unique location in an application
        where modules are composed together
      </p></td></tr>
</table></div>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<p class="simpara">
          <span class="bold"><strong>"Evil"</strong></span> usage of Dependency Injection
          Framework
        </p>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
            Presented example is just for learning purposes, please don't follow
            this anti-pattern approach!
          </p></td></tr>
</table></div>
<pre class="programlisting"><span class="keyword">auto</span> <span class="identifier">global_injector</span> <span class="special">=</span> <a class="link" href="concepts/injectors/make_injector.html" title="make_injector">di::make_injector</a><span class="special">(</span>
    <a class="link" href="concepts/bindings/bind.html" title="bind">di::bind</a><span class="special">&lt;</span><span class="identifier">interface</span><span class="special">,</span> <span class="identifier">implementation</span><span class="special">&gt;()</span>
<span class="special">);</span>

<span class="keyword">class</span> <span class="identifier">app</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">app</span><span class="special">()</span>
        <span class="special">:</span> <span class="identifier">logger</span><span class="special">(</span><span class="identifier">global_injector</span><span class="special">.</span><span class="identifier">create</span><span class="special">&lt;</span><span class="identifier">ilogger</span><span class="special">&gt;())</span>
    <span class="special">{</span> <span class="special">}</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_ptr</span><span class="special">&lt;</span><span class="identifier">ilogger</span><span class="special">&gt;</span> <span class="identifier">logger</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">app</span><span class="special">().</span><span class="identifier">run</span><span class="special">();</span>
<span class="special">}</span>
</pre>
</li></ul></div>
<p>
      We don't need Dependency Injection Framework to apply all the "goods"
      of Dependency Injection, but it may make our life easier. Programmers should
      be "lazy" and shouldn't have to write tedious/boilerplate code. Projects
      should scale and the bigger projects are, the more frameworks will be used.
      So in the end all most projects will end up with some sort of dependency injection
      framework. Using the library may give you additional advantages like modules,
      logging, generating diagrams, compile time checking or restrictions, additional
      conversions, etc. In general it give you full control of what and how will
      be injected in easy and user friendly way. Therefore instead of creating and
      configuring the objects yourself, the dependency framework does it for you.
    </p>
<p>
      <a class="link" href="references.html#See11">See11</a> widely explains advantages of using dependency
      injection, which might be sum up by:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          <span class="bold"><strong>Parallel Development</strong></span>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
                Allows many teams to work separately on different modules
              </li></ul></div>
        </li>
<li class="listitem">
          <span class="bold"><strong>Extensibility</strong></span>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                Lose coupling, declarative approach are features which make code
                easy to extend
              </li>
<li class="listitem">
                Promotes business logic code over boilerplate code
              </li>
</ul></div>
        </li>
<li class="listitem">
          <span class="bold"><strong>Maintainability</strong></span>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                Separation between object creation and business logic make code easy
                to maintain
              </li>
<li class="listitem">
                Reduce <code class="computeroutput"><span class="identifier">Dependency</span> <span class="identifier">Carrying</span></code> - passing dependencies
                which aren't used directly and passed further as well as Singletons
                which weren't passed by constructor because they would have to be
                passed everywhere
                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem">
                      changing constructor signature may not require any changes
                      in dependencies configuration (if such dependency might be
                      deduced or is already used)
                    </li></ul></div>
              </li>
</ul></div>
        </li>
<li class="listitem">
          <span class="bold"><strong>Testability</strong></span>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                Possibility of passing all required parameters via constructor give
                the opportunity to use fakes for testing purposes
              </li>
<li class="listitem">
                We won't need to write tests for manual injection or factories
              </li>
<li class="listitem">
                Integration tests might be written easily by passing fakes from framework
              </li>
<li class="listitem">
                Unit tests doesn't require framework at all to pass dependencies,
                but to avoid boilerplate code dependency injection framework may
                inject fakes automatically
              </li>
</ul></div>
        </li>
<li class="listitem">
          <span class="bold"><strong>Readability</strong></span>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
                Code is easier to read due to separation between business logic and
                object creation as well as lack of boilerplate code just making chaos
              </li></ul></div>
        </li>
</ul></div>
<p>
      <span class="bold"><strong>Dependency Injection Framework</strong></span> might be really
      useful and may make your code to be loosely coupled and easy to maintain. Followed
      by few good practices/principles will get most out of Dependency Injection
      Framework.
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          Follow <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle" target="_top"><span class="bold"><strong>S</strong></span>ingle Responsibility</a> principle
        </li>
<li class="listitem">
          Follow <a href="http://en.wikipedia.org/wiki/Open/closed_principle" target="_top"><span class="bold"><strong>O</strong></span>pen/Closed</a> principle
        </li>
<li class="listitem">
          Follow <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_top"><span class="bold"><strong>L</strong></span>iskov Substitution</a> principle
        </li>
<li class="listitem">
          Follow <a href="http://en.wikipedia.org/wiki/Interface_segregation_principle" target="_top"><span class="bold"><strong>I</strong></span>nterface Segregation</a> principle
        </li>
<li class="listitem">
          Follow <a href="http://en.wikipedia.org/wiki/Dependency_inversion_principle" target="_top"><span class="bold"><strong>D</strong></span>ependency inversion</a> principle
        </li>
<li class="listitem">
          Follow <a href="http://en.wikipedia.org/wiki/Law_of_Demeter" target="_top">Law of
          Demeter</a> principle
        </li>
<li class="listitem">
          Avoid global states and <a href="http://en.wikipedia.org/wiki/Singleton_pattern" target="_top">Singleton
          pattern</a> and <a href="http://en.wikipedia.org/wiki/Service_locator_pattern" target="_top">Service
          Locator</a> pattern
        </li>
<li class="listitem">
          Apply Composition Root
        </li>
</ul></div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2014 Krzysztof Jusiak<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="introduction.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="overview.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
