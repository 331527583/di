<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Krzysztof Jusiak">
  
  <title>User Guide - Boost.DI</title>
  

  <link rel="shortcut icon" href="../img/favicon.ico">

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/codemirror.css">
  <link rel="stylesheet" href="../css/highlight.css">
  <link rel="stylesheet" href="../css/mdn-like.css">

  
  <script>
    // Current page data
    var mkdocs_page_name = "User Guide";
    var mkdocs_page_input_path = "user_guide.md";
    var mkdocs_page_url = "/user_guide/index.html";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script>
  <script src="../js/theme.js"></script>

  <script src="../js/codemirror/codemirror.js"></script>
  <script src="../js/codemirror/clike.js"></script>
  <script src="../js/codemirror/active-line.js"></script>

  <script src="../js/cpp.js"></script>
  <script src="../js/gitter.js"></script>
  <script src="../js/html.js"></script>
  <script src="../js/youtube.js"></script> 

  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

	
	<nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">

      <img src="../img/boost.png" />
      <a href="../index.html" class="icon icon-home" style="font-weight:bold;text-align:left;padding:0.809em;color:#fcfcfc;margin-bottom:0.809em"> Boost.DI</a>

      <div class="wy-side-nav-search">
		<div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">

        <ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../index.html">Introduction</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../overview/index.html">Overview</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../tutorial/index.html">Tutorial</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../quick_user_guide/index.html">Quick User Guide</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 current">
        <a class="current" href="index.html">User Guide</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#injector">Injector</a></li>
                
            
                <li class="toctree-l3"><a href="#bindings">Bindings</a></li>
                
            
                <li class="toctree-l3"><a href="#injections">Injections</a></li>
                
            
                <li class="toctree-l3"><a href="#annotations">Annotations</a></li>
                
            
                <li class="toctree-l3"><a href="#scopes">Scopes</a></li>
                
            
                <li class="toctree-l3"><a href="#modules">Modules</a></li>
                
            
                <li class="toctree-l3"><a href="#providers">Providers</a></li>
                
            
                <li class="toctree-l3"><a href="#policies">Policies</a></li>
                
            
                <li class="toctree-l3"><a href="#concepts">Concepts</a></li>
                
            
                <li class="toctree-l3"><a href="#configuration">Configuration</a></li>
                
            
            </ul>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../examples/index.html">Examples</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../extensions/index.html">Extensions</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../projects/index.html">Projects</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../CHANGELOG/index.html">CHANGELOG</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../TODO/index.html">TODO</a>
        
    </li>
<li>
          
        </ul>
      </div>

    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Boost.DI</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
    
      
    
    <li>User Guide</li>
    <li class="wy-breadcrumbs-aside">
      
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <ul>
<li><a href="#injector">Injector</a><ul>
<li><a href="#di_make_injector">di::make_injector</a></li>
</ul>
</li>
<li><a href="#bindings">Bindings</a><ul>
<li><a href="#di_bind">di::bind</a></li>
</ul>
</li>
<li><a href="#injections">Injections</a><ul>
<li><a href="#di_automatic">automatic (default)</a></li>
<li><a href="#BOOST_DI_INJECT">BOOST_DI_INJECT</a></li>
<li><a href="#BOOST_DI_INJECT_TRAITS">BOOST_DI_INJECT_TRAITS</a></li>
<li><a href="#di_inject">di::inject</a></li>
<li><a href="#di_ctor_traits">di::ctor_traits</a></li>
</ul>
</li>
<li><a href="#annotations">Annotations</a><ul>
<li><a href="#di_named">(named = name)</a></li>
</ul>
</li>
<li><a href="#scopes">Scopes</a><ul>
<li><a href="#di_deduce">di::deduce (default)</a></li>
<li><a href="#di_instance">di::instance (di::bind&lt;&gt;.to(value))</a></li>
<li><a href="#di_singleton">di::singleton</a></li>
<li><a href="#di_unique">di::unique</a></li>
</ul>
</li>
<li><a href="#modules">Modules</a></li>
<li><a href="#providers">Providers</a><ul>
<li><a href="#di_stack_over_heap">di::providers::stack_over_heap (default)</a></li>
<li><a href="#di_heap">di::providers::heap</a></li>
</ul>
</li>
<li><a href="#policies">Policies</a><ul>
<li><a href="#di_constructible">di::policies::constructible</a></li>
</ul>
</li>
<li><a href="#concepts">Concepts</a><ul>
<li><a href="#di_boundable">di::concepts::boundable</a></li>
<li><a href="#di_callable">di::concepts::callable</a></li>
<li><a href="#di_configurable">di::concepts::configurable</a></li>
<li><a href="#di_creatable">di::concepts::creatable</a></li>
<li><a href="#di_providable">di::concepts::providable</a></li>
<li><a href="#di_scopable">di::concepts::scopable</a></li>
</ul>
</li>
<li><a href="#configuration">Configuration</a><ul>
<li><a href="#di_config">di::config</a></li>
</ul>
</li>
</ul>
<hr />
<blockquote>
<p>Let's assume all examples below include <code>boost/di.hpp</code> header and define <code>di</code> namespace alias.</p>
</blockquote>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;
namespace di = boost::di;
//
struct i1 { virtual ~i1() = default; virtual void dummy1() = 0; };
struct i2 { virtual ~i2() = default; virtual void dummy2() = 0; };
struct impl1 : i1 { void dummy1() override { } };
struct impl2 : i2 { void dummy2() override { } };
struct impl : i1, i2 { void dummy1() override { } void dummy2() override { } };
</code></pre>

<h3 id="injector">Injector</h3>
<p><a id="di_make_injector"></a></p>
<p>--- <strong><em>di::make_injector</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Creates <a href="#di_make_injector">injector</a> type.</p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>template&lt;class... TDeps&gt; requires boundable&lt;TDeps...&gt;
class injector {
public:
  using deps; // list of dependencies
  using config; // configuration

  injector(injector&amp;&amp;) = default;
  template &lt;class... Ts&gt; // no requirements
  injector(core::injector&lt;Ts...&gt;&amp;&amp;) noexcept;
  explicit injector(const TDeps&amp;...) noexcept;

  template&lt;class T&gt; requires creatable&lt;T&gt;
  T create() const;

  template &lt;class T&gt; requires creatable&lt;T&gt;
  operator T() const;
};
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TDeps...</code></td>
<td><a href="#di_boundable">boundable</a>&lt;TDeps...></td>
<td>[Bindings] to be used as configuration</td>
<td>-</td>
</tr>
<tr>
<td><code>create&lt;T&gt;()</code></td>
<td><a href="#di_creatable">creatable</a>&lt;T></td>
<td>Creates type <code>T</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>operator T()</code></td>
<td><a href="#di_creatable">creatable</a>&lt;T></td>
<td>Creates type <code>T</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Type <code>T</code></th>
<th>Is allowed?</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>T</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>T*</code></td>
<td>✔</td>
<td>Ownerhsip transfer!</td>
</tr>
<tr>
<td><code>const T*</code></td>
<td>✔</td>
<td>Ownerhsip transfer!</td>
</tr>
<tr>
<td><code>T&amp;</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>const T&amp;</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>T&amp;&amp;</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>std::unique_ptr&lt;T&gt;</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>std::shared_ptr&lt;T&gt;</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>std::weak_ptr&lt;T&gt;</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>boost_shared_ptr&lt;T&gt;</code></td>
<td>✔</td>
<td>-</td>
</tr>
</tbody>
</table>
<pre><code>template&lt;
  class TConfig = di::config
, class... TBindings
&gt; requires boundable&lt;TBindings...&gt; &amp;&amp; configurable&lt;TConfig&gt;
auto make_injector(const TBindings&amp;...) noexcept;
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TConfig</code></td>
<td><a href="#di_configurable">configurable</a>&lt;TConfig></td>
<td><a href="#di_config">Configuration</a></td>
<td>-</td>
</tr>
<tr>
<td><code>make_injector(const TBindings&amp;...)</code></td>
<td><a href="#di_boundable">boundable</a>&lt;TBindings...></td>
<td>Creates <a href="#di_make_injector">injector</a> with given [Bindings]</td>
<td><a href="#di_make_injector">injector</a></td>
</tr>
</tbody>
</table>
<p><strong><em>Test</em></strong>
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/injector_empty.cpp" />
<strong><em>Example</em></strong></p>
<p><img alt="CPP(BTN)" src="../Run_Hello_World_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/hello_world.cpp" /></p>
<p><br /><hr /></p>
<h3 id="bindings">Bindings</h3>
<p>Bindings define dependencies configuration which basically means what types will be created
and what values will be passed into them.</p>
<p><a id="di_bind"></a>
--- <strong><em>di::bind</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Allows to bind interface to implementation and associate value with it.</p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>struct override; // overrides given configuration

namespace detail {
  template&lt;class... Ts&gt; requires boundable&lt;Ts...&gt;
  struct bind {
    bind(bind&amp;&amp;) noexcept = default;

    template&lt;class T&gt; requires boundable&lt;T&gt;
    auto to() noexcept;

    template&lt;class T&gt; requires boundable&lt;T&gt;
    auto to(T&amp;&amp;) noexcept;

    template&lt;class TScope&gt; requires scopable&lt;TScope&gt;
    auto in(const TScope&amp; = di::deduce) noexcept;

    template&lt;class TName&gt; // no requirements
    auto named(const TName&amp; = {}) noexcept;

    auto operator[](const override&amp;) noexcept;
  };
} // detail

template&lt;class... Ts&gt; requires boundable&lt;Ts...&gt;
detail::bind&lt;Ts...&gt; bind{};
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Ts...</code></td>
<td><a href="#di_boundable">boundable</a>&lt;Ts...></td>
<td>'Interface' types</td>
<td>-</td>
</tr>
<tr>
<td><code>to&lt;T\&gt;</code></td>
<td><a href="#di_boundable">boundable</a>&lt;T></td>
<td>Binds <code>Ts...</code> to <code>T</code> type</td>
<td><a href="#di_boundable">boundable</a></td>
</tr>
<tr>
<td><code>to(T&amp;&amp;)</code></td>
<td><a href="#di_boundable">boundable</a>&lt;T></td>
<td>Binds <code>Ts...</code> to <code>T</code> object</td>
<td><a href="#di_boundable">boundable</a></td>
</tr>
<tr>
<td><code>in(const TScope&amp;)</code></td>
<td><a href="#di_scopable">scopable</a>&lt;TScope></td>
<td>Binds <code>Ts...</code> into <code>TScope</code></td>
<td><a href="#di_boundable">boundable</a></td>
</tr>
<tr>
<td><code>named(const TName&amp;)</code></td>
<td>-</td>
<td>Binds <code>Ts...</code> using 'Named' annotation</td>
<td><a href="#di_boundable">boundable</a></td>
</tr>
<tr>
<td><code>operator[](const override&amp;)</code></td>
<td>-</td>
<td>Overrides given binding</td>
<td><a href="#di_boundable">boundable</a></td>
</tr>
</tbody>
</table>
<p><strong><em>Test</em></strong>
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/bind_interface_to_implementation.cpp" />
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/bind_type_to_value.cpp" />
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/bind_deduce_type_to_value.cpp" />
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/bind_type_to_compile_time_value.cpp" />
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/bind_multiple_interfaces.cpp" />
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/bind_type_override.cpp" />
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/bind_cross_platform.cpp" />
<strong><em>Example</em></strong></p>
<p><img alt="CPP(BTN)" src="../Run_Bindings_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/bindings.cpp" />
<img alt="CPP(BTN)" src="../Run_Bindings_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/fwd_bindings.cpp" />
<img alt="CPP(BTN)" src="../Run_Dynamic_Bindings_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/dynamic_bindings.cpp" />
<img alt="CPP(BTN)" src="../Run_Multiple_Bindings_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/multiple_bindings.cpp" />
<img alt="CPP(BTN)" src="../Run_Constructor_Bindings_Extension|https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/bindings/constructor_bindings.cpp" /></p>
<p><br /><br /><br /><hr /></p>
<h3 id="injections">Injections</h3>
<p><em>Constructor Injection</em> is the most powerful of available injections.
It guarantees initialized state of data members. Boost.DI constructor injection is achieved without any additional work from the user.</p>
<p><a id="di_automatic"></a>
--- <strong><em>automatic (default)</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Boost.DI will deduce the best available constructor to be used for injection - unique constructor with the longest parameter list.
If the default behavior should be changed constructor has to be explicitly marked with <a href="#BOOST_DI_INJECT">BOOST_DI_INJECT</a> or <a href="#BOOST_DI_INJECT_TRAITS">BOOST_DI_INJECT_TRAITS</a>.</p>
<div class="warning">
<h3><span class="fa fa-eye wy-text-neutral"></span>&nbsp; Note</h3>
Automatic constructor parameters deduction is limited to [BOOST_DI_CFG_CTOR_LIMIT_SIZE], which by default is set to 10.
</div>

<p><strong><em>Semantics</em></strong></p>
<pre><code>class constructor {
public:
  constructor(auto parameter1, auto parameter2, ..., auto parameterN);
};
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>parameter1-parameterN</code></td>
<td>-</td>
<td><code>N</code> constructor parameter</td>
<td>-</td>
</tr>
</tbody>
</table>
<div class="warning">
<h3><span class="fa fa-eye wy-text-neutral"></span>&nbsp; Note</h3>
Boost.DI is not able to distinguish between ambiguous constructors with the same (longest) amount of parameters.
</div>

<p><strong><em>Test</em></strong>
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/constructor_injection_direct.cpp" />
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/constructor_injection_aggregate.cpp" />
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/constructor_injection_multiple_constructors.cpp" />
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/constructor_injection_ambigious_constructors_via_vaargs.cpp" />
<strong><em>Example</em></strong></p>
<p><img alt="CPP(BTN)" src="../Run_Automatic_Injection_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/automatic_injection.cpp" />
<img alt="CPP(BTN)" src="../Run_Constructor_Signature_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/constructor_signature.cpp" />
<img alt="CPP(BTN)" src="../Run_Concepts_Extension|https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/concepts.cpp" />
<img alt="CPP(BTN)" src="../Run_Assisted_Injection_Extension|https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/assisted_injection.cpp" />
<img alt="CPP(BTN)" src="../Run_Lazy_Extension|https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/lazy.cpp" />
<img alt="CPP(BTN)" src="../Run_Named_Parameters_Extension|https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/named_parameters.cpp" />
<img alt="CPP(BTN)" src="../Run_XML_Injection_Extension|https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/xml_injection.cpp" /></p>
<p><br /><br /><br /><hr /></p>
<p><a id="BOOST_DI_INJECT"></a>
--- <strong><em>BOOST_DI_INJECT</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>BOOST_DI_INJECT is a macro definition used to explicitly say Boost.DI which constructor should be used as well as in order to annotate types - see [annotations] for further reding.
When class has more than one constructor Boost.DI will by default choose the one with the longest parameter list.
In case of constructors ambiguity Boost.DI is not able to choose the best one.
Then BOOST_DI_INJECT become handy to point which constructor should be used.</p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>struct T {
    BOOST_DI_INJECT(T, ...) { }
};
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>T</code></td>
<td>-</td>
<td>Class type</td>
<td>-</td>
</tr>
<tr>
<td><code>...</code></td>
<td>-</td>
<td><code>T</code> constructor parameters</td>
<td>-</td>
</tr>
</tbody>
</table>
<div class="warning">
<h3><span class="fa fa-eye wy-text-neutral"></span>&nbsp; Note</h3>
BOOST_DI_INJECT constructor parameters is limited to [BOOST_DI_CFG_CTOR_LIMIT_SIZE], which by default is set to 10.
</div>

<p><strong><em>Test</em></strong>
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/constructor_injection_ambigious_constructors_via_BOOST_DI_INJECT.cpp" />
<strong><em>Example</em></strong></p>
<p><img alt="CPP(BTN)" src="../Run_Constructor_Injection_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/constructor_injection.cpp" /></p>
<p><br /><hr /></p>
<p><a id="BOOST_DI_INJECT_TRAITS"></a>
--- <strong><em>BOOST_DI_INJECT_TRAITS</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>BOOST_DI_INJECT_TRAITS is a macro definition used to define constructor traits.</p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>struct T {
  BOOST_DI_INJECT_TRAITS(...) { }
  T(...) { }
};
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>...</code></td>
<td>-</td>
<td><code>T</code> constructor parameters</td>
<td>-</td>
</tr>
</tbody>
</table>
<div class="warning">
<h3><span class="fa fa-eye wy-text-neutral"></span>&nbsp; Note</h3>
BOOST_DI_INJECT_TRAITS constructor parameters is limited to [BOOST_DI_CFG_CTOR_LIMIT_SIZE], which by default is set to 10.
</div>

<p><strong><em>Test</em></strong>
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/constructor_injection_ambigious_constructors_via_BOOST_DI_INJECT_TRAITS.cpp" />
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/constructor_injection_default_values.cpp" />
<strong><em>Example</em></strong></p>
<p><img alt="CPP(BTN)" src="../Run_Constructor_Injection_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/constructor_injection.cpp" /></p>
<p><br /><hr /></p>
<p><a id="di_inject"></a>
--- <strong><em>di::inject</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>di::inject informs Boost.DI about constructor parameters. Useful for generated/generic classes as it doesn't have constructor parameters size limitations.</p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>struct T {
  using boost_di_inject__ = di::inject&lt;...&gt;;
  T(...) {}
};
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>...</code></td>
<td>-</td>
<td><code>T</code> constructor parameters</td>
<td>-</td>
</tr>
</tbody>
</table>
<div class="warning">
<h3><span class="fa fa-eye wy-text-neutral"></span>&nbsp; Note</h3>
di::inject has no limitations if it comes to constructor parameters, however, named parameters are not allowed.
</div>

<p><strong><em>Test</em></strong>
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/constructor_injection_ambigious_constructors_via_inject.cpp" />
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/constructor_injection_long_parameter_list.cpp" />
<strong><em>Example</em></strong></p>
<p><img alt="CPP(BTN)" src="../Run_Constructor_Injection_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/constructor_injection.cpp" /></p>
<p><br /><hr /></p>
<p><a id="di_ctor_traits"></a>
--- <strong><em>di::ctor_traits</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p><strong><em>Semantics</em></strong></p>
<p><strong><em>Test</em></strong>
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/constructor_injection_ambigious_constructors_via_ctor_traits.cpp" />
<strong><em>Example</em></strong></p>
<p><img alt="CPP(BTN)" src="../Run_Constructor_Injection_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/constructor_injection.cpp" /></p>
<p><br /><hr /></p>
<h3 id="annotations">Annotations</h3>
<p>Annotations are intrusive, additional informations specified along with the type in order to refer to given type by the
annotation instead of type it self. Useful, when there are more than one type of the same parameters in constructor parameters.</p>
<p><a id="di_named"></a>
--- <strong><em>(named = name)</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Named parameters are useful when constructor has more parameters of the same type.</p>
<pre><code class="cpp">  T(int value1, int value2);
</code></pre>

<p>In order to inject proper values into <code>value1</code> and <code>value2</code> they have to be distinguished somehow.
Boost.DI solution for that problem are annotations.</p>
<div class="warning">
<h3><span class="fa fa-eye wy-text-neutral"></span>&nbsp; Note</h3>
Annotations might be set only when constructor is selected using BOOST_DI_INJECT or BOOST_DI_INJECT_TRAITS.
</div>

<p><strong><em>Semantics</em></strong></p>
<pre><code>auto Name = []{}; // just an object

struct T {
  BOOST_DI_INJECT(T, (named = Name) type type_name [= default_value], ...);
};
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Name</code></td>
<td>-</td>
<td>Object representing named type</td>
<td>-</td>
</tr>
</tbody>
</table>
<p><strong><em>Example</em></strong></p>
<pre><code>BOOST_DI_INJECT(T, (named = value_1) int value1, (named = value_2) int value2);
</code></pre>
<div class="warning">
<h3><span class="fa fa-eye wy-text-neutral"></span>&nbsp; Note</h3>
Implementation of constructor doesn't require annotations, which means implementation won't be affected by annotations.
</div>

<p><strong><em>Test</em></strong>
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/annotated_constructor_injection.cpp" />
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/annotated_constructor_injection_with_constructor_definition.cpp" />
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/annotated_constructor_injection_with_ctor_traits.cpp" />
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/annoteded_constructor_injection_with_the_same_names.cpp" />
<strong><em>Example</em></strong></p>
<p><img alt="CPP(BTN)" src="../Run_Annotations_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/annotations.cpp" /></p>
<p><br /><hr /></p>
<h3 id="scopes">Scopes</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Scopes are responsible for creating and maintaining life time of dependencies.
If no scope will be given, deduce scope will be assumed.</p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>template &lt;class TExpected, class TGiven&gt;
struct scope {
  template &lt;class T&gt;
  using is_referable;

  template &lt;class T, class TName, class TProvider&gt;
  static auto try_create(const TProvider&amp;);

  template &lt;class T, class TName, class TProvider&gt;
  auto create(const TProvider&amp;);
};
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TExpected</code></td>
<td>-</td>
<td>'Interface' type</td>
<td>-</td>
</tr>
<tr>
<td><code>TGiven</code></td>
<td>-</td>
<td>'Implementation' type</td>
<td>-</td>
</tr>
<tr>
<td><code>is_referable&lt;T\&gt;</code></td>
<td>-</td>
<td>Verifies whether scope value might be converted to a reference</td>
<td>std::true_type/std::false_type</td>
</tr>
<tr>
<td><code>try_create&lt;T, TName, TProvider\&gt;</code></td>
<td><a href="#di_providable">providable</a>&lt;TProvider></td>
<td>Verifies whether type might be created</td>
<td>std::true_type/std::false_type</td>
</tr>
<tr>
<td><code>create&lt;T, TName, TProvider\&gt;</code></td>
<td><a href="#di_providable">providable</a>&lt;TProvider></td>
<td>Creates type might be created</td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Type/Scope</th>
<th>unique</th>
<th>singleton</th>
<th>instance</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>✔</td>
<td>-</td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T&amp;</td>
<td>-</td>
<td>✔</td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>const T&amp;</td>
<td>✔ (temporary)</td>
<td>✔</td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T* (transfer ownership)</td>
<td>✔</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>✔</td>
</tr>
<tr>
<td>const T*</td>
<td>✔</td>
<td>-</td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td>✔</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>unique_ptr<T></td>
<td>✔</td>
<td>-</td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>shared_ptr<T></td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>weak_ptr<T></td>
<td>-</td>
<td>✔</td>
<td>✔</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong><em>Test</em></strong>
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/scopes_custom.cpp" />
<strong><em>Example</em></strong></p>
<p><img alt="CPP(BTN)" src="../Run_Custom_Scope_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_scope.cpp" />
<img alt="CPP(BTN)" src="../Run_Scoped_Scope_Extension|https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/scopes/scoped_scope.cpp" />
<img alt="CPP(BTN)" src="../Run_Session_Scope_Extension|https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/scopes/session_scope.cpp" />
<img alt="CPP(BTN)" src="../Run_Shared_Scope_Extension|https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/scopes/shared_scope.cpp" /></p>
<p><br /><br /><br /><hr /></p>
<p><a id="di_deduce"></a>
--- <strong><em>di::deduce (default)</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Default scope which will be converted to one of the scopes depending on the type.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>deduce</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td><a href="#di_unique">unique</a></td>
</tr>
<tr>
<td>T&amp;</td>
<td><a href="#di_singleton">singleton</a></td>
</tr>
<tr>
<td>const T&amp;</td>
<td><a href="#di_unique">unique</a> (temporary)/singleton</td>
</tr>
<tr>
<td>T*</td>
<td><a href="#di_unique">unique</a> (ownership transfer)</td>
</tr>
<tr>
<td>const T*</td>
<td><a href="#di_unique">unique</a> (ownership transfer)</td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td><a href="#di_unique">unique</a></td>
</tr>
<tr>
<td>unique_ptr<T></td>
<td><a href="#di_unique">unique</a></td>
</tr>
<tr>
<td>shared_ptr<T></td>
<td><a href="#di_singleton">singleton</a></td>
</tr>
<tr>
<td>weak_ptr<T></td>
<td><a href="#di_singleton">singleton</a></td>
</tr>
</tbody>
</table>
<p><strong><em>Semantics</em></strong></p>
<pre><code>namespace scopes {
  struct deduce {
    template &lt;class TExpected, class TGiven&gt;
    struct scope {
      template &lt;class T&gt;
      using is_referable;

      template &lt;class T, class TName, class TProvider&gt;
      static auto try_create(const TProvider&amp;);

      template &lt;class T, class TName, class TProvider&gt;
      auto create(const TProvider&amp;);
    };
  };
}

scopes::deduce deduce;
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TExpected</code></td>
<td>-</td>
<td>'Interface' type</td>
<td>-</td>
</tr>
<tr>
<td><code>TGiven</code></td>
<td>-</td>
<td>'Implementation' type</td>
<td>-</td>
</tr>
<tr>
<td><code>is_referable&lt;T\&gt;</code></td>
<td>-</td>
<td>Verifies whether scope value might be converted to a reference</td>
<td>std::true_type/std::false_type</td>
</tr>
<tr>
<td><code>try_create&lt;T, TName, TProvider\&gt;</code></td>
<td><a href="#di_providable">providable</a>&lt;TProvider></td>
<td>Verifies whether type might be created</td>
<td>std::true_type/std::false_type</td>
</tr>
<tr>
<td><code>create&lt;T, TName, TProvider\&gt;</code></td>
<td><a href="#di_providable">providable</a>&lt;TProvider></td>
<td>Creates type might be created</td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<p><strong><em>Test</em></strong>
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/scopes_deduce_default.cpp" />
<strong><em>Example</em></strong></p>
<p><img alt="CPP(BTN)" src="../Run_Deduce_Scope_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/deduce_scope.cpp" />
<img alt="CPP(BTN)" src="../Run_Scopes_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/scopes.cpp" /></p>
<p><br /><hr /></p>
<p><a id="di_instance"></a>
--- <strong><em>di::instance (di::bind&lt;&gt;.to(value))</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Scope representing values - passed by user. The life time of the object depends on the user.
Boost.DI is not managing life time of passed objects, however values and strings will be copied and managed by the library.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>instance</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>✔</td>
</tr>
<tr>
<td>T&amp;</td>
<td>-</td>
</tr>
<tr>
<td>const T&amp;</td>
<td>✔ (temporary)</td>
</tr>
<tr>
<td>T* (transfer ownership)</td>
<td>✔</td>
</tr>
<tr>
<td>const T*</td>
<td>✔</td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td>✔</td>
</tr>
<tr>
<td>unique_ptr<T></td>
<td>✔</td>
</tr>
<tr>
<td>shared_ptr<T></td>
<td>✔</td>
</tr>
<tr>
<td>weak_ptr<T></td>
<td>-</td>
</tr>
</tbody>
</table>
<p><strong><em>Semantics</em></strong></p>
<pre><code>namespace scopes {
  struct instance {
    template &lt;class TExpected, class TGiven&gt;
    struct scope {
      template &lt;class T&gt;
      using is_referable;

      template &lt;class T, class TName, class TProvider&gt;
      static auto try_create(const TProvider&amp;);

      template &lt;class T, class TName, class TProvider&gt;
      auto create(const TProvider&amp;);
    };
  };
}
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TExpected</code></td>
<td>-</td>
<td>'Interface' type</td>
<td>-</td>
</tr>
<tr>
<td><code>TGiven</code></td>
<td>-</td>
<td>'Implementation' type</td>
<td>-</td>
</tr>
<tr>
<td><code>is_referable&lt;T\&gt;</code></td>
<td>-</td>
<td>Verifies whether scope value might be converted to a reference</td>
<td>std::true_type/std::false_type</td>
</tr>
<tr>
<td><code>try_create&lt;T, TName, TProvider\&gt;</code></td>
<td><a href="#di_providable">providable</a>&lt;TProvider></td>
<td>Verifies whether type might be created</td>
<td>std::true_type/std::false_type</td>
</tr>
<tr>
<td><code>create&lt;T, TName, TProvider\&gt;</code></td>
<td><a href="#di_providable">providable</a>&lt;TProvider></td>
<td>Creates type might be created</td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<p><strong><em>Test</em></strong>
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/scopes_instance.cpp" />
<strong><em>Example</em></strong></p>
<p><img alt="CPP(BTN)" src="../Run_Bindings_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/bindings.cpp" />
<img alt="CPP(BTN)" src="../Run_Scopes_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/scopes.cpp" /></p>
<p><br /><hr /></p>
<p><a id="di_singleton"></a>
--- <strong><em>di::singleton</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Scope representing shared value between all instances and between threads.
Singleton scope will be deduced in case of shared_ptr or weak_ptr.</p>
<div class="warning">
<h3><span class="fa fa-eye wy-text-neutral"></span>&nbsp; Note</h3>
Singleton scope will convert between std::shared_ptr and boost::shared_ptr if required.
</div>

<table>
<thead>
<tr>
<th>Type</th>
<th>singleton</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>✔</td>
</tr>
<tr>
<td>T&amp;</td>
<td>-</td>
</tr>
<tr>
<td>const T&amp;</td>
<td>✔ (temporary)</td>
</tr>
<tr>
<td>T* (transfer ownership)</td>
<td>✔</td>
</tr>
<tr>
<td>const T*</td>
<td>✔</td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td>✔</td>
</tr>
<tr>
<td>unique_ptr<T></td>
<td>✔</td>
</tr>
<tr>
<td>shared_ptr<T></td>
<td>✔</td>
</tr>
<tr>
<td>weak_ptr<T></td>
<td>-</td>
</tr>
</tbody>
</table>
<p><strong><em>Semantics</em></strong></p>
<pre><code>namespace scopes {
  struct singleton {
    template &lt;class TExpected, class TGiven&gt;
    struct scope {
      template &lt;class T&gt;
      using is_referable;

      template &lt;class T, class TName, class TProvider&gt;
      static auto try_create(const TProvider&amp;);

      template &lt;class T, class TName, class TProvider&gt;
      auto create(const TProvider&amp;);
    };
  };
}

scopes::singleton singleton;
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TExpected</code></td>
<td>-</td>
<td>'Interface' type</td>
<td>-</td>
</tr>
<tr>
<td><code>TGiven</code></td>
<td>-</td>
<td>'Implementation' type</td>
<td>-</td>
</tr>
<tr>
<td><code>is_referable&lt;T\&gt;</code></td>
<td>-</td>
<td>Verifies whether scope value might be converted to a reference</td>
<td>std::true_type/std::false_type</td>
</tr>
<tr>
<td><code>try_create&lt;T, TName, TProvider\&gt;</code></td>
<td><a href="#di_providable">providable</a>&lt;TProvider></td>
<td>Verifies whether type might be created</td>
<td>std::true_type/std::false_type</td>
</tr>
<tr>
<td><code>create&lt;T, TName, TProvider\&gt;</code></td>
<td><a href="#di_providable">providable</a>&lt;TProvider></td>
<td>Creates type might be created</td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<p><strong><em>Test</em></strong>
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/scopes_singleton.cpp" />
<strong><em>Example</em></strong></p>
<p><img alt="CPP(BTN)" src="../Run_Scopes_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/scopes.cpp" />
<img alt="CPP(BTN)" src="../Run_Eager_Singletons_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/eager_singletons.cpp" /></p>
<p><br /><hr /></p>
<p><a id="di_unique"></a>
--- <strong><em>di::unique</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Scope representing unique/per request value.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>unique</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>✔</td>
</tr>
<tr>
<td>T&amp;</td>
<td>-</td>
</tr>
<tr>
<td>const T&amp;</td>
<td>✔ (temporary)</td>
</tr>
<tr>
<td>T* (transfer ownership)</td>
<td>✔</td>
</tr>
<tr>
<td>const T*</td>
<td>✔</td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td>✔</td>
</tr>
<tr>
<td>unique_ptr<T></td>
<td>✔</td>
</tr>
<tr>
<td>shared_ptr<T></td>
<td>✔</td>
</tr>
<tr>
<td>weak_ptr<T></td>
<td>-</td>
</tr>
</tbody>
</table>
<p><strong><em>Semantics</em></strong></p>
<pre><code>namespace scopes {
  struct unique {
    template &lt;class TExpected, class TGiven&gt;
    struct scope {
      template &lt;class T&gt;
      using is_referable;

      template &lt;class T, class TName, class TProvider&gt;
      static auto try_create(const TProvider&amp;);

      template &lt;class T, class TName, class TProvider&gt;
      auto create(const TProvider&amp;);
    };
  };
}

scopes::unique unique;
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TExpected</code></td>
<td>-</td>
<td>'Interface' type</td>
<td>-</td>
</tr>
<tr>
<td><code>TGiven</code></td>
<td>-</td>
<td>'Implementation' type</td>
<td>-</td>
</tr>
<tr>
<td><code>is_referable&lt;T\&gt;</code></td>
<td>-</td>
<td>Verifies whether scope value might be converted to a reference</td>
<td>std::true_type/std::false_type</td>
</tr>
<tr>
<td><code>try_create&lt;T, TName, TProvider\&gt;</code></td>
<td><a href="#di_providable">providable</a>&lt;TProvider></td>
<td>Verifies whether type might be created</td>
<td>std::true_type/std::false_type</td>
</tr>
<tr>
<td><code>create&lt;T, TName, TProvider\&gt;</code></td>
<td><a href="#di_providable">providable</a>&lt;TProvider></td>
<td>Creates type might be created</td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<p><strong><em>Test</em></strong>
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/scopes_unique.cpp" />
<strong><em>Example</em></strong></p>
<p><img alt="CPP(BTN)" src="../Run_Scopes_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/scopes.cpp" /></p>
<p><br /><hr /></p>
<h3 id="modules">Modules</h3>
<p><a id="di_module"></a></p>
<pre><code class="cpp">auto module = [] { return di::make_injector(...); };
</code></pre>

<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Modules allow to split the configuration into smaller injectors.
Module might be installed by passing it into [make_injector].</p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>auto module = di::make_injector(...);
</code></pre>
<p><strong><em>Test</em></strong>
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/module.cpp" />
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/module_exposed_type.cpp" />
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/module_exposed_many_types.cpp" />
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/module_exposed_annotated_type.cpp" />
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/module_exposed_complex_types.cpp" />
<strong><em>Example</em></strong></p>
<p><img alt="CPP(BTN)" src="../Run_Modules_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/modules.cpp" /></p>
<p><br /><hr /></p>
<h3 id="providers">Providers</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Providers are responsible for creating objects using given configuration.</p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>namespace type_traits {
  struct direct; // T(...)
  struct uniform; // T{...}
  struct heap; // new T
  struct stack; // T
}

namespace providers {
  class provider {
    public:
      template &lt;class T, class... TArgs&gt;
      struct is_creatable;

      template &lt;
        class T
      , class TInit // type_traits::direct/type_traits::uniform
      , class TMemory // type_traits::heap/type_traits::stack
      , class... TArgs
      &gt; auto get(const TInit&amp;, const TMemory&amp;, TArgs&amp;&amp;... args) const;
  };
}
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>is_creatable&lt;T, TArgs...\&gt;</code></td>
<td><a href="#di_creatable">creatable</a>&lt;TArgs...></td>
<td>Verify whether <code>T</code> is creatable with <code>TArgs...</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>get&lt;T, TInitialization, TMemory, TArgs\&gt;(const TInitialization&amp;, const TMemory&amp;, TArgs&amp;&amp;...)</code></td>
<td><code>TInitialization</code> is direct\</td>
<td>uniform &amp;&amp; <code>TMemory</code> is heap\</td>
<td>stack</td>
</tr>
</tbody>
</table>
<p><strong><em>Test</em></strong>
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/providers_heap_no_throw.cpp" />
<strong><em>Example</em></strong></p>
<p><img alt="CPP(BTN)" src="../Run_Custom_Provider_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_provider.cpp" />
<img alt="CPP(BTN)" src="../Run_Pool_Provider_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/pool_provider.cpp" /></p>
<p><br /><hr /></p>
<p><a id="di_stack_over_heap"></a>
--- <strong><em>di::providers::stack_over_heap (default)</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Creates objects on the stack whenever possible, otherwise on the heap.</p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>namespace providers {
  class stack_over_heap {
    public:
      template &lt;class T, class... TArgs&gt;
      struct is_creatable;

      template &lt;
        class T
      , class TInit // type_traits::direct/type_traits::uniform
      , class TMemory // type_traits::heap/type_traits::stack
      , class... TArgs
      &gt; auto get(const TInit&amp;, const TMemory&amp;, TArgs&amp;&amp;... args) const;
  };
}
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>is_creatable&lt;T, TArgs...\&gt;</code></td>
<td><a href="#di_creatable">creatable</a>&lt;TArgs...></td>
<td>Verify whether <code>T</code> is creatable with <code>TArgs...</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>get&lt;T, TInitialization, TMemory, TArgs\&gt;(const TInitialization&amp;, const TMemory&amp;, TArgs&amp;&amp;...)</code></td>
<td><code>TInitialization</code> is direct\</td>
<td>uniform &amp;&amp; <code>TMemory</code> is heap\</td>
<td>stack</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Type</th>
<th><code>TMemory</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>stack</td>
</tr>
<tr>
<td>T&amp;</td>
<td>stack</td>
</tr>
<tr>
<td>const T&amp;</td>
<td>stack</td>
</tr>
<tr>
<td>T*</td>
<td>stack</td>
</tr>
<tr>
<td>const T*</td>
<td>stack</td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td>stack</td>
</tr>
<tr>
<td>unique_ptr<T></td>
<td>stack</td>
</tr>
<tr>
<td>shared_ptr<T></td>
<td>stack</td>
</tr>
<tr>
<td>weak_ptr<T></td>
<td>stack</td>
</tr>
</tbody>
</table>
<p><strong><em>Test</em></strong>
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/providers_stack_over_heap.cpp" />
<strong><em>Example</em></strong></p>
<p><img alt="CPP(BTN)" src="../Run_Custom_Provider_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_provider.cpp" />
<img alt="CPP(BTN)" src="../Run_Pool_Provider_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/pool_provider.cpp" /></p>
<p><br /><hr /></p>
<p><a id="di_heap"></a>
--- <strong><em>di::providers::heap</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Basic provider creates objects on the heap.</p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>namespace providers {
  class stack_over_heap {
    public:
      template &lt;class T, class... TArgs&gt;
      struct is_creatable;

      template &lt;
        class T
      , class TInit // type_traits::direct/type_traits::uniform
      , class TMemory // type_traits::heap/type_traits::stack
      , class... TArgs
      &gt; auto get(const TInit&amp;, const TMemory&amp;, TArgs&amp;&amp;... args) const;
  };
}
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>is_creatable&lt;T, TArgs...\&gt;</code></td>
<td><a href="#di_creatable">creatable</a>&lt;TArgs...></td>
<td>Verify whether <code>T</code> is creatable with <code>TArgs...</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>get&lt;T, TInitialization, TMemory, TArgs\&gt;(const TInitialization&amp;, const TMemory&amp;, TArgs&amp;&amp;...)</code></td>
<td><code>TInitialization</code> is direct\</td>
<td>uniform &amp;&amp; <code>TMemory</code> is heap\</td>
<td>stack</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Type</th>
<th><code>TMemory</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>stack</td>
</tr>
<tr>
<td>T&amp;</td>
<td>stack</td>
</tr>
<tr>
<td>const T&amp;</td>
<td>stack</td>
</tr>
<tr>
<td>T*</td>
<td>stack</td>
</tr>
<tr>
<td>const T*</td>
<td>stack</td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td>stack</td>
</tr>
<tr>
<td>unique_ptr<T></td>
<td>stack</td>
</tr>
<tr>
<td>shared_ptr<T></td>
<td>stack</td>
</tr>
<tr>
<td>weak_ptr<T></td>
<td>stack</td>
</tr>
</tbody>
</table>
<p><strong><em>Test</em></strong>
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/providers_heap.cpp" />
<strong><em>Example</em></strong></p>
<p><img alt="CPP(BTN)" src="../Run_Custom_Provider_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_provider.cpp" />
<img alt="CPP(BTN)" src="../Run_Pool_Provider_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/pool_provider.cpp" />
<img alt="CPP(BTN)" src="../Run_Mocks_Provider_Extension|https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/providers/mocks_provider.cpp" /></p>
<p><br /><br /><br /><hr /></p>
<h3 id="policies">Policies</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Policies operates on dependencies in order to limit allowed behaviour or visit created types during run-time.
Policies are set up via [di::config].</p>
<div class="warning">
<h3><span class="fa fa-eye wy-text-neutral"></span>&nbsp; Note</h3>
By default Boost.DI has no policies enabled.
</div>

<p><strong><em>Semantics</em></strong></p>
<p>template <class... TPolicies> requires callable<TPolicies...>
  auto make_policies(TPolicies... args) noexcept;</p>
<p>struct config : di::config {
    static auto policies(...) noexcept { return make_policies(...); }
  };</p>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>make_policies&lt;TPolicies...\&gt;</code></td>
<td><a href="#di_callable">callable</a>&lt;TPolicies...></td>
<td>Creates policies</td>
<td><a href="#di_callable">callable</a> list</td>
</tr>
</tbody>
</table>
<div class="warning">
<h3><span class="fa fa-eye wy-text-neutral"></span>&nbsp; Note</h3>
In order for injector to verify policies they have to be created using di::config and passed via `TConfig` in make_injector or set globally via BOOST_DI_CFG.
</div>

<p><strong><em>Test</em></strong>
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/policies_print_types.cpp" />
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/policies_print_type_extended.cpp" />
<strong><em>Example</em></strong></p>
<p><img alt="CPP(BTN)" src="../Run_Custom_Policy_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_policy.cpp" />
<img alt="CPP(BTN)" src="../Run_Types_Dumper_Extension|https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/policies/types_dumper.cpp" />
<img alt="CPP(BTN)" src="../Run_UML_Dumper_Extension|https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/policies/uml_dumper.cpp" /></p>
<p><br /><br /><br /><hr /></p>
<p><a id="di_constructible"></a>
--- <strong><em>di::policies::constructible</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Policy limits constructor parameters to explicitly allowed.</p>
<div class="warning">
<h3><span class="fa fa-eye wy-text-neutral"></span>&nbsp; Note</h3>
By default constructible policy disables creation of any constructor parameters.
</div>

<p><strong><em>Semantics</em></strong></p>
<pre><code>namespace policies {
  struct _ { }; // placeholder

  template&lt;class T&gt;
  struct is_bound; // true when type is bound with 'di::bind&lt;T&gt;'

  template &lt;class T&gt;
  struct is_injected; // true when type is injected using 'BOOST_DI_INJECT' or is 'fundamental'

  template&lt;class T&gt;
  auto constructible(const T&amp;) noexcept;
}

namespace operators {
  template&lt;class X&gt;
  inline auto operator!(const X&amp;)

  template&lt;class X, class Y&gt;
  inline auto operator&amp;&amp;(const X&amp;, const Y&amp;);

  template&lt;class X, class Y&gt;
  inline auto operator||(const X&amp;, const Y&amp;);
}
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>is_bound&lt;T\&gt;</code></td>
<td>-</td>
<td>Verify whether type <code>T</code> is bound</td>
<td>true_type/false_type</td>
</tr>
<tr>
<td><code>is_injected&lt;T\&gt;</code></td>
<td>-</td>
<td>Verify whether type <code>T</code> is injected via <a href="#BOOST_DI_INJECT">BOOST_DI_INJECT</a></td>
<td>true_type/false_type</td>
</tr>
</tbody>
</table>
<div class="warning">
<h3><span class="fa fa-eye wy-text-neutral"></span>&nbsp; Note</h3>
In order to allow logic operators using namespace boost::di::policies::operators has to be used
</div>

<p><strong><em>Test</em></strong>
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/policies_constructible_local.cpp" />
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/policies_constructible_global.cpp" /></p>
<div class="warning">
<h3><span class="fa fa-eye wy-text-neutral"></span>&nbsp; Note</h3>
STL type traits are supported and might be combined with Boost.DI traits in order to limit constructor types
For example, std::is_same<_, int>{} || std::is_constructible<_, int, int>{} || std::is_base_of<int, _>{}, etc...
</div>

<p><strong><em>Example</em></strong></p>
<p><img alt="CPP(BTN)" src="../Run_Custom_Policy_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_policy.cpp" />
<img alt="CPP(BTN)" src="../Run_Types_Dumper_Extension|https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/policies/types_dumper.cpp" />
<img alt="CPP(BTN)" src="../Run_UML_Dumper_Extension|https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/policies/uml_dumper.cpp" /></p>
<p><br /><br /><br /><hr /></p>
<h3 id="concepts">Concepts</h3>
<p>Concepts are types constraints which ensure that only given types which are satisfied by the constraint will be allowed.
If type doesn't satisfy the concept short and descriptive error message is provided.</p>
<p><a id="di_boundable"></a>
--- <strong><em>di::concepts::boundable</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Bindings type requirement.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template &lt;class TExpected, class TGiven&gt;
concept bool boundable() {
  return is_complete&lt;TExpected&gt;()
      &amp;&amp; is_complete&lt;TGiven&gt;()
      &amp;&amp; (is_base_of&lt;TExpected, TGiven&gt;() || is_convertible&lt;TGiven, TExpected&gt;());
}

template &lt;class... Ts&gt;
concept bool boundable() {
  return is_supported&lt;Ts&gt;()... 
      &amp;&amp; is_movable&lt;Ts&gt;()...
      &amp;&amp; (is_base_of&lt;injector, Ts&gt;()... || is_base_of&lt;dependency, Ts&gt;()...);
}
</code></pre>
<p><strong><em>Semantics</em></strong></p>
<pre><code>boundable&lt;T&gt;
boundable&lt;Ts...&gt;
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Ts...</code></td>
<td>Bindings to be verified</td>
<td>true_type if constraint is satisfied, <code>error</code> otherwise</td>
</tr>
</tbody>
</table>
<p><strong><em>Example</em></strong></p>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>type&lt;T&gt;::has_disallowed_qualifiers</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>type <code>T</code> has disallowed qualifiers</td>
</tr>
<tr>
<td>Expression</td>
<td><img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_has_disallowed_qualifiers.cpp" /></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>type&lt;T&gt;::is_abstract</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>type <code>T</code> is abstract</td>
</tr>
<tr>
<td><code>BOOST_DI_CFG_DIAGNOSTICS_LEVEL</code></td>
<td>0, 1 -&gt; no additional info, 2 -&gt; info about why type <code>T</code> is abstract</td>
</tr>
<tr>
<td>Expression</td>
<td><img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_abstract.cpp" /></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>type&lt;T&gt;::is_not_related_to</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>type <code>T</code> is not related to type <code>U</code></td>
</tr>
<tr>
<td>Expression</td>
<td><img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_not_related_to.cpp" /></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>type&lt;T&gt;::is_bound_more_than_once</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>type <code>T</code> is bound more than once</td>
</tr>
<tr>
<td>Expression</td>
<td><img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_bound_more_than_once.cpp" /></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>type&lt;T&gt;::is_neither_a_dependency_nor_an_injector</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>type <code>T</code> is neither a dependency nor an injector</td>
</tr>
<tr>
<td>Expression</td>
<td><img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_neither_a_dependency_nor_an_injector.cpp" /></td>
</tr>
</tbody>
</table>
<hr />
<p><a id="di_callable"></a>
--- <strong><em>di::concepts::callable</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Policies type requirement.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template &lt;class T&gt;
concept bool callable() {
  return requires(T object) {
    { object(...) };
  }
}
</code></pre>
<p><strong><em>Semantics</em></strong></p>
<pre><code>callable&lt;T&gt;
</code></pre>
<p><strong><em>Example</em></strong></p>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>policy&lt;TPolicy&gt;::requires_&lt;call_operator&gt;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>policy <code>TPolicy</code> requires a call operator</td>
</tr>
<tr>
<td>Expression</td>
<td><img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/callable_requires_call_operator.cpp" /></td>
</tr>
</tbody>
</table>
<hr />
<p><a id="di_configurable"></a>
--- <strong><em>di::concepts::configurable</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template &lt;class T&gt;
concept bool configurable() {
  return requires(T object) {
    return providable&lt;decltype(T::provider(...))&gt; &amp;&amp; callable&lt;decltype(T::policies(...))&gt;();
  }
}
</code></pre>
<p><strong><em>Semantics</em></strong></p>
<pre><code>configurable&lt;T&gt;
</code></pre>
<p><strong><em>Example</em></strong></p>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>config&lt;TConfig&gt;::requires_&lt;provider&lt;providable_type (...)&gt;&gt;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>config <code>T</code> requires only providable and callable types</td>
</tr>
<tr>
<td>Expression</td>
<td><img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/configurable_requires_callable_and_providable.cpp" /></td>
</tr>
</tbody>
</table>
<hr />
<p><a id="di_creatable"></a>
--- <strong><em>di::concepts::creatable</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Type creation requirement.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template &lt;class T, class... TBindings&gt;
concept bool creatable() {
  return is_recursively_constructible&lt;T, TBindings...&gt;();
}
</code></pre>
<p><strong><em>Semantics</em></strong></p>
<pre><code>creatable&lt;T, TBindings...&gt;
</code></pre>
<p><strong><em>Example</em></strong></p>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>abstract_type&lt;T&gt;::is_not_bound</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>config <code>T</code> requires only providable and callable types</td>
</tr>
<tr>
<td><code>BOOST_DI_CFG_DIAGNOSTICS_LEVEL</code></td>
<td>0 -&gt; 'constraint not satisfied', 1 -&gt; (0) + abstract type is not bound, 2 -&gt; (1) + creation tree</td>
</tr>
<tr>
<td>Suggestion</td>
<td>'type is not bound, did you forget to add: 'di::bind<interface>.to<implementation>()'?'</td>
</tr>
<tr>
<td>Expression</td>
<td><img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_abstract_type_is_not_bound.cpp" /></td>
</tr>
<tr>
<td>Expression</td>
<td><img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_expose_abstract_type_is_not_bound.cpp" /></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>type&lt;T&gt;::has_ambiguous_number_of_constructor_parameters::given&lt;Given&gt;::expected&lt;Expected&gt;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>type <code>T</code> has ambiguous number of constructor parameters where <code>Given</code> were provided but <code>Expected</code> were expected</td>
</tr>
<tr>
<td><code>BOOST_DI_CFG_DIAGNOSTICS_LEVEL</code></td>
<td>0 -&gt; 'constraint not satisfied', 1 -&gt; (0) + abstract type is not bound, 2 -&gt; (1) + creation tree</td>
</tr>
<tr>
<td>Suggestion</td>
<td>'verify BOOST_DI_INJECT_TRAITS or di::ctor_traits'</td>
</tr>
<tr>
<td>Expression</td>
<td><img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_type_has_ambiguous_number_of_constructor_parameters.cpp" /></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>type&lt;T&gt;::has_to_many_constructor_parameters::max&lt;Max&gt;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>type <code>T</code> has to many constructor parameter where maximum number is <code>Max</code></td>
</tr>
<tr>
<td><code>BOOST_DI_CFG_DIAGNOSTICS_LEVEL</code></td>
<td>0 -&gt; 'constraint not satisfied', 1 -&gt; (0) + abstract type is not bound, 2 -&gt; (1) + creation tree</td>
</tr>
<tr>
<td>Suggestion</td>
<td>'increase BOOST_DI_CFG_CTOR_LIMIT_SIZE value or reduce number of constructor parameters'</td>
</tr>
<tr>
<td>Expression</td>
<td><img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_type_has_to_many_constructor_parameters.cpp" /></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>scoped&lt;TScope&gt;::is_not_convertible_to&lt;T&gt;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>scope <code>TScope</code> is not convertible to type <code>T</code></td>
</tr>
<tr>
<td><code>BOOST_DI_CFG_DIAGNOSTICS_LEVEL</code></td>
<td>0 -&gt; 'constraint not satisfied', 1 -&gt; (0) + abstract type is not bound, 2 -&gt; (1) + creation tree</td>
</tr>
<tr>
<td>Suggestion</td>
<td>'scoped object is not convertible to the requested type, did you mistake the scope: 'di::bind<T>.in(scope)'?'</td>
</tr>
<tr>
<td>Expression</td>
<td><img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_scoped_is_not_convertible_to.cpp" /></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>scoped&lt;instance&gt;::is_not_convertible_to&lt;T&gt;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>instance is not convertible to type <code>T</code></td>
</tr>
<tr>
<td><code>BOOST_DI_CFG_DIAGNOSTICS_LEVEL</code></td>
<td>0 -&gt; 'constraint not satisfied', 1 -&gt; (0) + abstract type is not bound, 2 -&gt; (1) + creation tree</td>
</tr>
<tr>
<td>Suggestion</td>
<td>'instance is not convertible to the requested type, verify binding: 'di::bind<T>.to(value)'?'</td>
</tr>
<tr>
<td>Expression</td>
<td><img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_instance_is_not_convertible_to.cpp" /></td>
</tr>
</tbody>
</table>
<div class="warning">
<h3><span class="fa fa-eye wy-text-neutral"></span>&nbsp; Note</h3>
Suggestions are not supported/displayed by MSVC-2015.
</div>

<hr />
<p><a id="di_providable"></a>
--- <strong><em>di::concepts::providable</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Provider type requirement.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template &lt;class T&gt;
concept bool providable() {
  return requires(T object) {
    { object.template get&lt;_&gt;(direct/uniform{}, stack/heap{}, ...) };
    { object.template is_creatable&lt;_&gt;(direct/uniform{}, stack/heap{}, ...) };
  }
}
</code></pre>
<p><strong><em>Semantics</em></strong></p>
<p>providable<T></p>
<p><strong><em>Example</em></strong></p>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>provider&lt;TProvider&gt;::requires_&lt;get&gt;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>provider <code>TProvider</code> requires <code>get</code> method</td>
</tr>
<tr>
<td>Expression</td>
<td><img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/providable_requires_get.cpp" /></td>
</tr>
</tbody>
</table>
<hr />
<p><a id="di_scopable"></a>
--- <strong><em>di::concepts::scopable</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Scope type requirement.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template &lt;class T&gt;
concept bool scopable() {
  return requires(T) {
    typename scope&lt;_, _&gt;::is_referable;
    { T::scope&lt;_, _&gt;{}.try_create() };
    { T::scope&lt;_, _&gt;{}.create() };
  }
}
</code></pre>
<p><strong><em>Semantics</em></strong></p>
<p>scopable<T></p>
<p><strong><em>Example</em></strong></p>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>scope&lt;TScope&gt;::requires_&lt;create&gt;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>scope <code>TScope</code> requires <code>create</code> method</td>
</tr>
<tr>
<td>Expression</td>
<td><img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/scopable_requires_create.cpp" /></td>
</tr>
</tbody>
</table>
<hr />
<h3 id="configuration">Configuration</h3>
<p><a id="di_config"></a>
--- <strong><em>di::config</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Injector configuration.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>struct config {
  static auto provider(...) noexcept;
  static auto policies(...) noexcept;
};
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>provider()</code></td>
<td><a href="#di_providable">providable</a></td>
<td>Creates provider</td>
<td><a href="#di_providable">providable</a></td>
</tr>
<tr>
<td><code>policies()</code></td>
<td><a href="#di_callable">callable</a></td>
<td>Creates policies</td>
<td><a href="#di_callable">callable</a></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BOOST_DI_CFG</code></td>
<td>Global configuration allows to customize provider and policies</td>
</tr>
</tbody>
</table>
<p><strong><em>Semantics</em></strong></p>
<pre><code>di::make_injector&lt;config&gt;(...)
// or
#define BOOST_DI_CFG config // change default
di::make_injector(...)
</code></pre>
<p><strong><em>Test</em></strong>
<img alt="CPP(SPLIT)" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/policies_constructible_global.cpp" />
<strong><em>Example</em></strong></p>
<p><img alt="CPP(BTN)" src="../Run_Configuration_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/configuration.cpp" /></p>
<p><br /><hr /></p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../examples/index.html" class="btn btn-neutral float-right" title="Examples">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../quick_user_guide/index.html" class="btn btn-neutral" title="Quick User Guide"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div id="disqus_thread"></div>
  <script type="text/javascript">
  /* * * CONFIGURATION VARIABLES * * */
  var disqus_shortname = '';

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
      <p>Copyright &copy; 2016</p>
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../quick_user_guide/index.html" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../examples/index.html" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>

<script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
</body>
</html>
