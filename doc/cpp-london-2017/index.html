<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Boost your design with C++14 dependency injection</title>

		<meta name="description" content="Boost your design with C++14 dependency injection">
		<meta name="author" content="Kris Jusiak">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/league.css" id="theme">

            <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<div class="slides">

          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$"
                   data-notes="^Note:">
					<script type="text/template">

C++ London Feb-2017

#Boost your design with dependency injection

Kris Jusiak, Quantlab

---

[kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)

==============================================================================

##Agenda

* In search of the best design
    * God object, Single responsibility, Static factories, Constructor injection
    * Policy design, Static polymorphism, Virtual concepts (C++2X)
    * Functional design, Type erasure, Dynamic polymorphism (Object Oriented design)
* [[Boost].DI](https://github.com/boost-experimental/di)
    * Overview
    * Showcase
    * Testing
* Summary

----

##Disclaimer

---

* ###We will focus on a simple example
###but let's think large scale (big team projects)

==============================================================================

##Story: Show a value from a file (BDD Style)

```
Scenario 1: Value from a file is displayed
 Given an 'input.txt' file with an integer value in it
   And console terminal ready
 When the App runs
 Then the integer value from 'input.txt' should
      be shown on the terminal console
```

----

#In search of the best design!

* Loosely coupled code
* Testable code

----

## KISS - ~~Keep it simple~~, STUPID (V0)

```cpp
class App { // God object - does too much!
  void run() {
    auto value = 0;
    {
      std::ifstream file{"input.txt"};
      assert(file.good());
      file >> value;
    }
    std::cout << value << '\n';
  }
};
```

```cpp
int main() {
    App{}.run();
}
```

----

## God object (V0)

![app](images/app0.png)

* (+) Does the job?
* (-) Hard to extend/maintain
* (-) Hard to test (TDD/BDD)

----

##Composition Root

> Unique location in an application where modules are composed together

```cpp
int main() {
  App{}.run();
}
```

----

##Let's introduce some abstractions (V1)

```cpp
class Reader {
  static constexpr auto path = "input.txt";
  std::ifstream file{path};

public:
  auto read() {
    auto value = 0;
    file >> value;
    return value;
  }
};
```

```cpp
class Viewer {
  public:
    void show(int value) {
      std::cout << value << '\n';
    }
};
```

----

##Let's introduce some abstractions (V1)

```cpp
class App {
  Reader reader;
  Viewer viewer;

  void run() {
    viewer.show(reader.read());
  }
};
```

```cpp
int main() {
  App{}.run();
}
```

----

##Let's introduce some abstractions (V1)

![app](images/app2.png)

* (+) Still does the job
* (+/-) We can somewhat test it in isolation (can't test the App)
* (-) Reader/Viewer tightly coupled to App

----

##Single responsibility principle

> "A class should have only one reason to change" Unclue Bob

----

##Let's fix it by using static factories? (V2)

```cpp
class IReader; class FileReader;
class IViewer; class ConsoleViewer;
```

```cpp
struct ReaderFactory {
  static auto create(std::string_view input) {
    return std::make_unique<FileReader>(input);
  }
};
```

```cpp
struct ViewerFactory {
  static auto create() {
    return std::make_unique<ConsoleViewer>();
  }
};
```

----

##Let's fix it by using static factories? (V2)

```cpp
class App {
public:
  void run() {
    ViewerFactory::create()->show(
      ReaderFactory::create("input.txt")->read()
    );
  }

};
```

```cpp
int main() {
  App{}.run();
}
```

----

##Let's fix it by using static factories? (V2)

* (+) Still does the job
* (+) We can test it in isolation but it's hard
* (+) Reader/Viewer are still tightly coupled to App
* (-) Can't inject different Readers/Viewers
* (-) Can't test factories easily

> Static factories MUST GO!

----

##Let's fix it by constructor injection? (V3)

```cpp
class Reader;
class Viewer;
```

```cpp
class App {
 Reader reader;
 Viewer viewer;

 public:
  App(Reader&& reader, Viewer&& viewer)
    : reader(std::move(reader))
    , viewer(std::move(viewer))
  { }

  void run() {
    viewer.show(reader.read());
  }
};
```

```cpp
int main() {
  Reader reader;
  Viewer viewer;
  App app{std::move(reader), std::move(viewer)};
}
```

----

##Let's fix it by constructor injection? (V3)

![app](images/app1.png)

* (+) Still does the job
* (+) We can test it in isolation (including App) but it's hard
* (+) Reader/Viewer are not tightly coupled to App
* (-) Can't inject different Readers/Viewers

----

##There you have it - Dependency Injection (DI)

> "Don't call us, we'll call you", Hollywood principle
> Separates creation logic from business logic

-

###Wiring - Create and pass required dependencies
```cpp
Reader reader{...};
Viewer viewer{...};
...
App app{...}
```

----

##Let's fix it by templates - Policy Design / Duck Typing (V4)

```cpp
class Reader;
class Viewer;
```

```cpp
template<class TReader, class TViewer>
class App {
  TReader reader;
  TViewer viewer;

public:
  App(TReader& reader, TViewer& viewer)
    : reader(reader), viewer(viewer)
  { }

  void run() {
    viewer.show(reader.read());
  }
};
```

----

##Let's fix it by templates - Policy Design / Duck Typing (V4)

```cpp
int main() {
  Reader reader;
  Viewer viewer;
  App<Reader, Viewer>{reader, viewer}.run();
}
```

* (+) Still does the job
* (+) We can test it in isolation (including App) but it's hard
* (+) Reader/Viewer are not tightly coupled to App
* (+) Can't inject different Readers/Viewers
* (-) We are limited to header files
* (-) Slower compilation times (Point of instantiation - POI)
* (-) Code bloat (executable size)
* (-) Template are contagious
* (-) Horrible error messages

> STL example: template<class T, class Allocator = std::allocator<T>> class vector;

----

##Template argument deduction for class templates (C++17)

###C++14
```cpp
  App<Reader, Viewer>{reader, viewer}.run();
```

###C++17
```cpp
  App{reader, viewer}.run(); // templates are still there
                             // just deduced from parameters
```

----

##Let's interface it by static polymorphism (V5)
####Curiously recurring template pattern (CRTP)

```cpp
template <class T>
class Reader {
  int read_impl() { return {}; }
public:
  int read() { return static_cast<T*>(this)->read_impl(); }
};
```

```cpp
class FileReader : public Reader<FileReader> {
  std::ifstream file;
public:
  explicit FileReader(std::string_view path) : file(path) {
      assert(file.good());
  }

  int read_impl() {
    auto value = 0;
    file >> value;
    return value;
  }
};
```

----

##Let's interface it by static polymorphism? (V5)

```cpp
template <class T>
class Viewer {
  void show_impl(int) {}
public:
  void show(int value) { static_cast<T*>(this)->show_impl(value); }
};
```

```cpp
class ConsoleViewer : public Viewer<ConsoleViewer> {
public:
  void show_impl(int value) { std::cout << value << std::endl; }
};
```

----

##Let's interface it by static polymorphism? (V5)

```cpp
template <class TReader, class TViewer>
class App {
  TReader& reader;
  TViewer& viewer;

public:
  App(TReader& reader, TViewer& viewer) 
   : reader(reader), viewer(viewer) 
  {}

  void run() { viewer.show(reader.read()); }
};
```

```cpp
int main() {
  FileReader reader{"input.txt"};
  ConsoleViewer viewer{};
  App{reader, viewer}.run();
}
```

----

![app](images/app3.png)

* (+) Still does the job
* (+) We can test it in isolation (including App) but it's hard
* (+) Reader/Viewer are not tightly coupled to App
* (+) Can't inject different Readers/Viewers
* (-) We are limited to header files
* (-) Slower compilation times (Point of instantiation - POI)
* (-) Bigger executable size
* (-) Horrible error messages

----

##Virtual Concepts to the rescue? (C++2X?)

```cpp
template <class T>
concept bool Readable() {
  return requires(T reader) {
    { reader.read(std::string_view{}) } -> int;
  }
};
```

```cpp
template <class T>
concept bool Viewable() {
  return requires(T viewer) {
    { viewer.show() };
  }
};
```

----

##Virtual Concepts to the rescue? (C++2X?)

```cpp
class App {
  virtual Readable reader; // stack, Small Buffer Optimization
  virtual Viewable viewer; // type erasure

public:
  // implies templat<Readable T1, Viewable T2> App
  App(Readable reader, Viewable viewer)
    : reader(reader), viewer(viewer) {}

  void run() {
    viewer.show(reader.read());
  }
};
```

```cpp
int main() {
  Readable reader = FileReader{"input.txt"};
  Viewable viwer = ConsoleViewer();

  App{reader, viewer}.run();
}
```

----

##Virtual Concepts to the rescue? (C++2X?)

* (+) Still does the job
* (+) We can test it in isolation (including App) but it's hard
* (+) Reader/Viewer are not tightly coupled to App
* (+) Can't inject different Readers/Viewers
* (-) We are limited to header files
* (-) Slower compilation times (Point of instantiation - POI)
* (-) Bigger executable size
* (-) Horrible error messages

| | |
|-|-|
|[Concepts lite](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3580.pdf) | Constrating templates |
|[Virtual concepts](https://github.com/andyprowl/virtual-concepts/blob/master/draft/Dynamic%20Generic%20Programming%20with%20Virtual%20Concepts.pdf)  | Type-erasure |
|[Static reflection](www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0194r0.pdf) | Fakes/Stubs/Mocks generation |

----

##No templates solution, please?

----

##Functional design for fun and profit? (V6)

```cpp
using fview = std::function<void(int)>;
using fread = std::function<int()>;
```

```cpp
const auto fileRead = [](std::string_view path) {
  return [=] {
    auto value = 0;
    {
      std::ifstream file{path};
      file >> value;
    }
    return value;
  };
};
```

```cpp
const auto consoleView = [](int value) {
  std::cout << value << '\n';
};
```

----

##Functional design for fun and profit? (V6)

```cpp
class App {
  fview view;
  fread read;

 public:
   App(const fview& view, const fread& read)
     : view(view), read(read)
   { }

   void run() {
     view(read());
   }
};
```

```cpp
int main() {
  App{fileRead, consoleView}.run();
}
```

----

* (+) Still does the job
* (+) We can test it in isolation (including App) but it's hard
* (+) Reader/Viewer are not tightly coupled to App
* (+) Can't inject different Readers/Viewers
* (-) We are limited to header files
* (-) Slower compilation times (Point of instantiation - POI)
* (-) Bigger executable size
* (-) Horrible error messages

----

##Let's erase the type - Type erasure - (V7)?


```cpp
BOOST_TYPE_ERASURE_MEMBER((has_read), read, 0)
BOOST_TYPE_ERASURE_MEMBER((has_show), show, 1)
```

```cpp
using Reader = mpl::vector<
  has_read<int()>
, type_erasure::copy_constructible<>
>;

using Viewer = mpl::vector<
  has_show<void(int)>
, type_erasure::copy_constructible<>
>;
```

----

##Let's erase the type - Type erasure - (V7)?

```cpp
struct FileReader {
  explicit FileReader(std::string_view path) : file{path} {
    assert(file.good()); 
  }

  int read() {
    auto value = 0;
    file >> value;
    return value;
  }

  std::ifstream file;
};
```

```cpp
struct ConsoleViewer {
  void show(int value) { std::cout << value << std::endl; }
};
```

----

##Let's erase the type - Type erasure - (V7)?

```cpp
struct App {
  type_erasure::any<Reader> reader;
  type_erasure::any<Viewer> viewer;

  App(type_erasure::any<Reader> reader,
     type_erasure::any<Viewer> viewer)
    : reader(reader), viewer(viewer)
  { }

  void run() { viewer.show(reader.read()); }
};
```

```cpp
int main() {
  FileReader reader{"input.txt"};
  ConsoleViewer viewer{};
  App{reader, viewer}.run();
}
```

----

* (+) Still does the job
* (+) We can test it in isolation (including App) but it's hard
* (+) Reader/Viewer are not tightly coupled to App
* (+) Can't inject different Readers/Viewers
* (-) We are limited to header files
* (-) Slower compilation times (Point of instantiation - POI)
* (-) Bigger executable size
* (-) Horrible error messages

> STL example: std::shared_ptr deleter

----

##Object oriented design with dynamic polymorphism (V8)

```cpp
class IReader {
public:
  virtual ~IReader() noexcept = default;
  virtual int read() = 0;
};
```

```cpp
class FileReader final : public IReader {
public:
  FileReader(std::string_view path);
  void read() override;
};
```

----

##Object oriented design with dynamic polymorphism (V8)

```cpp
class IViewer {
public:
  virtual ~IViewer() noexcept = default;
  virtual void show(int) = 0;
};
```

```cpp
class ConsoleViewer final : public IViewer {
  void show(int) override;
};
```

----

##Object oriented design with dynamic polymorphism (V8)

```cpp
class App {
  IReader& reaer;
  IViewer& viewer;

public:
  App(IReader& reader, IViewer& viewer)
    : reader(reader), viewer(viewer) {}

  void run() {
    viewer.show(reader.read());
  }
};
```

```cpp
int main() {
  auto reader = FileReader("input.txt");
  auto viewer = ConsoleViewer{};

  App{reader, viewer}.run();
}
```

----

##Object oriented design with dynamic polymorphism (V8)

![app](images/app3.png)

* (+) Still does the job
* (+) We can easily do TDD/BDD (mocking)
* (+) We can inject diff readers/writers (loosely coupled)
* (-) Performance hit due to virtual dispatch?

----

##Dynamic Polymorphism - performance
####final keyword and devirtualization

![final](images/final.png)
https://godbolt.org/g/e8olYN

----

##Manual DI - Problems

* ###Single Responsibility
  =>
    * ###A lot of classes
    =>
      * ###Wiring Mess
      =>
        * ###Hard to maintain + programers are lazy
        =>
          * ###Hacks/Workarounds

-----

##Solution

###Simplify/Remove the wiring mess (Automate the injection)
=>
### [[Boost].DI](https://github.com/boost-experimental/di)

==============================================================================

##[Boost].DI

* One header - 3k LOC - (boost/di.hpp) / generated
* Neither Boost nor STL is required
* No 'if's, 'virtual', 'exceptions' (-fno-rtti, -fno-exceptions)
* Non-intrusive (constructor parameters deduction)
* Compile-time creation guarantee (no run-time errors)
* Supported compilers (C++14)
  * [Clang-3.4+](https://travis-ci.org/boost-experimental/di), [XCode-6.1+](https://travis-ci.org/boost-experimental/di), [GCC-5.2+](https://travis-ci.org/boost-experimental/di), [MSVC-2015+](https://ci.appveyor.com/project/krzysztof-jusiak/di)

----

##[Boost].DI - API

###Injector
```cpp
template<class... TDeps> requires boundable<TDeps...>()
class injector {
public:
  explicit injector(TDeps&&...) noexcept;
  injector(injector&&) = default;
  injector& operator=(injector&&) = default;

  template<class T> requires creatable<T>()
  constexpr T create() const;
};
```

###Make injector
```cpp
template<class TConfig = di::config, class... TDeps>
  requires configurable<TConfig>() && boundable<TDeps...>()
auto make_injector(TDeps&&...) noexcept;
```

----

##[Boost].DI - Hello World

```cpp
#include <boost/di.hpp>
namespace di = boost::di;
```

```cpp
class IReader;
class IViewer;
```

```cpp
class App {
 public:
  App(const IReader&, const IViewer&); // DI handles
};                  ^       ^          // order and types
                    |       \----------------------\
                    \-----------------------\      |
int main() {                                |      |
  const auto injector = di::make_injector(  |      |
     di::bind<IReader>.to<FileReader>(), ---/      |
     di::bind<IViewer>.to<ConsoleViewer>() --------/
  );

  injector.create<std::unique_ptr<App>>().run();
}
```

----

##[Boost].DI - Performance

```sh
time $CXX -std=c++14 app.cpp # 0.092s
```

####ASM x86-64

```
push   %rbx
mov    %rdi,%rbx
mov    $0x8,%edi
callq  0x4009f0 <_Znwm@plt>
movq   $0x400e78,(%rax)
mov    %rax,(%rbx)
mov    %rbx,%rax
pop    %rbx
retq
```

####Same as

```cpp
return make_unique<App>(...);
```

----

##[Boost].DI - Benchmarks (GCC-7/Java8)

| 64 types, 1-4 ctor params, 1024 iterations | **[Boost].DI** | **Guice** | **Dagger2** |
| --------------------- | ------------ | ---------------- | ------------- |
| Compilation time    | 0.376s       |  0.570s            | 1.411s        |
| Execution time      | 0.002s       |  0.528s            | 0.157s        |

---

| 256 types, 1-4 ctor params, 1024 iterations | **[Boost].DI** | **Guice** | **Dagger2** |
| --------------------- | ------------ | ---------------- | ------------- |
| Compilation time    | 0.706s       | 0.642s             | 1.903s        |
| Execution time      | 0.002s       | 0.544s             | 0.210s        |

----

##[Boost].DI - Compile-time errors

```cpp
const auto injector = di::make_injector(
// di::bind<IViewer>.to<ConsoleViewer>(), // missing 'IViewer' binding
   di::bind<IReader>.to<FileReader>()
);
auto app = injector.create<App>();
```

####Full Compilation-Time Error Message

```cpp
error: 'create<App>' is deprecated: creatable constraint
  injector.create<App>();           not satisfied
           ^
note 'create<App>' has been explicitly marked deprecated here
  create
  ^
error: inline function 'abstract_type<IViewer>::is_not_bound::error'
 error(_ = "type is not bound, did you forget to add:
           'di::bind<interface>.to<implementation>()'?");
```

----

##Let's come back to our example (V3)

###Automatic Injection

```cpp
class Reader;
class Viewer;
```

```cpp
class App {
 Reader reader;
 Viewer viewer;

public:
  App(Reader&& reader, Viewer&& viewer)
    : reader(std::move(reader))
    , viewer(std::move(viewer))
  {}

  void run() {
    viewer.show(reader.read());
  }
};
```

----

##Automatic Injection

###Manual DI - Wiring mess
```cpp
int main() {
  Reader reader;
  Viewer viewer;
  App app{std::move(reader), std::move(viewer)};
  app.run();
}
```

###[Boost].DI
```cpp
int main() {
  di::make_injector().create<App>().run();
}
```

----

##Refactoring for free!

###Let's change App constructor
  
#####Before
```cpp
App(Reader&& reader, Viewer&& viewer)
  : reader(std::move(reader))
  , viewer(std::move(viewer))
{ }
```

#####After
```cpp
App(Viewer& viewer, std::unique_ptr<Reader> reader)
 : viewer(viewer)
 , reader(std::move(reader))
{}

```

----

##Refactoring for free!

###Manual DI - Wiring mess
```cpp
int main() {
  auto reader = std::make_unique<Reader>{};
  Viewer viewer;
  App app{viewer, std::move(reader)};
  app.run();
}
```

###[Boost].DI
```cpp
int main() {
  di::make_injector().create<App>().run(); // same as before!
}
```

----

##Implementing features by wiring

```
Scenario 2: Value from the input file is displayed on the console
 Given an 'input.txt' file with an integer value in it
   And the first command line argument equals to "ConsoleViewer"
 When the App runs
 Then the integer value from 'input.txt' should
      be shown on the terminal console
```

```
Scenario 3: Value from the input file is displayed on the QtWindow
 Given an 'input.txt' file with an integer value in it
   And the first command line argument equals to "QtViewer"
 When the App runs
 Then the integer value from 'input.txt' should
      be shown on the Qt Window
```

----

##Implementing features by wiring
###Weak vs Strong interface

```cpp
class QtViewer {
public:
  QtViewer(int width, int height); // weak interface
};
```

```cpp
QtViewer(600, 800); // Okay
QtViewer(800, 600); // Oops
```

```cpp
class QtViewer {
public:
  QtViewer(width, height); // strong types
};
```

```cpp
QtViewer(width{500}, height{800}); // Okay
QtViewer(height{500}, width{800}); // Compile error, YAY
QtViewer(500, 800);                // Compile error, YAY
```

----

##Implementing features by wiring
###Configuration
```cpp
const auto config = [](std::string_view view) {
  return di::make_injector(
     di::bind<IReader>.to<FileReader>(),
     di::bind<IViewer>.to([&](const auto& injector) {
       if (view == "QtViewer") {
          return std::make_unique<QtViewer>(width{1024}, height{768});
       } else if (view == "ConsoleViewer") {
          return std::make_unique<ConsoleViewer>();
       }
     })
  );
};
```

```cpp
int main(int argc, char** argv) {
  assert(2 == argc);
  config(argv[1]).create<App>().run();
}
```

----

##Testing

> "If you liked it then you should have put a test on it", Beyonce rule

----

##Test Driven Development (TDD) / Unit Tests

```cpp
"should show read text"_test = [] {
  constexpr auto value = 42;

  auto [sut, mocks] = make<App>(); // creates System Under Test
                                   // and mocks

  InSequence sequence;
  EXPECT_CALL(mocks<IReader>(), read()).WillOnce(Return(value));
  EXPECT_CALL(mocks<IViewer>(), show(value));

  sut.run();
};
```

----

##Behaviour Driven Development (BDD) / Integration Tests

```cpp
"given input file, when runs, then print value from file"_test = [] {
  {
      std::fstream file{"input.txt"};
      file << 42;
  }
  mocks_t mocks;
  const auto injector = di::make_injector(
    config(),
    di::bind<IViewer>.to(GMock<IViewer>(mocks))
  );

  EXPECT_CALL(mocks<IViewer>(), show(42));

  injector.create<App>().run();
};
```

----

##[Boost].DI - features

* Core
    * Automatic Injection, Bindings (Multiple Bindings, Dynamic Bindings), Scopes (Scope Deduction), Named Parameters (Annotations), Modules, Providers, Policies
* Extensions
    * Automatic Mocks jnjection, Smart Factories, Assisted Injection, Xml Injection, Dependencies Diagram Generation, Automatic Serialization

---

[Examples](http://boost-experimental.github.io/di/examples) | [Extensions](http://boost-experimental.github.io/di/extensions)

==============================================================================

##Summary

----

##Good practises are good practices for a reason!

----

##STUPID vs SOLID (Object Oriented design)

<table><tr>
 <td>
  <table>
    <tr><td><b>S</b></td><td>Singleton</td></tr>
    <tr><td><b>T</b></td><td>Tight Coupling</td></tr>
    <tr><td><b>U</b></td><td>Untestability</td></tr>
    <tr><td><b>P</b></td><td>Premature Optimization</td></tr>
    <tr><td><b>I</b></td><td>Indescriptive Naming</td></tr>
    <tr><td><b>D</b></td><td>Duplication</td></tr>
  </table>
 </td>

 <td>
  <table>
    <tr><td><b>S</b></td><td><b>Single Responsibility</b></td></tr>
    <tr><td><b>O</b></td><td>Open-close</td></tr>
    <tr><td><b>L</b></td><td>Liskov substitution</td></tr>
    <tr><td><b>I</b></td><td>Interface segregation</td></tr>
    <tr><td><b>D</b></td><td><b>Dependency injection</b></td></tr>
  </table>
 </td>

 </tr>
</table>
> "Clean Code", Unclue Bob

----

##Dependency Injection

* A powerful design pattern helping with creating:
  * Loosely coupled code
  * Easy to test code (TDD/BDD)

* [Boost].DI
  * Removes/Cleanup the wiring mess (boilerplate code)
  * Simplify refactoring (constructor parameters deduction)
  * Make testing easier (automatic mocks injection)

==============================================================================

##Questions?

| [Boost].DI |  |
| ------- | ------------- |
| Documentation | http://boost-experimental.github.io/di |
| Source Code | https://github.com/boost-experimental/di |
| Try it online! | http://boost-experimental.github.io/di/try_it |
|                | https://godbolt.org/g/dvjJFI |
<!-- .element: style="margin-left:-13%; width:125%" -->

-

[kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)


					</script>
				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({

        // Display controls in the bottom right corner
        controls: true,

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: true,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'convex', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
