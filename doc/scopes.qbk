[section Scopes]

Boost.DI scopes create and maintain dependencies life time.
If no scope will be given whilst binding deduce scope will be assumed.

Synopsis
```
    class scope_ {
        typedef mpl::int_<N> priority; // N - priority, 1=lowest, N=highest

        template<typename TExpected, typename TGiven = TExpected>
        class scope {
        public:
            template<typename... T>
            result_type create(T&&... args);

            template<typename TAction>
            void call(const TAction&);
        };
    };
```

Scopes use `wrappers` to return convertible objects.
`Wrappers` are able to convert to requested types accurately to their definition.
There are 5 basic types of wrappers.

[table
    [[Wrapper][Description]]
    [[copy][conversion to lvalue/pointer/smart_ptr]]
    [[reference][conversion to reference]]
    [[shared][conversion to smart_ptr]]
    [[universal][conversion to any type wrappers provide and to const ref/named on top of it]]
    [[value][conversion to lvalue/rvalue/pointer/smart_pointer]]
]

Implementation of custom scope requires

* Implementation of the scope
* [optional] mapping to DSL binding to easier usage (custom_scope<...>)

```
class custom_scope {
public:
    typedef boost::mpl::int_<0> priority;

    template<typename TExpected, typename TGiven>
    class scope {
    public:
        typedef scope type;
        typedef di::wrappers::shared result_type;

        template<typename... Args>
        result_type create(Args&&... args) {
            return std::make_shared<TGiven>(std::forward(args)...);
        }
    };
};

namespace di {

template<typename... T>
struct custom_scope
    : scope< ::custom_scope >::bind<T...>
{ };

} // namespace di

```


[section Deduce (Default)]

[h5 Synopsis]
```
    class deduce {
    public:
        template<typename T, typename = T>
        class scope;
    };
```

[h5 Description]

Default scope which will be converted to one of the scopes shared/unique/external accordingly to `Scope Traits`.

[table Scope Traits
    [ [Type] [Scope] ]
    [ [T&] [external] ]
    [ [T] [unique] ]
    [ [const T&] [unique] ]
    [ [T*] [unique] ]
    [ [const T*] [unique] ]
    [ [unique_ptr<T>] [unique] ]
    [ [const unique_ptr<T>&] [unique] ]
    [ [T&&] [unique] ]
    [ [const T&&] [unique] ]
    [ [shared_ptr<T>] [shared] ]
    [ [const shared_ptr<T>&] [shared] ]
    [ [weak_ptr<T>] [shared] ]
    [ [const weak_ptr<T>&] [shared] ]
    [ [named<T, TName>] [scope of T] ]
]

[h5 Example]

```
    di::deduce<implementation>()
    di::deduce<di::bind<interface, implementation>>()
    di::deduce<di::bind_int<42>>()
```

[h5 Conversions]
Refer to `Scopes Conversions` table.

[endsect]

[section External]

[h5 Synopsis]
```
    template<template<typename> class TWrapper>
    class external {
    public:
        typedef mpl::int_<1> priority;

        template<typename TExpected, typename TGiven = TExpected>
        class scope {
        public:
            template<typename... TArgs>
            TWrapper<TExpected, TGiven> create(TArgs&&...);
        };
    };
```

[h5 Description]

Scope representing external value (passed by user). The life time of the object depends on the user.
Boost.DI is not responsible of managing of the passed object, however values and strings will be copied
and managed by the library. External scope has priority before other scopes which means that if some value/type
will be binded using different scope as well then this binding won't be taken into account.

[h5 Example]

```
    di::bind<int>::to(42)
    di::bind<std::string>::to("text")
    di::bind<example>::to(make_shared<example>())
    example example_;
    di::bind<example>::to(cref(example_))
    di::bind<example>::to(ref(example_))
```

[h5 Conversions]
Refer to `Scopes Conversions` table.

[endsect]

[section Unique]

[h5 Synopsis]
```
    template<template<typename> class TWrapper = wrappers::copy>
    class unique {
    public:
        typedef mpl::int_<0> priority;

        template<typename TExpected, typename TGiven = TExpected>
        class scope {
        public:
            template<typename... TArgs>
            TWrapper<TExpected, TGiven> create(TArgs&&...);
        };
    };
```

[h5 Description]

Scope representing unique value, meaning unique value always will be passed to the constructor.
[note In case of pointers user will be responsible to take care of deleting them]

[h5 Example]

```
    unique<di::bind_int<42>>()
    unique<di::bind<interface, implementation>>()
```
[note Scope deduction has lower priority than explicit scope definition, so shared_ptr parameter might be forced to be unique]

[h5 Conversions]
Refer to `Scopes Conversions` table.

[endsect]

[section Shared]

[h5 Synopsis]
```
    template<template<typename> class TWrapper = wrappers::shared>
    class shared {
    public:
        typedef mpl::int_<0> priority;

        template<typename TExpected, typename TGiven = TExpected>
        class scope {
        public:
            template<typename... TArgs>
            TWrapper<TExpected, TGiven> create(TArgs&&...);
        };
    };
```

[h5 Description]

Scope representing shared/session value, meaning passed value will be shared between all given instances.
Boost.DI to achieve that is using smart shared pointers. This scope will be deduced in case of shared ptr.
[note Shared scope will convert between std::shared_ptr and boost::shared_ptr if required.
 Primary smart pointer might be set by `BOOST_DI_CFG_STD_SMART_PTR` and `BOOST_DI_CFG_BOOST_SMART_PTR`.
 Only primary smart pointer will be able to be converted to weak_ptr.
]
[h5 Example]

```
    shared<di::bind_int<42>>()
    shared<di::bind<interface, implementation>>()
```

[h5 Conversions]
Refer to `Scopes Conversions` table.

[endsect]

[section Session]

[h5 Synopsis]
```
    template<template<typename> class TWrapper = wrappers::shared>
    class session {
    public:
        typedef mpl::int_<0> priority;

        template<typename TExpected, typename TGiven = TExpected>
        class scope {
        public:
            template<typename... TArgs>
            TWrapper<TExpected, TGiven> create(TArgs&&...);

            void call(const session_entry&);
            void call(const session_exit&);
        };
    };
```

[h5 Description]

Scope representing shared value, meaning passed value will be shared between all given instances
and will be empty if it won't be in scope.
Scope is activated by call of `call` method with `session_entry` parameter and deactivated by call of `call` method with `session_exit` parameter;

[h5 Example]

```
    session<di::bind_int<42>>()
    session<di::bind<interface, implementation>>()
```

```
    auto injector = di::make_injector(
        shared<bind<interface, implementation>>()
    );

    assert(!injector.create<std::unique_ptr<interface>>())

    injector.call(di::scopes::session_entry());
    assert(injector.create<std::unique_ptr<interface>>())

    injector.call(di::scopes::session_exit());
    assert(!injector.create<std::unique_ptr<interface>>())
```

[h5 Conversions]
Refer to `Scopes Conversions` table.
[endsect]

[h6 Scopes Conversions]

[warning In current version of Boost.DI rvalue references aren't available for `Microsoft Visual Studio Compiler`]

[table
    [[Type][external][session][shared][unique]]
    [[T][X][X][X][X]]
    [[T*][X][X][X][X]]
    [[T&][X][X][X][X]]
    [[const T&][X][X][X][X]]
    [[T&&][X][X][X][X]]
    [[const T*][X][X][X][X]]
    [[std::shared_ptr<T>][X][X][X][X]]
    [[boost::shared_ptr<T>][X][X][X][X]]
    [[std::unique_ptr<T>][X][X][X][X]]
    [[std::auto_ptr<T>][X][X][X][X]]
    [[][][][][]]
    [[const T&][X][X][X][X]]
    [[named<T, name>][X][X][X][X]]
]

[endsect]

