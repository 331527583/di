[/
 /
 / Copyright (c) 2014 Krzysztof Jusiak (krzysztof at jusiak dot net)
 /
 / Distributed under the Boost Software License, Version 1.0.
 / (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /
 /]

[section Scopes]

[heading Description]
Scopes are responsible for creating and maintaining life time of dependencies.
If no scope will be given whilst binding __scopes_deduce__ will be assumed.
`Boost.DI` favor 6 types of scopes.

* __scopes_deduce__
* __scopes_unique__
* __scopes_shared__
* __scopes_singleton__
* __scopes_session__
* __scopes_external__

Scopes use `wrappers` to return convertible objects.
`Wrappers` are able to convert object to requested types accurately to their definition.
There are 3 basic types of wrappers.

[heading Wrapper Model]
    template<class T>
    class wrapper_model {
    public:
        template<class TValueType>
        wrapper_model(const TValueType&) noexcept;

        operator T()() const noexcept;
    };

[table Parameters
    [[Parameter][Requirement][Description][Returns][Throws]]
    [[`T`][None][Type to which __wrapper_model__ might be converted to]]
    [[`TValueType`][None][Object type to be stored by __wrapper_model__]]
    [[`wrapper_model(const TValueType&)`][None][Conversion constructor - creates __wrapper_model__ from `TValueType` type][][Does not throw]]
    [[`operator T()`][None][Converts __wrapper_model__ to `T` type][`T` instance][Does not throw]]
]

[table
    [[Wrapper][Description]]
    [[std::reference_wrapper][Conversion to reference types]]
    [[shared][Conversion to shared smart pointers]]
    [[unique][Conversion to uniuqe smart pointer and unique values]]
]

[heading Synopsis]
    class scope {
        static constexpr auto priority = false; // scope priority

        template<class TExpected, class TGiven>
        class scope {
        public:
            template<class TAction>
            void call(const TAction&);

            template<class T, class TProvider>
            auto create(const TProvider&);
        };
    };

[table Parameters
    [[Parameter][Requirement][Description][Returns][Throw]]
    [[`TExpected`][None][Interface type to be expected by constructor]]
    [[`TGiven`][None][Implementation to be created]]
    [[`TAction`][None][Action to be passed to scopes which handle it]]
    [[`T`][None][Constructor parameter type]]
    [[`TProvider`][__provider_model__][Instance provider]]
    [[`call(TAction)`][None][call appropirate `call` method on scope][None][Does not throw]]
    [[`create(TProvider)`][None][create `TGiven` object and return wrappered `TExpected` instance][None][Does not throw]]
]

[heading Header]
    #include <__di_hpp__>

[heading Namespace]
    boost::di::scopes

[heading Examples]
    struct custom_scope {
        static constexpr auto priority = false;

        template<class TExpected, class>
        struct scope {
            template<class T, class TProvider>
            auto __di_injector_create__(const TProvider& provider) {
                return shared_ptr<TExpected>{provider.get()};
            }
        };
    };

    auto injector = __di_make_injector__(
      __di_bind__<i, impl>.in(custom_scope{})
    );

    assert(injector.__di_injector_create__<shared_ptr<i>>()
           !=
           injector.__di_injector_create__<shared_ptr<i>>()
    );

[heading More Examples]
    ``__examples_custom_scope__``

[table Scope to type conversion
    [[Type]                     [unique]                [shared]    [singleton]                   [session]         [external]]
    [[T]                        [\u2714]                [-]         [-]                            [-]              [\u2714]]
    [[T&]                       [-]                     [-]         [-]                            [-]              [\u2714]]
    [[const T&]                 [\u2714 (temporary)]    [-]         [-]                            [-]              [\u2714]]
    [[T*]                       [\u2714]                [-]         [-]                            [-]              [\u2714]]
    [[const T*]                 [\u2714]                [-]         [-]                            [-]              [\u2714]]
    [[T&&]                      [\u2714]                [-]         [-]                            [-]              [-]]
    [[unique_ptr<T>]            [\u2714]                [-]         [-]                            [-]              [\u2714]]
    [[shared_ptr<T>]            [\u2714]                [\u2714]    [\u2714]                       [\u2714]         [\u2714]]
    [[weak_ptr<T>]              [-]                     [\u2714]    [\u2714]                       [\u2714]         [-]]
]

[note If expected type is `T*` or `const T*` then responsibility to delete the object is on client side. `Boost.DI` won't delete it.]

[heading See Also]

* __scopes_deduce__
* __scopes_external__
* __scopes_unique__
* __scopes_shared__
* __scopes_session__

[section:deduce deduce (default)]

[heading Description]
Default scope which will be converted to one of the scopes  __scopes_unique__ / __scopes_singleton__ accordingly to [link di.concepts.scopes.deduce.scope_traits Scope Traits] mapping.

[table Scope deduction
    [[Type][Scope]]
    [[T][__di_scopes_unique__]]
    [[T&][error - has to be bound as external]]
    [[const T&][__di_scopes_unique__ (temporary)]]
    [[T*][__di_scopes_unique__ (ownership transfer)]]
    [[const T*][__di_scopes_unique__ (ownership transfer)]]
    [[T&&][__di_scopes_unique__]]
    [[unique_ptr<T>][__di_scopes_unique__]]
    [[shared_ptr<T>][__di_scopes_singleton__]]
    [[weak_ptr<T>][__di_scopes_singleton__]]
]

[heading Synopsis]
    class deduce {
    public:
        template<class>
        class scope {
            template<class T>
            struct rebind {
                typedef class scope_traits<T>::type other;
            };
        };
    };

[table Parameters
    [[Parameter][Requirement][Description]]
    [[`T`][None][Type to be re-bound accordingly to [link di.concepts.scopes.deduce.scope_traits Scope Traits]]]
]

[heading Header]
    #include <__di_hpp__>

[heading Namespace]
    boost::di::scopes

[heading Examples]
[table
    [[Binding][Description]]
    [[```__di_bind_deduce__<__di_bind__<interface, implementation>>()```][Bind `implementation` with deduced `interface` in deduce scope]]
    [[```__di_bind_deduce__<implementation>()```][Bind `implementation` in deduce scope]]
]
    class example {
    public:
        example(shared_ptr<interface1> i1   // deduced as shared scope
              , shared_ptr<interface1> i1_  // deduced as shared scope
              , shared_ptr<interface2> i2   // deduced as unique scope
              , unique_ptr<interface3> i3   // deduced as unique scope
              , interface4& i4)             // deduced as external scope
            : i1(i1)
            , i1_(i1_)
            , i2(i2)
            , i3(i4)
            , i4(i4)
        { }

        shared_ptr<interface1> i1;
        shared_ptr<interface1> i1_;
        unique_ptr<interface2> i2;
        unique_ptr<interface> i3;
        interface& i4;
    };

    auto injector = __di_make_injector__(
        __di_bind_deduce__<implementation1>() // bind deduced interface to implementation
      , __di_bind__<interface2, implementation2>() // deduce scope by default
      , __di_bind_scope__<di::scopes::deduce>::bind<__di_bind__<interface3, implementation3>>() // long version of scope binding
      , __di_bind__<interface4>::to(ref(implementation4)) // bind to external value
    );

    auto example_ = injector.__di_injector_create__<example>();

    assert(dynamic_cast<implementation1*>(example_->i1.get());
    assert(dynamic_cast<implementation1*>(example_->i1_.get());
    assert(example_->i1 == example->i1_);
    assert(dynamic_cast<implementation2*>(example_->i2.get());
    assert(dynamic_cast<implementation3*>(example_->i3.get());
    assert(dynamic_cast<implementation4*>(example_->i4.get());

[heading More Examples]
    ``__examples_deduce_scope__``

[heading Tests]
    ``[@test/ut/scopes/deduce_ut.cpp]``

[heading See Also]

* __scopes__
* __scopes_external__
* __scopes_unique__
* __scopes_shared__
* __scopes_session__

[endsect]

[section external]

[heading Description]
Scope representing external values - passed by user. The life time of the object depends on the user.
`Boost.DI` is not responsible of managing life time of passed objects, however `values` and `strings` will be copied
and managed by the library. External scope has priority before other scopes which means that if some value/type
will be bound using different scope as well then binding using external scope will be used.

[heading Synopsis]
    template<template<class> class TWrapper>
    class external {
    public:
        typedef mpl::int_<1> priority;

        template<class TExpected>
        class scope {
        public:
            TWrapper<TExpected> create();
        };
    };

[table Parameters
    [[Parameter][Requirement][Description][Returns][Throw]]
    [[`TWrapper`][__wrapper_model__ type][Consist available type conversions]]
    [[`TExpected`][None][Type to be expected by constructor]]
    [[`create()`][None][Create wrapped type to be passed to constructor][__wrapper_model__<TExpected>][Does not throw]]
]

[table Conversions
    [[Type][external]]
    [[T][\u2714 - with lvalues]]
    [[T*][\u2714 - with lvalues]]
    [[T&][\u2714]]
    [[const T&][\u2714]]
    [[T&&][\u2714 - with lvalues]]
    [[const T*][\u2714 - with lvalues]]
    [[std::shared_ptr<T>][\u2714]]
    [[boost::shared_ptr<T>][\u2714]]
    [[std::unique_ptr<T>][\u2714 - with lvalues]]
    [[std::auto_ptr<T>][\u2714 - with lvalues]]
    [[][]]
    [[temporary const T&][\u2714 - with lvalues]]
    [[__di_named__<T, TName>][\u2714 - with lvalues]]
]

[note If expected type is `T*` or `const T*` then responsibility to delete the object is on client side. `Boost.DI` won't delete it.]

[heading Header]
    #include <__di_hpp__>

[heading Namespace]
    boost::di::scopes

[heading Examples]
[table
    [[Binding][Description]]
    [[```__di_bind__<int>::to(42)```][Bind `int` parameter to value `42`]]
    [[```__di_bind__<std::string>::to("text")```][Bind `std::string` parameter to value `text`]]
    [[```__di_bind__<example>::to(make_shared<example>())```][Bind example type to external `shared_ptr`]]
    [[```__di_bind__<example>::to(cref(example_))```][Bind example to const reference object]]
    [[```__di_bind__<example>::to(ref(example_))```][Bind example to reference object]]
    [[```__di_bind__<int>::to([]{return 42;})```][Bind `int` to lambda expression returning `42` value]]
]

    auto example_ = make_shared<example>();

    auto injector = __di_make_injector__(
        __di_bind__<int>::to(42)
      , __di_bind__<example>::to(example_)
    );

    assert(42 == injector.__di_injector_create__<int>());
    assert(example_ == injector.__di_injector_create__<shared_ptr<example>>());

[heading More Examples]
    ``__more_examples_externals__``

[heading Tests]
    ``[@test/ut/scopes/external_ut.cpp]`` | ``[@test/ut/wrappers/value_ut.cpp]`` | ``[@test/ut/wrappers/reference_ut.cpp]`` | ``[@test/ut/wrappers/shared_ut.cpp]``

[heading See Also]

* __scopes__
* __scopes_deduce__
* __scopes_unique__
* __scopes_shared__
* __scopes_session__

[endsect]

[section unique]

[heading Description]
Scope representing per request value which means unique value always will be passed to the constructor.

[heading Synopsis]
    template<template<class> class TWrapper = wrappers::copy>
    class unique {
    public:
        typedef mpl::int_<0> priority;

        template<class TExpected>
        class scope {
        public:
            TWrapper<TExpected> create(const function<TExpected*()>&);
        };
    };

[table Parameters
    [[Parameter][Requirement][Description][Returns][Throws]]
    [[`TWrapper`][__wrapper_model__ type][Consist available type conversions]]
    [[`TExpected`][None][Type to be expected by constructor]]
    [[`create(const function<TExpected*()>&)`][None][Create wrapped type to be passed to constructor][__wrapper_model__<TExpected>][Does not throw]]
]

[table Conversions
    [[Type][unique]]
    [[T][\u2714]]
    [[T*][\u2714]]
    [[T&][-]]
    [[const T&][-]]
    [[T&&][-]]
    [[const T*][\u2714]]
    [[std::shared_ptr<T>][\u2714]]
    [[boost::shared_ptr<T>][\u2714]]
    [[std::unique_ptr<T>][\u2714]]
    [[std::auto_ptr<T>][\u2714]]
    [[][]]
    [[temporary const T&][\u2714]]
    [[__di_named__<T, TName>][\u2714]]
]

[note If expected type is `T*` or `const T*` then responsibility to delete the object is on client side. `Boost.DI` won't delete it.]

[heading Header]
    #include <__di_hpp__>

[heading Namespace]
    boost::di::scopes

[heading Examples]
[table
    [[Binding][Description]]
    [[```di::unique<__di_bind__<interface, implementation>>()```][Bind `interface` to `implementation` in unique scope]]
    [[`create(const function<TExpected*()>&)`][Create wrapped type to be passed to constructor]]
]

    auto injector = __di_make_injector__(
        di::unique<
            __di_bind__<interface, implementation>
          , __di_bind_int__<42>
        >()
      , di::scope<di::scopes::unique<>>::bind<
            __di_bind_string__<mpl::string<'txt'>>
        >()
    );

    assert(42 == injector.__di_injector_create__<int>());
    assert("txt" == injector.__di_injector_create__<std::string>());
    assert(dynamic_cast<implementation*>(injector.__di_injector_create__<shared_ptr<interface>>().get()));
    assert(injector.__di_injector_create__<shared_ptr<interface>>() != injector.__di_injector_create__<shared_ptr<interface>>());

[note Scope deduction has lower priority than explicit __bindings_scope__ definition, so `shared_ptr` parameter might be forced to be unique.]

[heading Tests]
    ``[@test/ut/scopes/unique_ut.cpp]`` | ``[@test/ut/wrappers/copy_ut.cpp]``

[heading See Also]

* __scopes__
* __scopes_deduce__
* __scopes_external__
* __scopes_shared__
* __scopes_session__

[endsect]

[section shared]

[heading Description]
Scope representing shared value which will be shared between all instances.
`Boost.DI` to achieve that is using smart shared pointers. This scope will be deduced in case of `shared_ptr`.
[note Shared scope will convert between `std::shared_ptr` and `boost::shared_ptr` if required.
 Primary smart pointer might be set by `BOOST_DI_CFG_STD_SMART_PTR` and `BOOST_DI_CFG_BOOST_SMART_PTR`.
 Only primary smart pointer will be able to be converted to `weak_ptr`.
]

[heading Synopsis]
    template<template<class> class TWrapper = wrappers::shared>
    class shared {
    public:
        typedef mpl::int_<0> priority;

        template<class TExpected>
        class scope {
        public:
            TWrapper<TExpected> create(const function<TExpected*()>&);
        };
    };

[table Parameters
    [[Parameter][Requirement][Description][Returns][Throws]]
    [[`TWrapper`][__wrapper_model__ type][Consist available type conversions]]
    [[`TExpected`][None][Type to be expected by constructor]]
    [[`create(const function<TExpected*()>&)`][None][Create wrapped type to be passed to constructor][__wrapper_model__<TExpected>][Does not throw]]
]

[table Conversions
    [[Type][shared]]
    [[T][-]]
    [[T*][-]]
    [[T&][-]]
    [[const T&][-]]
    [[T&&][-]]
    [[const T*][-]]
    [[std::shared_ptr<T>][\u2714]]
    [[boost::shared_ptr<T>][\u2714]]
    [[std::unique_ptr<T>][-]]
    [[std::auto_ptr<T>][-]]
    [[][]]
    [[temporary const T&][-]]
    [[__di_named__<T, TName>][\u2714 with T=shared_ptr<T>]]
]

[heading Header]
    #include <__di_hpp__>

[heading Namespace]
    boost::di::scopes

[heading Examples]
[table
    [[Binding][Description]]
    [[```di::shared<__di_bind__<interface, implementation>>()```][Bind `interface` to `implementation` in shared scope]]
]
    auto injector = __di_make_injector__(
        di::shared<
            __di_bind__<interface, implementation>
        >()
    );

    assert(dynamic_cast<implementation*>(injector.__di_injector_create__<shared_ptr<interface>>().get()));
    assert(injector.__di_injector_create__<shared_ptr<interface>>() == injector.__di_injector_create__<shared_ptr<interface>>());

[heading Tests]
    ``[@test/ut/scopes/shared_ut.cpp]`` | ``[@test/ut/wrappers/shared_ut.cpp]``

[heading See Also]

* __scopes__
* __scopes_deduce__
* __scopes_external__
* __scopes_unique__
* __scopes_session__

[endsect]

[section singleton]
[endsect]

[section session]

[heading Description]
Scope representing session value which will be shared between all instances and will be empty if it won't be in scope.
Scope is activated by call of `call` method with `di::policies::session_entry` parameter and deactivated by call of `call` method with `di::policies::session_exit` parameter;

[heading Synopsis]
    template<template<class> class TWrapper = wrappers::shared>
    class session {
    public:
        typedef mpl::int_<0> priority;

        template<class TExpected>
        class scope {
        public:
            TWrapper<TExpected> create(const function<TExpected*()>&);
            void call(const session_entry&);
            void call(const session_exit&);
        };
    };

[table Parameters
    [[Parameter][Requirement][Description][Returns][Throw]]
    [[`TWrapper`][__wrapper_model__ type][Consist available type conversions]]
    [[`TExpected`][None][type to be expected by constructor]]
    [[`create(const function<TExpected*()>&)`][None][Create wrapped type to be passed to constructor][__wrapper_model__<TExpected>][Does not throw]]
    [[`call(const session_entry&)`][None][Trigger  scope entry][][Does not throw]]
    [[`call(const session_exit&)`][None][Trigger scope exit][][Does not throw]]
]

[table Conversions
    [[Type][session]]
    [[T][-]]
    [[T*][-]]
    [[T&][-]]
    [[const T&][-]]
    [[T&&][-]]
    [[const T*][-]]
    [[std::shared_ptr<T>][\u2714]]
    [[boost::shared_ptr<T>][\u2714]]
    [[std::unique_ptr<T>][-]]
    [[std::auto_ptr<T>][-]]
    [[][]]
    [[temporary const T&][-]]
    [[__di_named__<T, TName>][\u2714 with T=shared_ptr<T>]]
]

[heading Header]
    #include <__di_hpp__>

[heading Namespace]
    boost::di::scopes

[heading Examples]
[table
    [[Binding][Description]]
    [[```di::session<__di_bind__<interface, implementation>>()```][Bind `interface` to `implementation` in session scope]]
]

    auto injector = __di_make_injector__(
        di::session<bind<interface, implementation>>()
    );

    assert(!injector.__di_injector_create__<std::unique_ptr<interface>>())

    injector.call(di::scopes::session_entry());
    assert(injector.__di_injector_create__<std::unique_ptr<interface>>())

    injector.call(di::scopes::session_exit());
    assert(!injector.__di_injector_create__<std::unique_ptr<interface>>())

[heading Tests]
    ``[@test/ut/scopes/session_ut.cpp]`` | ``[@test/ut/wrappers/shared_ut.cpp]``

[heading See Also]

* __scopes__
* __scopes_deduce__
* __scopes_external__
* __scopes_unique__
* __scopes_session__

[endsect]

[endsect]

