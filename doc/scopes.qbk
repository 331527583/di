[/
 /
 / Copyright (c) 2014 Krzysztof Jusiak (krzysztof at jusiak dot net)
 /
 / Distributed under the Boost Software License, Version 1.0.
 / (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /
 /]

[section Scopes]

[heading Description]
Scopes are responsible for creating and maintaining life time of the dependency.
If no scope will be given whilst binding `deduce` scope will be assumed.
`Boost.DI` favor 5 types of scopes

* __scopes_deduce__
* __scopes_external__
* __scopes_unique__
* __scopes_shared__
* __scopes_session__

Scopes use `wrappers` to return convertible objects.
`Wrappers` are able to convert object to requested types accurately to their definition.
There are 5 basic types of wrappers.

[table
    [[Wrapper][Description]]
    [[copy][conversion to lvalue/pointer/smart_ptr]]
    [[reference][conversion to reference]]
    [[shared][conversion to smart_ptr]]
    [[universal][conversion to any type wrappers provide and to const ref/named on top of it]]
    [[value][conversion to lvalue/rvalue/pointer/smart_pointer]]
]

[heading Synopsis]
```
    class unspecified {
        typedef mpl::int_<N> priority; // N - priority, 1=lowest, N=highest

        template<typename TExpected>
        class scope {
        public:
            result_type create(); // mutually exclusive with create(const function<TExpected*>()>*), used when object is not required - external scope
            result_type create(const function<TExpected*()>&); // mutually exclusive with create()

            template<typename TAction>
            void call(const TAction&);
        };
    };
```

[table Parameters
    [[Parameter][Requirement][Description]]
    [[`TExpected`][None][Object to be expected by constructor]]
    [[`N`][Integer number value][Priority of the scope, 1=lowest, N=highest]]
    [[`TAction`][None][Action to be passed to scopes which handle it]]
]

[heading Header]
    #include <boost/di.hpp>

[heading Namespace]
    boost::di::scopes

[heading Examples]
    class custom_scope {
    public:
        typedef boost::mpl::int_<0> priority;

        template<typename TExpected>
        class scope {
        public:
            typedef scope type;
            typedef di::wrappers::shared<TExpected> result_type;

            result_type create(const function<TExpected*()>& f) {
                return std::make_shared<TGiven>(f());
            }
        };
    };

    namespace di {

    template<typename... T>
    struct custom_scope
        : scope< ::custom_scope >::bind<T...>
    { };

    } // namespace di

    auto injector = di::make_injector(
        custom_scope<
            di::bind<interface, implementation>
        >()
      , scope<custom_scope>::bind<
            di::bind<interface1, implementation1>
        >()
    );

    assert(dynamic_cast<implementation1*>(injector.create<shared_ptr<interface1>>().get()));
    assert(dynamic_cast<implementation2*>(injector.create<shared_ptr<interface2>>().get()));
    assert(injector.create<shared_ptr<interface1>>() != injector.create<shared_ptr<interface2>>());

[heading More Examples]
    ``__examples_custom_scope__``

[heading Scopes Conversions]

[warning Current version of `Boost.DI` doesn't support `rvalue references` with `Microsoft Visual Studio Compiler`.]

[table
    [[Type][external][unique][shared][session]]
    [[T][X][X][X][X]]
    [[T*][X][X][X][X]]
    [[T&][X][X][X][X]]
    [[const T&][X][X][X][X]]
    [[T&&][X][X][X][X]]
    [[const T*][X][X][X][X]]
    [[std::shared_ptr<T>][X][X][X][X]]
    [[boost::shared_ptr<T>][X][X][X][X]]
    [[std::unique_ptr<T>][X][X][X][X]]
    [[std::auto_ptr<T>][X][X][X][X]]
    [[][][][][]]
    [[const T&][X][X][X][X]]
    [[named<T, name>][X][X][X][X]]
]

[heading Tests]
    ``[@test/ut/wrappers/universal_ut.cpp]``

[heading See Also]

* __scopes_deduce__
* __scopes_external__
* __scopes_unique__
* __scopes_shared__
* __scopes_session__

[section:deduce deduce (default)]

[heading Description]
Default scope which will be converted to one of the scopes `shared/unique/external` accordingly to `Scope Traits` transformation.

[table Scope Traits
    [ [Type] [Scope] ]
    [ [T&] [external] ]
    [ [T] [unique] ]
    [ [const T&] [unique] ]
    [ [T*] [unique] ]
    [ [const T*] [unique] ]
    [ [unique_ptr<T>] [unique] ]
    [ [const unique_ptr<T>&] [unique] ]
    [ [T&&] [unique] ]
    [ [const T&&] [unique] ]
    [ [shared_ptr<T>] [shared] ]
    [ [const shared_ptr<T>&] [shared] ]
    [ [weak_ptr<T>] [shared] ]
    [ [const weak_ptr<T>&] [shared] ]
    [ [named<T, TName>] [scope of T] ]
]

[heading Synopsis]
    class deduce {
    public:
        template<typename>
        class scope {
            template<typename T>
            struct rebind {
                typedef typename scope_traits<T>::type other;
            };
        };
    };

[heading Header]
    #include <boost/di.hpp>

[heading Namespace]
    boost::di::scopes

[heading Examples]
    class example {
    public:
        example(shared_ptr<interface1> i1   // deduced as shared scope
              , shared_ptr<interface1> i1_  // deduced as shared scope
              , shared_ptr<interface2> i2   // deduce as unique scope
              , unique_ptr<interface3> i3   // deduce as unique scope
              , const interface4& i4)       // deduce as external scope
            : i1(i1)
            , i1_(i1_)
            , i2(i2)
            , i3(i4)
            , i4(i4)
        { }

        shared_ptr<interface1> i1;
        shared_ptr<interface1> i1_;
        unique_ptr<interface2> i2;
        unique_ptr<interface> i3;
        const interface& i4;
    };

    auto injector = di::make_injector(
        di::deduce<implementation1>() // bind deduced interface to implementation
      , di::bind<interface2, implementation2>() // deduce scope by default
      , di::scope<di::scopes::deduce>::bind<di::bind<interface3, implementation3>>() // long version of scope binding
      , di::bind<interface4>::to(cref(implementation4)) // bind to external value
    );

    auto example_ = injector.create<example>();

    assert(dynamic_cast<implementation1*>(example_->i1.get());
    assert(dynamic_cast<implementation1*>(example_->i1_.get());
    assert(example_->i1 == example->i1_);
    assert(dynamic_cast<implementation2*>(example_->i2.get());
    assert(dynamic_cast<implementation3*>(example_->i3.get());
    assert(dynamic_cast<implementation4*>(example_->i4.get());

[heading More Examples]
    ``__examples_deduce_scope__``

[heading Tests]
    ``[@test/ut/scopes/deduce_ut.cpp]``

[heading See Also]

* __scopes__
* __scopes_external__
* __scopes_unique__
* __scopes_shared__
* __scopes_session__

[endsect]

[section external]

[heading Description]
Scope representing external value (passed by user). The life time of the object depends on the user.
`Boost.DI` is not responsible of managing life time of passed object, however values and strings will be copied
and managed by the library. External scope has priority before other scopes which means that if some value/type
will be binded using different scope as well then this binding won't be taken into account.

[heading Synopsis]
    template<template<typename> class TWrapper>
    class external {
    public:
        typedef mpl::int_<1> priority;

        template<typename TExpected>
        class scope {
        public:
            TWrapper<TExpected> create();
        };
    };

[table Parameters
    [[Parameter][Requirement][Description]]
    [[`TWrapper`][Wrapper Model type][consist available type conversions]]
    [[`TExpected`][None][type to be expected by constructor]]
]

[table Conversions
    [[Type][external]]
    [[T][X]]
    [[T*][X]]
    [[T&][X]]
    [[const T&][X]]
    [[T&&][X]]
    [[const T*][X]]
    [[std::shared_ptr<T>][X]]
    [[boost::shared_ptr<T>][X]]
    [[std::unique_ptr<T>][X]]
    [[std::auto_ptr<T>][X]]
    [[][]]
    [[const T&][X]]
    [[named<T, name>][X]]
]

[heading Header]
    #include <boost/di.hpp>

[heading Namespace]
    boost::di::scopes

[heading Examples]
[table
    [[Binding][Description]]
    [[```di::bind<int>::to(42)```][bind `int` parameter to value `42`]]
    [[```di::bind<std::string>::to("text")```][bind `std::string` parameter to value `text`]]
    [[```di::bind<example>::to(make_shared<example>())```][bind example type to external `shared_ptr`]]
    [[```di::bind<example>::to(cref(example_))```][bind example to const reference object]]
    [[```di::bind<example>::to(ref(example_))```][bind example to reference object]]
    [[```di::bind<int>::to([]{return 42;})```][bind `int` to lambda expression returning `42` value]]
]

    auto example_ = make_shared<example>();

    auto injector = di::make_injector(
        di::bind<int>::to(42)
      , di::bind<example>::to(example_)
    );

    assert(42 == injector.create<int>());
    assert(example_ == injector.create<shared_ptr<example>>());
    
[heading Tests]
    ``[@test/ut/scopes/external_ut.cpp]`` | ``[@test/ut/wrappers/value_ut.cpp]`` | ``[@test/ut/wrappers/reference_ut.cpp]`` | ``[@test/ut/wrappers/shared_ut.cpp]``

[heading See Also]

* __scopes__
* __scopes_deduce__
* __scopes_unique__
* __scopes_shared__
* __scopes_session__

[endsect]

[section unique]

[h5 Synopsis]
```
    template<template<typename> class TWrapper = wrappers::copy>
    class unique {
    public:
        typedef mpl::int_<0> priority;

        template<typename TExpected, typename TGiven = TExpected>
        class scope {
        public:
            template<typename... TArgs>
            TWrapper<TExpected, TGiven> create(TArgs&&...);
        };
    };
```

[h5 Description]

Scope representing unique value, meaning unique value always will be passed to the constructor.
[note In case of pointers user will be responsible to take care of deleting them]

[h5 Example]

```
    unique<di::bind_int<42>>()
    unique<di::bind<interface, implementation>>()
```
[note Scope deduction has lower priority than explicit scope definition, so shared_ptr parameter might be forced to be unique]

[h5 Conversions]
Refer to `Scopes Conversions` table.

[table
    [[Tests: [@test/ut/scopes/unique_ut.cpp] | [@test/ut/wrappers/copy_ut.cpp]]]
]
[endsect]

[section shared]

[h5 Synopsis]
```
    template<template<typename> class TWrapper = wrappers::shared>
    class shared {
    public:
        typedef mpl::int_<0> priority;

        template<typename TExpected, typename TGiven = TExpected>
        class scope {
        public:
            template<typename... TArgs>
            TWrapper<TExpected, TGiven> create(TArgs&&...);
        };
    };
```

[h5 Description]

Scope representing shared/session value, meaning passed value will be shared between all given instances.
Boost.DI to achieve that is using smart shared pointers. This scope will be deduced in case of shared ptr.
[note Shared scope will convert between std::shared_ptr and boost::shared_ptr if required.
 Primary smart pointer might be set by `BOOST_DI_CFG_STD_SMART_PTR` and `BOOST_DI_CFG_BOOST_SMART_PTR`.
 Only primary smart pointer will be able to be converted to weak_ptr.
]
[h5 Example]

```
    shared<di::bind_int<42>>()
    shared<di::bind<interface, implementation>>()
```

[h5 Conversions]
Refer to `Scopes Conversions` table.

[table
    [[Tests: [@test/ut/scopes/shared_ut.cpp] | [@test/ut/wrappers/shared_ut.cpp]]]
]
[endsect]

[section session]

[h5 Synopsis]
```
    template<template<typename> class TWrapper = wrappers::shared>
    class session {
    public:
        typedef mpl::int_<0> priority;

        template<typename TExpected, typename TGiven = TExpected>
        class scope {
        public:
            template<typename... TArgs>
            TWrapper<TExpected, TGiven> create(TArgs&&...);

            void call(const session_entry&);
            void call(const session_exit&);
        };
    };
```

[h5 Description]

Scope representing shared value, meaning passed value will be shared between all given instances
and will be empty if it won't be in scope.
Scope is activated by call of `call` method with `session_entry` parameter and deactivated by call of `call` method with `session_exit` parameter;

[h5 Example]

```
    session<di::bind_int<42>>()
    session<di::bind<interface, implementation>>()
```

```
    auto injector = di::make_injector(
        shared<bind<interface, implementation>>()
    );

    assert(!injector.create<std::unique_ptr<interface>>())

    injector.call(di::scopes::session_entry());
    assert(injector.create<std::unique_ptr<interface>>())

    injector.call(di::scopes::session_exit());
    assert(!injector.create<std::unique_ptr<interface>>())
```

[h5 Conversions]
Refer to `Scopes Conversions` table.

[table
    [[Tests: [@test/ut/scopes/session_ut.cpp] | [@test/ut/wrappers/shared_ut.cpp]]]
]
[endsect]

[endsect]

