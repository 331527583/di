[section Scopes]

Boost.DI scopes create and maintain dependencies life time.
If no scope will be given whilst binding deduce scope will be assumed.

Synopsis
```
    class scope_ {
        typedef mpl::int_<N> priority; // N - priority, 1=lowest, N=highest

        template<typename TExpected, typename TGiven = TExpected>
        class scope {
        public:
            template<typename... T>
            result_type create(T&&... args);
        };
    };
```

Scopes use `wrappers` to return convertible objects.
`Wrappers` are able to convert to requested types accurately to their definition.
There are 5 basic types of wrappers.

[table
    [[Wrapper][Description]]
    [[copy][conversion to lvalue/pointer/smart_ptr]]
    [[reference][conversion to reference]]
    [[shared][conversion to smart_ptr]]
    [[universal][conversion to any type wrappers provide and to const ref/named on top of it]]
    [[value][conversion to lvalue/rvalue/pointer/smart_pointer]]
]

[section Deduce (Default)]

[h5 Synopsis]
```
    class deduce {
    public:
        template<typename T, typename = T>
        class scope;
    };
```

[h5 Description]

Default scope which will be converted to one of the scopes shared/unique/external accordingly to `Scope Traits`.

[h5 Example]

```
    di::deduce<implementation>()
    di::deduce<di::bind<interface, implementation>>()
    di::deduce<di::bind_int<42>>()
```

[h5 Conversions]
Refer to `Scopes Conversions` table.

[endsect]

[section External]

[h5 Synopsis]
```
    template<template<typename> class TWrapper>
    class external {
    public:
        typedef mpl::int_<1> priority;

        template<typename TExpected, typename TGiven = TExpected>
        class scope {
        public:
            template<typename... TArgs>
            TWrapper<TExpected, TGiven> create(TArgs&&...);
        };
    };
```

[h5 Description]

Scope representing external value (passed by user). The life time of the object depends on the user.
Boost.DI is not responsible of managing of the passed object, however values and strings will be copied
and managed by the library. External scope has priority before other scopes which means that if some value/type
will be binded using different scope as well then this binding won't be taken into account.

[h5 Example]

```
    di::bind<int>::to(42)
    di::bind<std::string>::to("text")
    di::bind<example>::to(make_shared<example>())
    example example_;
    di::bind<example>::to(cref(example_))
    di::bind<example>::to(ref(example_))
```

[h5 Conversions]
Refer to `Scopes Conversions` table.

[endsect]

[section Unique]

[h5 Synopsis]
```
    template<template<typename> class TWrapper = wrappers::copy>
    class unique {
    public:
        typedef mpl::int_<0> priority;

        template<typename TExpected, typename TGiven = TExpected>
        class scope {
        public:
            template<typename... TArgs>
            TWrapper<TExpected, TGiven> create(TArgs&&...);
        };
    };
```

[h5 Description]

Scope representing unique value, meaning unique value always will be passed to the constructor.
[note In case of pointers user will be responsible to take care of deleting them]

[h5 Example]

```
    unique<di::bind_int<42>>()
    unique<di::bind<interface, implementation>>()
```
[note Scope deduction has lower priority than explicit scope definition, so shared_ptr parameter might be forced to be unique]

[h5 Conversions]
Refer to `Scopes Conversions` table.

[endsect]

[section Shared]
[endsect]

[section Session]
[endsect]

[section Custom]
[endsect]

[table Scopes Conversions
    [[Type][external][session][shared][unique]]
    [[T][X][X][X][X]]
    [[T*][X][X][X][X]]
    [[T&][X][X][X][X]]
    [[const T&][X][X][X][X]]
    [[T&&][X][X][X][X]]
    [[const T*][X][X][X][X]]
    [[std::shared_ptr<T>][X][X][X][X]]
    [[boost::shared_ptr<T>][X][X][X][X]]
    [[std::unique_ptr<T>][X][X][X][X]]
    [[std::auto_ptr<T>][X][X][X][X]]
    [[][][][][]]
    [[const T&][X][X][X][X]]
    [[named<T, name>][X][X][X][X]]
]

[endsect]

