[/
 /
 / Copyright (c) 2014 Krzysztof Jusiak (krzysztof at jusiak dot net)
 /
 / Distributed under the Boost Software License, Version 1.0.
 / (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /
 /]

[section Scopes]

[heading Description]
Scopes are responsible for creating and maintaining life time of dependencies.
If no scope will be given whilst binding __scopes_deduce__ will be assumed.
`Boost.DI` favor 6 types of scopes.

* __scopes_deduce__ (default)
* __scopes_unique__
* __scopes_shared__
* __scopes_singleton__
* __scopes_session__
* __scopes_external__

Scopes use `wrappers` to return convertible objects.
`Wrappers` are able to convert object to requested types accurately to their definition.
There are 3 basic types of wrappers.

[heading Wrapper Model]
    template<class T>
    class wrapper_model {
    public:
        template<class TValueType>
        wrapper_model(const TValueType&) noexcept;

        operator T()() const noexcept;
    };

[table Parameters
    [[Parameter][Requirement][Description][Returns][Throws]]
    [[`T`][None][Type to which __wrapper_model__ might be converted to]]
    [[`TValueType`][None][Object type to be stored by __wrapper_model__]]
    [[`wrapper_model(const TValueType&)`][None][Conversion constructor - creates __wrapper_model__ from `TValueType` type][][Does not throw]]
    [[`operator T()`][None][Converts __wrapper_model__ to `T` type][`T` instance][Does not throw]]
]

[table
    [[Wrapper][Description]]
    [[std::reference_wrapper][Conversion to reference types]]
    [[shared][Conversion to shared smart pointers]]
    [[unique][Conversion to uniuqe smart pointer and unique values]]
]

[heading Synopsis]
    class scope {
        static constexpr auto priority = false; // scope priority

        template<class TExpected, class TGiven>
        class scope {
        public:
            template<class TAction>
            void call(const TAction&);

            template<class T, class TProvider>
            auto create(const TProvider&);
        };
    };

[table Parameters
    [[Parameter][Requirement][Description][Returns][Throw]]
    [[`TExpected`][None][Interface type to be expected by constructor]]
    [[`TGiven`][None][Implementation to be created]]
    [[`TAction`][None][Action to be passed to scopes which handle it]]
    [[`T`][None][Constructor parameter type]]
    [[`TProvider`][__provider_model__][Instance provider]]
    [[`call(TAction)`][None][call appropirate `call` method on scope][None][Does not throw]]
    [[`create(TProvider)`][None][create `TGiven` object and return wrappered `TExpected` instance][None][Does not throw]]
]

[table Scope to type conversion
    [[Type]                     [unique]                [shared]    [singleton]                   [session]         [external]]
    [[T]                        [\u2714]                [-]         [-]                            [-]              [\u2714]]
    [[T&]                       [-]                     [-]         [-]                            [-]              [\u2714]]
    [[const T&]                 [\u2714 (temporary)]    [-]         [-]                            [-]              [\u2714]]
    [[T*]                       [\u2714]                [-]         [-]                            [-]              [\u2714]]
    [[const T*]                 [\u2714]                [-]         [-]                            [-]              [\u2714]]
    [[T&&]                      [\u2714]                [-]         [-]                            [-]              [-]]
    [[unique_ptr<T>]            [\u2714]                [-]         [-]                            [-]              [\u2714]]
    [[shared_ptr<T>]            [\u2714]                [\u2714]    [\u2714]                       [\u2714]         [\u2714]]
    [[weak_ptr<T>]              [-]                     [\u2714]    [\u2714]                       [\u2714]         [-]]
]

[note If expected type is `T*` or `const T*` then responsibility to delete the object is on client side. `Boost.DI` won't delete it.]

[heading Header]
    #include <__di_hpp__>

[heading Namespace]
    boost::di::scopes

[heading Examples]
    struct custom_scope {
        static constexpr auto priority = false;

        template<class TExpected, class>
        class scope {
        public:
            template<class T, class TProvider>
            auto create(const TProvider& provider) {
                return shared_ptr<TExpected>{provider.get()};
            }
        };
    };

    auto injector = __di_make_injector__(
      __di_bind__<i, impl>.in(custom_scope{})
    );

    assert(injector.__di_injector_create__<shared_ptr<i>>()
           !=
           injector.__di_injector_create__<shared_ptr<i>>()
    );

[heading More Examples]
    ``__examples_custom_scope__``

[heading See Also]

* __scopes_deduce__
* __scopes_external__
* __scopes_unique__
* __scopes_shared__
* __scopes_singleton__
* __scopes_session__

[section:deduce deduce (default)]

[heading Description]
Default scope which will be converted to one of the scopes  __scopes_unique__ / __scopes_singleton__ accordingly to [link di.concepts.scopes.deduce Scope Traits] mapping.

[table Scope deduction
    [[Type][Scope]]
    [[T][__di_scopes_unique__]]
    [[T&][error - has to be bound as external]]
    [[const T&][__di_scopes_unique__ (temporary)]]
    [[T*][__di_scopes_unique__ (ownership transfer)]]
    [[const T*][__di_scopes_unique__ (ownership transfer)]]
    [[T&&][__di_scopes_unique__]]
    [[unique_ptr<T>][__di_scopes_unique__]]
    [[shared_ptr<T>][__di_scopes_singleton__]]
    [[weak_ptr<T>][__di_scopes_singleton__]]
]

[heading Synopsis]
    class deduce {
    public:
        static constexpr auto priority = false;

        template<class TExpected, class TGiven>
        class scope {
        public:
            template<class T, class TProvider>
            auto create(const TProvider&);
    };

[table Parameters
    [[Parameter][Requirement][Description][Returns][Throw]]
    [[`TExpected`][None][Interface type to be expected by constructor]]
    [[`TGiven`][None][Implementation to be created]]
    [[`T`][None][Constructor parameter type]]
    [[`TProvider`][__provider_model__][Instance provider]]
    [[`create(TProvider)`][None][create `TGiven` object and return wrappered `TExpected` instance][None][Does not throw]]
]

[heading Header]
    #include <__di_hpp__>

[heading Namespace]
    boost::di::scopes

[heading Examples]
[table
    [
        [
            ```
            struct c {
                shared_ptr<i1> sp; /*singleton*/
                unique_ptr<i2> up; /*unique*/
                int& i; /*external*/
                double d; /*unique*/
            };

            auto i = 42;

            auto injector = __di_make_injector__(
                __di_bind__<i1, impl1>
              , __di_bind__<i2, impl2>
              , __di_bind__<int>.to(ref(i))
              , __di_bind__<double>.to(87.0)
            );
            ```
        ]
        [
            ```
            auto object1 = injector.__di_injector_create__<c>();
            auto object2 = injector.__di_injector_create__<c>();
            assert(object1.sp == object2.sp);
            assert(object1.up != object2.up);
            assert(42 == object1.i);
            assert(&i == object1.i;
            assert(42 == object2.i);
            assert(&i == object2.i);
            assert(87.0 == object1.d);
            assert(87.0 == object2.d);
            ```
        ]
    ]
]

[note Deduce scope has lower priority than explicit __bindings_scope__ definition, so `shared_ptr` parameter might be forced to be unique.]

[heading More Examples]
    ``__examples_deduce_scope__``

[heading See Also]

* __scopes__
* __scopes_unique__
* __scopes_shared__
* __scopes_singleton__
* __scopes_session__
* __scopes_external__

[endsect]

[section unique]

[heading Description]
Scope representing unique value.

[heading Synopsis]
    class unique {
    public:
        static constexpr auto priority = false;

        template<class TExpected, class TGiven>
        class scope {
        public:
            template<class T, class TProvider>
            auto create(const TProvider&);
    };

[table Parameters
    [[Parameter][Requirement][Description][Returns][Throw]]
    [[`TExpected`][None][Interface type to be expected by constructor]]
    [[`TGiven`][None][Implementation to be created]]
    [[`T`][None][Constructor parameter type]]
    [[`TProvider`][__provider_model__][Instance provider]]
    [[`create(TProvider)`][None][create `TGiven` object and return wrappered `TExpected` instance][None][Does not throw]]
]

[heading Header]
    #include <__di_hpp__>

[heading Namespace]
    boost::di::scopes

[table Conversions
    [[Type]                     [unique]]
    [[T]                        [\u2714]]
    [[T&]                       [-]]
    [[const T&]                 [\u2714 (temporary)]]
    [[T*]                       [\u2714]]
    [[const T*]                 [\u2714]]
    [[T&&]                      [\u2714]]
    [[unique_ptr<T>]            [\u2714]]
    [[shared_ptr<T>]            [\u2714]]
    [[weak_ptr<T>]              [-]]
]

[note If expected type is `T*` or `const T*` then responsibility to delete the object is on client side. `Boost.DI` won't delete it.]

[heading Examples]
[table
    [
        [
            ```
            auto injector = __di_make_injector__(
                __di_bind__<i1, impl1>.in(__di_scopes_unique__)
            );
            ```
        ]
        [
            ```
            assert(injector.__di_injector_create__<shared_ptr<i1>>()
                   !=
                   injector.__di_injector_create__<shared_ptr<i1>>()
            );
            ```
        ]
    ]
]

[heading See Also]

* __scopes__
* __scopes_deduce__
* __scopes_shared__
* __scopes_singleton__
* __scopes_session__
* __scopes_external__

[endsect]

[section shared]

[heading Description]
Scope representing shared value between all instances within current thread.
[note Shared scope will convert between `std::shared_ptr` and `boost::shared_ptr` if required.]

[heading Synopsis]
    class shared {
    public:
        static constexpr auto priority = false;

        template<class TExpected, class TGiven>
        class scope {
        public:
            template<class T, class TProvider>
            auto create(const TProvider&);
    };

[table Parameters
    [[Parameter][Requirement][Description][Returns][Throw]]
    [[`TExpected`][None][Interface type to be expected by constructor]]
    [[`TGiven`][None][Implementation to be created]]
    [[`T`][None][Constructor parameter type]]
    [[`TProvider`][__provider_model__][Instance provider]]
    [[`create(TProvider)`][None][create `TGiven` object and return wrappered `TExpected` instance][None][Does not throw]]
]

[heading Header]
    #include <__di_hpp__>

[heading Namespace]
    boost::di::scopes

[table Conversions
    [[Type]                     [shared]]
    [[T]                        [-]]
    [[T&]                       [-]]
    [[const T&]                 [-]]
    [[T*]                       [-]]
    [[const T*]                 [-]]
    [[T&&]                      [-]]
    [[unique_ptr<T>]            [-]]
    [[shared_ptr<T>]            [\u2714]]
    [[weak_ptr<T>]              [\u2714]]
]

[heading Examples]
[table
    [
        [
            ```
            auto injector = __di_make_injector__(
                __di_bind__<i1, impl1>.in(__di_scopes_shared__)
            );

            ```
        ]
        [
            ```
            assert(injector.__di_injector_create__<shared_ptr<i1>>()
                   ==
                   injector.__di_injector_create__<shared_ptr<i1>>()
            );
            ```
        ]
    ]
]

[heading See Also]

* __scopes__
* __scopes_deduce__
* __scopes_unique__
* __scopes_singleton__
* __scopes_session__
* __scopes_external__

[endsect]

[section singleton]

[heading Description]
Scope representing shared value between all instances and between threads.
Singleton scope will be deduced in case of `shared_ptr` or `weak_ptr`.
[note Singleton scope will convert between `std::shared_ptr` and `boost::shared_ptr` if required.]

[heading Synopsis]
    class singleton {
    public:
        static constexpr auto priority = false;

        template<class TExpected, class TGiven>
        class scope {
        public:
            template<class T, class TProvider>
            auto create(const TProvider&);
    };

[table Parameters
    [[Parameter][Requirement][Description][Returns][Throw]]
    [[`TExpected`][None][Interface type to be expected by constructor]]
    [[`TGiven`][None][Implementation to be created]]
    [[`T`][None][Constructor parameter type]]
    [[`TProvider`][__provider_model__][Instance provider]]
    [[`create(TProvider)`][None][create `TGiven` object and return wrappered `TExpected` instance][None][Does not throw]]
]

[heading Header]
    #include <__di_hpp__>

[heading Namespace]
    boost::di::scopes

[table Conversions
    [[Type]                     [singleton]]
    [[T]                        [-]]
    [[T&]                       [-]]
    [[const T&]                 [-]]
    [[T*]                       [-]]
    [[const T*]                 [-]]
    [[T&&]                      [-]]
    [[unique_ptr<T>]            [-]]
    [[shared_ptr<T>]            [\u2714]]
    [[weak_ptr<T>]              [\u2714]]
]

[heading Examples]
[table
    [
        [
            ```
            auto injector = __di_make_injector__(
                __di_bind__<i1, impl1>.in(__di_scopes_shared__)
            );

            ```
        ]
        [
            ```
            assert(injector.__di_injector_create__<shared_ptr<i1>>() // thread 1
                   ==
                   injector.__di_injector_create__<shared_ptr<i1>>() // thread 2
            );
            ```
        ]
    ]
]

[heading See Also]

* __scopes__
* __scopes_deduce__
* __scopes_unique__
* __scopes_shared__
* __scopes_session__
* __scopes_external__

[endsect]

[section session]

[heading Description]
Scope representing session value shared between all instances when within session and empty value otherwise.
Scope is activated by call of `call` method with `session_entry` with given `name` parameter and deactivated
by call of `call` method with `session_exit` with given `name` parameter;

[heading Synopsis]
    template<class = no_name>
    class session_entry { };

    template<class = no_name>
    class session_exit { };

    template<class TName = no_name>
    class session {
    public:
        static constexpr auto priority = false;

        template<class TExpected, class TGiven>
        class scope {
        public:
            template<class T, class TProvider>
            auto create(const TProvider&);

            void call(const session_entry<TName>&) noexcept
            void call(const session_exit<TName>&) noexcept;
    };

[table Parameters
    [[Parameter][Requirement][Description][Returns][Throw]]
    [[`TExpected`][None][Interface type to be expected by constructor]]
    [[`TGiven`][None][Implementation to be created]]
    [[`T`][None][Constructor parameter type]]
    [[`TName`][None][Named object]]
    [[`TProvider`][__provider_model__][Instance provider]]
    [[`create(TProvider)`][None][create `TGiven` object and return wrappered `TExpected` instance][None][Does not throw]]
    [[`call(const session_entry&)`][None][Trigger  scope entry][][Does not throw]]
    [[`call(const session_exit&)`][None][Trigger scope exit][][Does not throw]]
]

[heading Header]
    #include <__di_hpp__>

[heading Namespace]
    boost::di::scopes

[table Conversions
    [[Type]                     [session]]
    [[T]                        [-]]
    [[T&]                       [-]]
    [[const T&]                 [-]]
    [[T*]                       [-]]
    [[const T*]                 [-]]
    [[T&&]                      [-]]
    [[unique_ptr<T>]            [-]]
    [[shared_ptr<T>]            [\u2714]]
    [[weak_ptr<T>]              [\u2714]]
]

[heading Examples]
[table
    [
        [
            ```
            auto my_session = []{};

            auto injector = __di_make_injector__(
                __di_bind__<i1, impl1>.in(
                    __di_scopes_session__(my_mession)
                )
            );
            ```
        ]
        [
            ```
            assert(nullptr == injector.__di_injector_create__<shared_ptr<i1>>());
            injector.call(di::session_entry(my_session);
            assert(injector.__di_injector_create__<shared_ptr<i1>>()
                   ==
                   injector.__di_injector_create__<shared_ptr<i1>>()
            );
            injector.call(di::session_exit(my_session);
            assert(nullptr == injector.__di_injector_create__<shared_ptr<i1>>());
            ```
        ]
    ]
]

[heading See Also]

* __scopes__
* __scopes_deduce__
* __scopes_unique__
* __scopes_shared__
* __scopes_singleton__
* __scopes_external__

[endsect]

[section external]

[heading Description]
Scope representing external values - passed by user. The life time of the object depends on the user.
`Boost.DI` is not responsible of managing life time of passed objects, however `values` and `strings` will be copied
and managed by the library. External scope has priority before other scopes which means that if some value/type
will be bound using different scope as well then binding using external scope will be proffered.

[heading Synopsis]
    class external {
    public:
        static constexpr auto priority = true;

        template<class TExpected, class TGiven>
        class scope {
        public:
            template<class T, class TProvider>
            auto create(const TProvider&);
    };

[table Parameters
    [[Parameter][Requirement][Description][Returns][Throw]]
    [[`TExpected`][None][Interface type to be expected by constructor]]
    [[`TGiven`][None][Implementation to be created]]
    [[`T`][None][Constructor parameter type]]
    [[`TProvider`][__provider_model__][Instance provider]]
    [[`create(TProvider)`][None][create `TGiven` object and return wrappered `TExpected` instance][None][Does not throw]]
]

[heading Header]
    #include <__di_hpp__>

[heading Namespace]
    boost::di::scopes

[table Conversions
    [[Type]                     [external]]
    [[T]                        [\u2714]]
    [[T&]                       [\u2714]]
    [[const T&]                 [\u2714]]
    [[T*]                       [\u2714]]
    [[const T*]                 [\u2714]]
    [[T&&]                      [-]]
    [[unique_ptr<T>]            [\u2714]]
    [[shared_ptr<T>]            [\u2714]]
    [[weak_ptr<T>]              [-]]
]

[note If expected type is `T*` or `const T*` then responsibility to delete the object is on client side. `Boost.DI` won't delete it.]

[heading Examples]
[table
    [
        [
            ```
            auto l = 42l;
            auto b = false;

            auto injector = __di_make_injector__(
               __di_bind__<int, int_<41>>
             , __di_bind__<int>.to(42)
             , __di_bind__<i1>.to(make_shared<impl>());
             , __di_bind__<long>.to(ref(l));
             , __di_bind__<short>.to([]{return 87;})
             , __di_bind__<i2>.to(
                 [&](const auto& injector) {
                    if (b) {
                        return injector.template
                            __di_injector_create__<impl2>();
                    }
                    return nullptr;
                 }
            );
            ```
        ]
        [
            ```
            assert(42 == injector.__di_injector_create__<int>()); // external has priority
            assert(injector.__di_injector_create__<shared_ptr<i1>>()
                   ==
                   injector.__di_injector_create__<shared_ptr<i1>>()
            );
            assert(l == injector.__di_injector_create__<long&>());
            assert(&l == &injector.__di_injector_create__<long&>());
            assert(87 == injector.__di_injector_create__<short>());
            {
            auto object = injector.__di_injector_create__<shared_ptr<i2>>();
            assert(nullptr == object);
            }
            {
            b = true;
            auto object = injector.__di_injector_create__<shared_ptr<i2>>();
            assert(dynamic_cast<impl2*>(object.get()));
            }
            ```
        ]
    ]
]

[heading More Examples]
    ``__examples_externals__``

[heading See Also]

* __scopes__
* __scopes_deduce__
* __scopes_unique__
* __scopes_shared__
* __scopes_singleton__
* __scopes_session__

[endsect]

[endsect]

