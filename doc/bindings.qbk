[/
 /
 / Copyright (c) 2014 Krzysztof Jusiak (krzysztof at jusiak dot net)
 /
 / Distributed under the Boost Software License, Version 1.0.
 / (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /
 /]

[section Bindings]

[heading Description]
Bindings in `Boost.DI` are done using specially defined Domain Specific Language (DSL).
The main purpose of binding DSL is to make easy things as easy
as possible whilst giving possibility to accomplish solutions for more complicated problems.
The glue between DSL and the core is `dependency`, so if you would like to write your own front end
the only thing which has to be in mind is to return list of dependencies.

[heading Synopsis]
    template<
        typename TScope
      , typename TExpected
      , typename TGiven
      , typename TBind
    >
    class dependency;

[table Parameters
    [[Parameter][Requirement][Description]]
    [[`TScope`][Scope Model type][Scope to be used]]
    [[`TExpected`][None][Type to be returned]]
    [[`TGiven`][None][Type to be created]]
    [[`TBind`][Bind Model type][Expression to be evaluated to verify dependency match during resolving]]
]

[heading Header]
    #include <boost/di.hpp>

[heading Examples]
    template<typename TIf, typename TImpl>
    struct bind
        : bindings::dependency<scopes::deduce, TIf, TImpl>
    { };

    di::make_injector(
        bind<i, impl>()
    );

[heading More Examples]
    ``[link di.examples Binding]``

[heading Tests]
    ``[@test/ut/bindings_ut.cpp]``

[heading Description]
Custom bindings requires `apply` class which should return compile time integer value.
Given value will influence how dependencies will be resolved. Current algorithm might
be found in `Design Rationale`.

[heading Synopsis]
    struct unspecified {
        template<typename TDependency>
        struct apply
            : TResult
        { };
    }

[table Parameters
    [[Parameter][Requirement][Description]]
    [[`TDependency`][Dependency Model type][Dependency type]]
    [[`TResult`][Integral value][Returns integer value represents importance of binding]]
]

[heading Header]
    #include <boost/di.hpp>

[heading Examples]
    struct longer_call_stack_first {
        template<typename TDependency>
        struct apply
            : mpl::size<typename TDependency::call_stack>
        { };
    }

    auto injector = di::make_injector(
        di::bind<int>::to(1)
      , di::bind<int>::when<longer_call_stack_first>::to(42)
    );

    struct example {
        explicit example(int i) : i(i) { };
        int i = 0;
    };

    assert(1 == injector.create<int>());
    assert(42 == injector.create<example>().i);

[heading Tests]
    ``[@test/ut/bindings_ut.cpp]`` | ``[@test/ut/core/binder_ut.cpp]``

[section bind]

[heading Description]
Allows bind interface to implementation and associate value with `dependency`.

[heading Synopsis]
    template<typename TInterface, typename TImplementation>
    struct bind
        : bindings::dependency<scopes::deduce, TInterface, TImplementation>
    {
        template<typename T>
        static dependency to(const T&);
    };

[table Parameters
    [[Parameter][Requirement][Description]]
    [[`TInterface`][None][Interface type]]
    [[`TImplementation`][None][Implementation type]]
    [[`T`][`POD`/`reference_wrapper`/`shared_ptr`][Value type]]
    [[`x.to(...)`][None][Returns new `dependency` with associated `T` value]]
]

[heading Expression Semantics]
    bind<i, impl>()
    bind<int>::to(int())

[*Return type]: `dependency`

[heading Header]
    #include <boost/di.hpp>

[heading Examples]
[table
    [[Binding][Description]]
    [[```di::bind<interface, implementation>())```][bind interface to implementation]]
    [[```di::bind<implementation>())```][bind to implementation with deduced interface]]
    [[```di::bind<int>::to(42)```][bind to number]]
    [[```di::bind<std::string>::to("text")```][bind to text value]]
    [[```di::bind<example>::to(cref(example_))```][bind to const reference]]
    [[```di::bind<example>::to(ref(example_))```][bind to reference]]
    [[```di::bind<interface>::to(make_shared<implementation>())```][bind to shared_ptr]]
    [[```di::bind<int>::to([]{ return 42; })```][bind value to functor expression]]
    [[```di::bind<function<int()>>::to([]{ return 42; })```][bind to lambda expression]]
    [[```di::bind<std::function<int()>>::to(boost::bind(&return_int, 42))```][bind to functor expression]]
    [[```di::bind_int<42>::named<mpl::string<'rnt'>>()```][bind annotated int to value named with `int`]]
    [[```di::bind<interface, implementation>::named<my_if>```][bind annotated interface to implementation named with `my_if`]]
]

[heading Tests]
    ``[@test/ut/bindings_ut.cpp]`` | ``[@test/ut/core/binder_ut.cpp]``

[endsect]

[section bind_bool]
[endsect]

[section bind_int]
Allows bind compile time integer value.

[heading Synopsis]
    template<int N>
    struct bind_int
        : bind<int, mpl::int_<N> >
    { };

[table Parameters
    [[Parameter][Requirement][Description]]
    [[`N`][Integer number][Value to be binded to `int` parameters]]
]

[heading Expression Semantics]
    bind_int<42>();

[*Return type]: `dependency`

[heading Header]
    #include <boost/di.hpp>

[heading Examples]
    di::make_injector(
        di::bind_int<42>()
    );

    di::injector<
        di::bind_int<42>
    >;

[heading Tests]
    ``[@test/ut/bindings_ut.cpp]`` | ``[@test/ut/core/binder_ut.cpp]``

[endsect]

[section bind_string]
Allows bind compile time string value.

[heading Synopsis]
    template<typename T>
    struct bind_string
        : bind<std::string, T>
    { };

[table Parameters
    [[Parameter][Requirement][Description]]
    [[`T`][`mpl::string` Model type][Value to be binded to `std::string` parameters]]
]

[heading Expression Semantics]
    bind_string<mpl::string<'str'>>();

[*Return type]: `dependency`

[heading Header]
    #include <boost/di.hpp>

[heading Examples]
    di::make_injector(
        di::bind_string<mpl::string<'str'>>()
    );

    di::injector<
        di::bind_string<mpl::string<'str'>>
    >;

[heading Tests]
    ``[@test/ut/bindings_ut.cpp]`` | ``[@test/ut/core/binder_ut.cpp]``

[endsect]

[section scope]
Allows to bind bindings to defined/custom scope.

[heading Synopsis]
    template<typename TScope>
    struct scope
        : bindings::scope<TScope>
    { };

[table Parameters
    [[Parameter][Requirement][Description]]
    [[`TScope`][Scope Model type][scope to be binded]]
]

[heading Expression Semantics]
    scope<scopes::unique<>>::bind<...>()

[*Return type]: `dependency`

[heading Header]
    #include <boost/di.hpp>

[heading Examples]
    di::make_injector(
        di::scope<scopes::unique<>>::bind<
            di::bind<i, impl>
        >()
    );

    di::injector<
        di::scope<scopes::unique<>>::bind<
            di::bind<i, impl>
        >
    >;

[heading Tests]
    ``[@test/ut/bindings_ut.cpp]`` | ``[@test/ut/core/binder_ut.cpp]``

[endsect]

[section deduce]
Allows to bind bindings to `deduce` scope. Interface type will be deduced, if not given.

[heading Synopsis]
    template<typename... TArgs>
    struct deduce
        : scope<scopes::deduce>::bind<TArgs...>
    { };

[table Parameters
    [[Parameter][Requirement][Description]]
    [[`TArgs...`][Binding Model type][Bindings to be binded with `deduce` scope]]
]

[heading Expression Semantics]
    deduce<bind<i, impl>>()

[*Return type]: `dependency`

[heading Header]
    #include <boost/di.hpp>

[heading Examples]
    di::make_injector(
        di::deduce<impl>() // interface type deduction
    );

    di::injector<
        di::deduce<impl> // interface type deduction
    >;

    di::make_injector(
        di::deduce<
            di::bind<i, impl>
        >()
    );

    di::injector<
        di::deduce<
            di::bind<i, impl>
        >()
    >;

[heading Tests]
    ``[@test/ut/bindings_ut.cpp]`` | ``[@test/ut/core/binder_ut.cpp]``

[endsect]

[section unique]
[endsect]

[section shared]
[endsect]

[section session]
[endsect]

[section call_stack]
* bind using call stack context
```
    call_stack<c1, c2, ..., cN> // call stack definition

    class c2 {
    public:
        c2(unique_ptr<interface>);
    };

    class c1 {
    public:
        c1(c2);
    };

    di::bind<interface, implementation>::when<call_stack<c1, c2>>()

```
[note `BOOST_DI_CFG_EXAMINE_CALL_STACK` has to be defined to enable this features]

* bind using call stack context and named parameters
```
    class c2 {
    public:
        c2(di::named<unique_ptr<interface>, my_if>);
    };

    class c1 {
    public:
        c1(c2);
    };

    // bind interface to implementation for named
    // parameter `my_if` when the class `c2` was created from class `c1`

    di::bind<interface, implementation>::named<my_if>::when<call_stack<c1, c2>>()
    di::bind<implementation>::named<my_if>::when<call_stack<c1, c2>>()
    di::bind<interface, implementation>::when<call_stack<c1, c2>>::named<my_if>()
    di::bind<implementation>::when<call_stack<c1, c2>>::named<my_if>()

    // all bindings above are equivalent
```


[endsect]

[section any_of]

* bind the same implementation to many interfaces
```
    di::bind<any_of<interface1, interface2, ..., interfaceN>, implementation>
```
[note The same might be achived with `bind<implementation>`]

[endsect]

[endsect]

