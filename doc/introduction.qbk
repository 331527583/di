[/
 /
 / Copyright (c) 2014 Krzysztof Jusiak (krzysztof at jusiak dot net)
 /
 / Distributed under the Boost Software License, Version 1.0.
 / (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /
 /]

[section Introduction & Motivation]

[:['["Don't call us, we'll call you.]]]
[:*--Hollywood principle*]

[*[@http://en.wikipedia.org/wiki/Dependency_injection Dependency injection]] (DI) involves passing (injecting) one or more dependencies (or services) to a dependent object (or client) which become part of the clientâ€™s state. It is like the Strategy Pattern, except the strategy is set once, at construction. DI enables loosely coupled designs, which are easier to maintain and test.
Following this approach has many advantages.

[table
[[Let's make some coffee!]]
[[[@images/coffee_maker.png [$images/coffee_maker.png]]]]
]

[table
[[No Dependency Injection][Dependency Injection]]
    [
        [
            ```
                class coffee_maker {                    
                public:                                 
                    coffee_maker()                      
                      : heater{make_shared<electric_heater>()}                               
                      , pump{make_unique<heat_pump>(heater)}                               
                    { }                                 
                                                        
                    void brew() {                       
                        heater->on();                   
                        pump->pump();                   
                        clog << "coffee"! << endl;      
                        heater->off();                  
                    }                                   
                                                        
                private:                                
                    shared_ptr<iheater> heater;         
                    unique_ptr<ipump> pump;             
                };                                      
            ```
        ]
        [
            ```
                class coffee_maker {
                public:
                    coffee_maker(shared_ptr<iheater> heater, unique_ptr<ipump> pump)
                        : heater(heater)
                        , pump(move(pump))
                    { }
                                                            
                    void brew() {
                        heater->on();
                        pump->pump();
                        clog << "coffee!" << endl;
                        heater->off();
                    }
                                                            
                private:
                    shared_ptr<iheater> heater;
                    unique_ptr<ipump> pump;
                };
            ```
        ]
    ]
]














* [*Provide loosely coupled code] (Separation of business logic and object creation)
* [*Provide easier to maintain code] (Different objects might be easily injected)
* [*Provide easier to test code] (Fakes objects might be injected)


`Boost.DI` is a `dependency injection library` improving `manual dependency injection` by simplifying object instantiation with automatic dependencies injection.
Using `Boost.DI` has many advantages over `manual dependency injection`.

* [*Reduce boilerplate code] (No factories, no objects creation in specific order)
* [*Reduce cost of maintenance effort] ([link di.examples.constructor_signature Constructor signature] change won't affect `di` configuration)
* [*Reduce testing effort]
* [*Give better control of what and how is created] (__policies__, __providers__)
* [*Give better understanding about objects hierarchy] (__examples_uml_dumper__)

[table
[[Manual Dependency Injection][`Boost.DI`]]
    [
        [
            ```
                int main() {
                    // boilerplate code
                    auto logic = make_shared<logic>();
                    auto logger = make_shared<logger>();

                    return example{logic, logger}.run();
                }
            ```
        ]
        [
            ```
                int main() {
                    auto injector = __di_make_injector__(
                        __di_bind__<ilogic, logic>
                      , __di_bind__<ilogger, logger>
                    );
                    return injector.__di_injector_create__<example>().run();                     .
                }
            ```
        ]
    ]
]

`Boost.DI` [*key] features.

* [*Type safe]
* [*Header only]
* [*Compile time creation guarantee] - no exceptions - if application compiles all dependencies will be be created accurately
* [*Exception safe strong guarantee]
* [*None or minimal run-time execution overhead] - [link di.performance.run_time Run-time performance]
* [*Fast compilation times] - [link di.performance.compile_time Compile-time performance]
* [*[link di.user_guide.injections.automatic Macro free]] - by default - no need to specify constructor traits or register anything
* [*[link di.user_guide.scopes.deduce Scopes deduction]] - [link di.user_guide.scopes scopes] are deduced based on type semantic
* [link di.user_guide.policies Policies] to limit [link di.user_guide.policies.constructible supported constructor parameters] or dump objects creation graph (__examples_uml_dumper__)
* Automatic conversion to boost smart pointers (if boost is available)
* Requires `C++14` compliant compiler

[heading See Also]
* [link di.motivation Motivation]
* [link di.overview Overview]
* [link di.tutorial Tutorial]
* [link di.quick_user_guide Quick user Guide]
* [link di.diagnostic_messages Diagnostic messages]
* [link di.performance Performance]
* [link di.user_guide User Guide]
* [link di.examples Examples]
* [link di.rationale Rationale]

[endsect]

