<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Experimental Boost.DI</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/league.css" id="theme">

		<!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<div class="slides">
          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$"
                   data-notes="^Note:">
					<script type="text/template">

C++Now 2016

# C++14 Dependency Injection Library

https://github.com/boost-experimental/di

Kris Jusiak

==============================================================================

##Dependency Injection

----

(DI) involves passing (injecting) one or more dependencies (or services) to a dependent object (or client) which become part of the clientâ€™s state. It is like the Strategy Pattern, except the strategy is set once, at construction. DI enables loosely coupled designs, which are easier to maintain and test

Rob Stewart

----

## "Let's make some coffee!"

<center>[![Coffee Maker](images/coffee_maker.png)](images/coffee_maker.png)</center>

----

##No Dependency Injection

```cpp
class coffee_maker {
public:
  // create dependencies in the constructor
  coffee_maker()
    : heater(std::make_shared<electric_heater>())
    , pump(std::make_unique<heat_pump>(heater))
  { }

  void brew() {
    heater->on();
    pump->pump();
  }

private:
  std::shared_ptr<iheater> heater;
  std::unique_ptr<ipump> pump;
};
```

----

##Dependency Injection

```cpp
class coffee_maker {
public:
  // inject dependencies via constructor
  coffee_maker(std::shared_ptr<iheater> heater
             , std::unique_ptr<ipump> pump)
    : heater(heater), pump(move(pump))
  { }

  void brew() {
    heater->on();
    pump->pump();
  }

private:
  std::shared_ptr<iheater> heater;
  std::unique_ptr<ipump> pump;
};
```

----

##It's all about the construction!

> "Don't call us, we'll call you", Hollywood principle

----

##Do I need Dependency Injection?

----

##Depends...

----

* DI provides loosely coupled code
  * separation of business logic and object creation
* DI provides easier to maintain code
  * different objects might be easily injected
* DI provides easier to test code
  * fakes objects might be injected

==============================================================================

##Do I need a DI Framework/Library?

----

Depending on a project and its scale you may put up with or without a DI library, however, in any project
a DI framework may **free you** from maintaining a following (boilerplate) code...

----

```cpp
auto create() {
  logger logger_;
  renderer renderer_;
  view view_{renderer_, logger_};
  model model_{logger_};
  controller controller_{model_, view_, logger_};
  user user_{logger_};
  ...
  return make_unique<app>(controller, user_, logger_).run();
}
```

----

Notice that **ORDER** in which above dependencies are created is **IMPORTANT** as well as that
**ANY** change in **ANY** of the objects constructor will **REQUIRE** a change in the code!

----

###Showcase

---

http://wandbox.com

----

DI library, not only let you forget about maintaining this code,
but also can help you with...

----

* Testing
* Serializing
* Understanding dependencies
* Restricting allowed types

----

###Try it yourself online!

---

http://boost-experimental.github.io/di/try_it

----

##Still not convinced?

----

###Real-life example?

----

> Let's make a web match-3 game in C++14

* Model-View-Controller
* Dependency Injection
* Meta State Machine
* Range-V3

---

[Thursday, May 12 / 9:00am - 10:30am](https://cppnow2016.sched.org/event/6Sg4/lets-make-a-web-match-3-game-in-c14-using-dependency-injectionexperimental-boostdi-meta-state-machineexperimental-boostmsm-lite-rangev3-and-msvc-and-emscripten)

---

[https://github.com/modern-cpp-examples/match3](https://github.com/modern-cpp-examples/match3)

==============================================================================

##C++ vs Java vs C# Libraries

----

###Writing a DI library in C++ is not an easy task

----

* Performance is important
* Lack of static reflection
* Pointers, References, Rvalues, Smart Pointers, ...
* Qualifiers - const, volatile, ...
* Templates, Concepts, ...

----

###DI Libraries...

----

![Libraries](images/libraries.png)

----

##Benchmarks

----

TODO

----

###More Benchmarks

---

http://boost-experimental.github.io/di/benchmarks

==============================================================================

##Experimental Boost.DI

==============================================================================

##Overview

----

###A bit of history

----

2012 - 2014

---

Version C++98 / C++11 - never released

---

https://github.com/boost-experimental/di/tree/cpp03

----

* Compiled slowly (Boost.MPL)
* Enormous error messages
* A lot of preprocessor magic (BOOST_PP)
* A lot of workarounds for compilers (MSVC 2013)

----

2014 - Now

---

Version C++14 - v1.0.0

---

https://github.com/boost-experimental/di/tree/cpp14

---

----

* One header (boost/di.hpp) / generated
* 3k lines
* Neither Boost nor STL is required
* No 'if' branches
* No 'virtual' methods
* No 'exceptions' (-fno-exceptions)

----

##Tested compilers

----

* [Clang-3.4+](https://travis-ci.org/boost-experimental/di)

* [XCode-6.1+](https://travis-ci.org/boost-experimental/di)

* [GCC-5.2+](https://travis-ci.org/boost-experimental/di)

* [MSVC-2015+](https://ci.appveyor.com/project/krzysztof-jusiak/di)

----

##Quality (per commit)

> CONTINOUS INTEGRATION

----

* Travis/Appveyor build on Linux/OS X/Windows (Boost-Build/CMake)
  * Clang-3.4/3.5/3.6/3.7/3.8 (libc++ / stdlibc++)
  * GCC-5
  * MSVC-2015
* Clang static analysis / Clang-tidy (static check)
* Valgrind / Dr. Memory (dynamic memory check)
* Clang-format (style check)
* Deploy documentation to 'GitHub/gh-pages'

----

###Tests

----

##99% test code coverage

----

* Unit tests
* Functional tests
* Performance tests (benchmarks)
* Compilation-error tests (validates error message)
* Run-time generation tests (compares generated assembler opcodes)

==============================================================================

##Design

----

##Goals

----

* ###Be as fast as possible

  * Boost.DI has none or minimal run-time overhead

----

* ###Compile as fast as possible

  * Boost.DI compiles **faster than Java-Dagger2!**

----

* ###Guarantee object creation at compile-time

  * Boost.DI resolves types at compile-time and gives short and intuitive error messages

> If it compiles it will work!

----

* ###Be as non-intrusive as possible

  * Boost.DI deduces constructor parameters without reflection

----

* ###Be easy to extend

  * Boost.DI provides easy way to write custom scopes/policies/providers

----

###Architecture

----

<img style="height:550px;" src="images/di.png" />

----

* Bindings

  * DSL to create dependencies representation which will be used by core to resolve types

----

* Scopes

  * Responsible for maintain objects life time

----

* Providers

  * Responsible for providing object instance

----

* Policies

  * Compile-time limitations for types / Run-time types visitor

----

* Config

  * Configuration for Policies and Providers

----

##In a nutshell (Pseudo-code)

----

```cpp
template<class TConfig, class... TBindings>
class core::injector {
  template<class T> constexpr auto create() const noexcept {
    TConfig::policies<T>()...;

    auto&& dependency = binder{}.resolve<T>(TBindings...);
    using ctor = ctor_traits<injector, T>();

    return wrapper<T>{
      dependency.create( // create in a dependency scope
        TConfig::provider{}.get<decltype(dependency.impl)>(
          create<ctor>()...))
    };
  }
};
```

[https://github.com/boost-experimental/di](https://github.com/boost-experimental/di)

==============================================================================

##User Guide

----

###Create objects tree

----

[![Create objects tree](images/tutorial_create_objects_tree.png)](images/tutorial_create_objects_tree.png)

----

```cpp
struct renderer { int device; };
class iview {
public:
  virtual ~iview() = default;
  virtual void update() = 0;
};
class model {};
class controller {
public:
  controller(model&, view&) {}
};
class user {};
class app {
public:
  app(controller&, user&) {}
};
```

----

###Usual approach to create `app`

----

```cpp
renderer renderer_;
view view_{"title", renderer_};
model model_;
controller controller_{model_, view_};
user user_;
app app_{controller_, user_};
```

----

###With Boost.DI

----

```cpp
auto app = di::make_injector().create<app>();
```

----

###Where

----

```cpp
template<class TConfig = di::config, class... TDeps>
  requires configurable<TConfig>() && boundable<TDeps...>()
auto make_injector(TDeps&&...) noexcept;
```

```cpp
template<class... TDeps> requires boundable<TDeps...>()
class injector {
public:
  injector(injector&&) = default;
  explicit injector(TDeps&&...) noexcept;

  template<class T> requires creatable<T>()
  constexpr auto create() const;

  template<class T> requires !creatable<T>()
  [[deprecated("creatable constraint not satisfied")]]
  constexpr auto create() const;
};
```

----

###How is that possible without static reflection?

----

###User-defined/implicit/generic conversion operator

----

```cpp
struct any_type {
  template<class T>
  constexpr operator T(); // non explicit
};

int main() {
  struct example {
    example(int, double);
  };

  static_assert(
    std::is_constructible<example, any_type, any_type>::value);
}
```
https://wandbox.com

----

###Limitations

----

It doesn't work for constructor with one parameter!

> Copy constructor / Move constructor

---

> Generic converting constructor
```cpp
class example {
public:
  template<class T>
  example(T); // non explicit
};
```

----

###Disable the operator when type T is convertible to the parent type

----

```cpp
template<class TParent>
struct any_type {
  template<class T, class =
    std::enable_if_t<!std::is_convertible<TParent, T>{}>
  > constexpr operator T();
};

int main() {
  struct example {
    example(int, double);
  };

  static_assert(
    !std::is_constructible<example, any_type<example>>::value);
}
```
https://wandbox.com

----

###Calculate the number of parameters?

----

```cpp
constexpr auto BOOST_DI_CFG_CTOR_LIMIT_SIZE = 10;

template<class T, std::size_t>
using any_type_t = any_type<T>;

template<class...>
struct is_constructible;

template<class T, std::size_t... Ns>
struct is_constructible<T, std::index_sequence<Ns...>>
  : std::is_constructible<T, any_type_t<T, Ns>...>
{ };
```

----

```cpp
template <class T, std::size_t... Ns>
constexpr auto ctor(std::index_sequence<Ns...>) noexcept {
  auto value = 0;
  int _[]{0, (is_constructible<T, std::make_index_sequence<Ns>>{}
    ? value = Ns : value)...};
  return value;
}

int main() {
  struct example {
    example(int, double, float);
  };

  static_assert(3 == ctor<example>(
    std::make_index_sequence<BOOST_DI_CFG_CTOR_LIMIT_SIZE>{}));
}
```
https://wandbox.com

----

###How it's done in DI?

----

###is braces constructible

----

```cpp
template <class T, class... TArgs>
decltype(void(T{declval<TArgs>()...}), true_type{})
test_is_braces_constructible(int);

template <class, class...>
false_type test_is_braces_constructible(...);

template <class T, class... TArgs>
using is_braces_constructible =
  decltype(test_is_braces_constructible<T, TArgs...>(0));

template <class T, class... TArgs>
using is_braces_constructible_t =
  typename is_braces_constructible<T, TArgs...>::type;

```

```cpp
struct example { int a; int b; };
static_assert(is_braces_constructible<example, any_type, any_type>{});
```

----

###Implementation (Pseudo-code)

----

```cpp
template<class TInjector, class TParent>
struct any_type {
  template<class T, class =
    std::enable_if_t<!std::is_convertible<TParent, T>{}>
  > constexpr operator T() {
    return injector_.template create<T>();
  }

  const TInjector& injector_;
};
```

----

```cpp
template<class TInjector, class T> auto ctor_traits() {
  if (has_inject<T>() { // BOOST_DI_INJECT
    return pair<direct, typename T::inject>{};
  }
  for (auto i = BOOST_DI_CFG_CTOR_LIMIT_SIZE; i >= 0; --i) {
    if (is_constructible<T, any_type<TInjector, T>...>())
      return pair<direct, any_type<TInjector, T>...>{};
    }
  }
  for (auto i = BOOST_DI_CFG_CTOR_LIMIT_SIZE; i >= 0; --i) {
    if (is_braces_constructible<T, any_type<TInjector, T>...>())
      return pair<uniform, any_type<TInjector, T>...>{};
    }
  }
  return error(...); // concepts emulation
};
```

----

###Coming back to the design

----

```cpp
template<class TConfig, class... TBindings>
class core::injector {
  template<class T> constexpr auto create() const noexcept {
    TConfig::policies<T>()...;
    auto&& dependency = binder{}.resolve<T>(TBindings...);

    using ctor = ctor_traits<injector, T>(); // -\
     // pair<direct/uniform, TCtor...>  <--------/

    return wrapper<T>{
      dependency.create( // create in a dependency scope
        TConfig::provider{}.get<decltype(dependency.impl)>(
          create<ctor>()...))
    };
  }
};
```

----

##Bindings

> DI Configuration

----

###Interfaces

----

```cpp
class iview {
public:
  virtual ~iview() noexcept = default;
  virtual void update() =0;
};

class gui_view: public iview {
public:
  gui_view(std::string title, const renderer&) {}
  void update() override {}
};

class text_view: public iview {
public:
  void update() override {}
};
```

----

```cpp
auto injector = di::make_injector(
  di::bind<iview>.to<gui_view>() // bind interface to implementation
);
```

```cpp
assert(dynamic_cast<gui_view*>(
  injector.create<std::unique_ptr<iview>().get())
);
```

----

###Values

----

```cpp
struct T { // create using uniform initialization
  int& a;  // might be used to serialize
  double b;
};
```

```cpp
 auto i = 42;
 auto injector = di::make_injector(
    di::bind<int>.to(i),
    di::bind<double>.to(87.0)
 );
 injector.create<T>(); // will create T{i, 87.0};
```
https://wandbox.com

----

###Dynamic conditions

----

```cpp
auto use_gui_view = true/false;

auto injector = di::make_injector(
  di::bind<iview>.to([&](const auto& injector) -> iview& {
    return use_gui_view ?
      injector.template create<gui_view&>() :
      injector.template create<text_view&>();
  })
);
```

```cpp
use_gui_view = true;
assert(dynamic_cast<gui_view*>(
  injector.create<std::unique_ptr<iview>().get())
);

use_gui_view = false;
assert(dynamic_cast<text_view*>(
  injector.create<std::unique_ptr<iview>().get())
);
```

----

###This way XML injection might be easily achieved

---

[XML Injection](http://boost-experimental.github.io/di/extensions/index.html#xml-injection)

----

###Vectors/Lists/Arrays/...

----

###Using initializer list

----

```cpp
auto injector = di::make_injector(
  di::bind<int[]>().to({1, 2, 3})
);

auto v = injector.create<std::vector<int>>();
  // or std::array / std::set

assert(3 == v.size());
assert(1 == v[0]);
assert(2 == v[1]);
assert(3 == v[2]);
```

----

###Using list of types

----

```cpp
auto injector = di::make_injector(
  di::bind<interface*[]>().to<implementation1, implementation2>()
);
```

```cpp
auto v = injector.create<
  std::vector<std::unique_ptr<interface>>>();
    // or std::array / std::set with
    // std::shared_ptr, raw pointer, reference, ...

assert(2 == v.size());
assert(dynamic_cast<implementation1*>(v[0].get()));
assert(dynamic_cast<implementation2*>(v[1].get()));
```

----

##Scopes

> Objects life time

----

* deduce scope (default)
* instance scope (bind<>.to(value) where value is maintained by the user)
* unique scope (one instance per request)
* singleton scope (shared instance)

----

```
+-------------------------------------------------+ singleton scope
|
|          unique scope     unique scope
|          +---+            +------+
|          |                |
+--+-------+----------------+---------------------> Application life time
   |
   |
   +------------------------+ instance / user scope
                             (is not controlled by DI)
```

----

###Scopes deduction

----

| Type | Scope |
|------|-------|
| `T`, `T&&`, `T*`, `const T*`, `std::unique_ptr<T>` | unique |
| `T&`, `const T&`, `std::shared_ptr<T>`, `boost::shared_ptr<T>`, `std::weak_ptr<T>` | singleton |

----

###Explicit change of the scope for a given type

----

```cpp
auto injector = di::make_injector(
  di::bind<iview>.to<gui_view>().in(di::singleton) // explicitly
);
```
----

##Injections / Annotations

----

```cpp
class model {
 public:
   model(int size, double precision) { }
   model(int rows, int cols) { }
};
```

> Constructor ambiguity (compilation error)

----

###Solution

----

```cpp
class model {
 public:
   model(int size, double precision) { }
   BOOST_DI_INJECT(model, int rows, int cols); // pick me!
};

model::model(int rows, int cols) {} // implementation is not affected
```
----

###Distinguish rows from columns

----

###Annotations / Names

----

```cpp
class model {
 public:
   model(int size, double precision) { }

   BOOST_DI_INJECT(model, (named = "rows"_s) int rows
                        , (named = "cols"_s) int cols);
};

model::model(int rows, int cols) {} // implementation stays the same
```

```cpp
auto injector = di::make_injector(
  di::bind<int>.named("rows"_s).to(6)
, di::bind<int>.named("cols"_s).to(8)
);
```

----

###Where

----

```cpp
template <char...>
struct string {};

template <class T, T... Ts>
constexpr auto operator""_s() {
  return string<Ts...>{}
}
```

> It's not standard!
> For a standard solution use unique types instead

----

##Modules

> Split DI configuration

----

```cpp
auto view_module = [] {
  return di::make_injector(
    di::bind<icanvas>.to<sdl_canvas>()
  , di::bind<irenderer>.to<gui_renderer>()
  );
};

auto model_module = [] {
  return di::make_injector(
    di::bind<config>.to({6, 8})
  , di::bind<irandom>.to<mt19937_random>()
  );
};
```

```cpp
auto injector = di::make_injector(
  view_module(), model_module()
);

injector.create<app>();
```

----

###Module in CPP file

----

###Expose types via injector

> Only exposed types will be creatable

----

```cpp
di::injector<view&> view_module() { // expose view
  return di::make_injector(
    di::bind<icanvas>.to<sdl_canvas>()
  , di::bind<irenderer>.to<gui_renderer>()
  );
}
```

```cpp
di::injector<model&> model_module() { // expose model
  return di::make_injector(
    di::bind<config>.to({6, 8})
  , di::bind<irandom>.to<mt19937_random>()
  );
}
```

```cpp
auto injector = di::make_injector(
  view_module(), model_module()
);

injector.create<app>();
```

==============================================================================

##Error messages / Concepts

----

###Concepts emulation

----

###"Standard" way without concepts

----

```cpp
#define REQUIRES(...) \
  typename std::enable_if<__VA_ARGS__, int>::type = 0
```

----

```cpp
template <class...>
using is_valid_expr = true_type;
```

```cpp
template <class T>
std::false_type providable_impl(...); // or some type error message

template <class T>
auto providable_impl(T&& t) -> is_valid_expr<
  decltype(t.template is_creatable<T>()),
  decltype(t.template get<T>())
>;

template <class T>
constexpr auto providable() {
  return decltype(providable_impl(std::declval<T>()))::value;
}
```

----

###How to get better error messages?

----

###Transport the substitution failures

----

```cpp
#define REQUIRES(...) \
  typename get_errors_from_types<__VA_ARGS__>::type
```

----

###Problem

> User-defined/implicit/generic conversion operator

----

```cpp
struct any_type {
  template<class T>
  constexpr operator T(); // no easy way to return a failure from T
};
```

----

###Solution

----

###Split concepts emulation into 2 parts

----

###Check the predicate

----

###Display the error message

----

###How?

----

###Creatable

----

```cpp
template <class T, class TDependency = binder::resolve_t<T>>
using creatable = std::is_convertible<
  TDependency::template try_create<T>(
    provider<ctor_traits<typename TDependency::impl>>{}
  );
>;
```

```cpp
template <class T, class TProvider>
auto try_create(const TProvider& provider) -> wrapper<
  unique, decltype(provider.get())> // `auto -> decltype` will disable
                                    // function if not applicable
try_create(const TProvider&);
```

----

```cpp
struct any_type {
  template <class T, REQUIRES(creatable<T>())>
  constexpr operator T(); // disabled when type is not creatable
};
```

----

```cpp
template<class T, class... TArgs, // TArgs migth be disabled by any_type
  REQUIRES(std::is_constructible<T, TArgs...>{})>
constexpr auto create_impl(TArgs&&... args) {
  return T{std::forward<TArgs>(args...)};
}

template<class T, class... TArgs,
  REQUIRES(!std::is_constructible<T, TArgs...>{})>
constexpr auto create_impl(TArgs&&... args) {
  return show_the_error<T>{};
}
```

----

###Show the error

----

```cpp
template<class T>
constexpr auto show_the_error() {
  return aux::is_polymorphic<T>{} ? // return the proper type
    abstract_type<T>::is_not_bound{} :
    type<T>::cant_be_created{}; // simplified version
};
```

----

> Static inline function without implementation will show
  a warning without a CALL STACK!

----

###Abstract type is not bound

----

```cpp
template <class T>
struct abstract_type {
  struct is_not_bound {
    constexpr operator T() const { return error(); }

    // no implementation
    static inline T
      error(_ = "type is not bound, did you forget to add:
          'di::bind<interface>.to<implementation>()'?");
  };
};
```

----

###Change the warning into error

----

```cpp
#if defined(__clang__)
#pragma clang diagnostic error "-Wundefined-inline"
#elif defined(__GCC__)
#pragma GCC diagnostic error "-Werror"
#elif defined(__MSVC__)
#pragma warning(disable : 4822) // function does not have a body
#endif
```

----

###From top to bottom

----

```cpp
template <class T, REQUIRES(creatable<T>())>
constexpr T create() const {
  return create_successful_impl(type<T>{}); // compilation time speed up
}

template <class T, REQUIRES(!creatable<T>())>
[[deprecated("creatable constraint not satisfied")]]
constexpr T create() const {
  return create_impl(type<T>{});
}
```

----

###Example

----

```cpp
struct renderer {
  int device;
};
class view {
public:
  view(std::string title, const renderer&);
};
class model {};
class controller {
public:
  controller(model&, view&) {}
};
class user {};
class app {
public:
  app(controller&, user&) {}
};
```

```cpp
auto injector = di::make_injector(); // no bindings for iview
injector.create<app>();
```

----

###Clang

----

```cpp
error: 'create<app>' is deprecated: creatable constraint not satisfied
  injector.create<app>();
           ^
note 'create<app>' has been explicitly marked deprecated here
  create
  ^
error: inline function 'abstract_type<iview>::is_not_bound::error'
 error(_ = "type is not bound, did you forget to add:
           'di::bind<interface>.to<implementation>()'?");
```

----

###GCC

----

```cpp
error: â€˜T injector<...>::create() const [with T = app]â€™ is deprecated:
  creatable constraint not satisfied
   injector.create<app>();
                        ^
note declared here
   create
   ^
error: inline function â€˜abstract_type<T>::is_not_bound::error(_)
  [with T = iview]â€™ used but never defined
  error(_ = "type is not bound, did you forget to add:
            'di::bind<interface>.to<implementation>()'?");
```

----

###MSVC

----

```cpp
error C4996: 'injector<...>::create': creatable constraint not
                                      satisfied
        with
        [
            TConfig=config
        ]
note see declaration of 'injector<...>::create'
        with
        [
            TConfig=config
        ]
error C4506: no definition for inline function
            'abstract_type<T>::is_not_bound::error(_)'
        with
        [
            T=iview
        ]
```

----

###BOOST DI CFG DIAGNOSTICS LEVEL

----

##BOOST DI CFG DIAGNOSTICS LEVEL=0

----

```cpp
error: 'create<app>' is deprecated: creatable constraint not satisfied
```

----

##BOOST DI CFG DIAGNOSTICS LEVEL=1

> Default

----

```cpp
error: 'create<app>' is deprecated: creatable constraint not satisfied
  injector.create<app>();

error: inline function 'abstract_type<iview>::is_not_bound::error'
 error(_ = "type is not bound, did you forget to add:
           'di::bind<interface>.to<implementation>()'?");
```
----

##BOOST DI CFG DIAGNOSTICS LEVEL=2

----

```cpp
error: 'create<app>' is deprecated: creatable constraint not satisfied

error: function â€˜T creating<T>::type(_) [with T = app]â€™
error: function â€˜T creating<T>::type(_) [with T = controller]â€™

error: inline function 'abstract_type<iview>::is_not_bound::error'
 error(_ = "type is not bound, did you forget to add:
           'di::bind<interface>.to<implementation>()'?");
```

==============================================================================

##Extensions

----

###Provide an easy way to extend DI functionality without changing the core

----

###Print types / Policy

----

```cpp
struct types_dumper : di::config {
  static auto policies(...) noexcept {
    return di::make_policies([](auto type) {
      using T = decltype(type);
      using ctor = typename T::type;
      using impl = typename T::given;
      std::cout << ... << std::endl;
    });
  }
};
```

----

###Example Output

----

```cpp
class iview {
public:
  virtual ~iview() noexcept = default;
  virtual void update() =0;
};
struct model { std::vector<int> board; };
class controller {
public:
  controller(model&, iview&) {}
};
struct user {};

class app {
public:
  app(controller&, user&) {}
};
```

----

```cpp
auto injector = di::make_injector<types_dumper>(
  di::bind<iview>.to<gui_view>()
);

injector.create<app>();
```

* app
    * controller
        * model
            * int[]
        * iview -> gui_view
    * user

----

###Serialize / Policy

> PODs only

----

###Serializable

----

```cpp
struct serializable : di::config {
  template <class TInjector>
  static auto policies(const TInjector& injector) noexcept {
    return di::make_policies([&](auto type) {
      using T = decltype(type);
      ...
      auto& serialize = injector.template create<serializable&>();
      auto ptr = reinterpret_cast<char*>(&injector.template create<T&>());
      const auto offset = calculate_offset(sizeof(T), alignof(T));
      serialize.emplace_back({get_type<T>(), ptr, offset});
      ...
    }
  }
};
```

----

###Serialize

----

```cpp
auto serialize = [](const auto& injector, auto& str) {
  serializable_call_t::apply(injector, [&](const auto& o, auto t) {
    str << o.path << " "
        << o.type << " "
        << o.offset << " "
        << std::to_string(
             *reinterpret_cast<decltype(t)*>(o.ptr() + o.offset)
           )
        << std::endl;
  });
};
```

----

###Deserialize

----

```cpp
auto deserialize = [](const auto& injector, auto& str) {
  serializable_call_t::apply(
    injector, [&](const auto& o, auto t, auto line) {
    std::string line, path, type;
    decltype(t) value = {};
    auto offset = 0;
    std::istringstream iss{line};
    iss >> path >> type >> offset >> value;
    *reinterpret_cast<decltype(t)*>(o.ptr() + offset) = value;
  });
};
```

----

###Example Output

----

```cpp
struct data { unsigned int ui; long l; float f; };
struct even_more_data { double d; bool b; long long ll; };
struct more_data { int i; long double ld; even_more_data d; short s; };

class example {
public:
  example(data& d, more_data& md) : d(d), md(md) {}

  void update(); // change data, more_data

private:
  data& d;
  more_data& md;
};
```

----

```cpp
auto injector = di::make_injector<serializable>();
injector.create<example>();
```

```cpp
std::stringstream str;
serialize(injector, str);
```

```cpp
deserialize(injector, str);
```

----

```cpp
example->data unsigned_int 13
example->data long 23
example->data float 0.330000
example->more_data int 44
example->more_data long_double 42.000000
example->more_data->even_more_data double 55.000000
example->more_data->even_more_data bool 1
example->more_data->even_more_data long_long 66
example->more_data short 77
```

----

###Constructible / Policy

----

###Let's Disallow types which are not PODs or are not bound

----

```cpp
struct is_pod_or_is_bound : di::config {
  static auto policies(...) noexcept {
    using namespace di::policies;
    return di::make_policies(
      constructible(std::is_pod<_>{} || is_bound<_>{})
    );
  }
};
```

----

```cpp
struct not_a_pod { virtual ~not_a_pod() = default; };
struct example { example(not_a_pod, int, double) { } };
```

```cpp
auto injector = di::make_injector<is_pod_or_is_bound>(
  di::bind<>().to(42)
, di::bind<not_a_pod>().to(not_a_pod{})
);

injector.create<example>();
```

----

###Error case / compilation error

----

```cpp
di::make_injector<is_pod_or_is_bound>().create<example>();
```

```cpp
error: 'create<example>' is deprecated: creatable constraint not satisfied
  injector.create<example>();
           ^
error: inline function 'type<not_a_pod>::not_allowed_by<
  or_<std::is_pod<_>, is_bound<_>>>::error'

  error(_ = "type disabled by constructible policy
           , added by BOOST_DI_CFG or make_injector<CONFIG>!");
```

----

###Mocks injector / Provider

----

###Automatic injection of mocks for interfaces

----

```cpp
struct mocks_provider : di::config {
  struct mock_provider {
    template <class T, class TInit, class TMemory, class... TArgs>
    std::enable_if_t<!std::is_polymorphic<T>::value, T*> get(
    get(const TInit&, const TMemory&, TArgs&&... args) {
      return new T{std::forward<TArgs>(args)...);
    }

    template <class T, class TInit, class TMemory, class... TArgs>
    std::enable_if_t<std::is_polymorphic<T>::value, T*> get(
      return &get_mock<T>();
    }
  };

public:
  static auto provider(...) noexcept { return mock_provider{}; }
};
```

----

###Get mock

---

> https://github.com/eranpeer/FakeIt
https://github.com/dascandy/hippomocks

----

###Example

----

```cpp
class iview {
public:
  virtual ~iview() noexcept = default;
  virtual void update() =0;
};
struct model { std::vector<int> board; };
class controller {
public:
  controller(model&, iview&) {}
};
struct user {};

class app {
public:
  app(controller&, user&) {}
};
```

----

```cpp
auto injector = di::make_injector<mocks_provider>(
  di::bind<int[]>.to({1, 2, 3, 4, 5, 6})
  // we don't have to bind iview!
);

injector.create<app>();
```

```cpp
auto&& v = get_mock<iview>();
When(Method(v, update)).AlwaysDo([]{...});
```

---
https://github.com/modern-cpp-examples/match3

----

###More extensions

---

[Constructor Bindings](http://boost-experimental.github.io/di/extensions/index.html#constructor-bindings) | [Contextual Bindings](http://boost-experimental.github.io/di/extensions/index.html#contextual-bindings)

[XML Injection](http://boost-experimental.github.io/di/extensions/index.html#xml-injection) | [Assisted Injection](http://boost-experimental.github.io/di/extensions/index.html#assisted-injection)

[Concepts](http://boost-experimental.github.io/di/extensions/index.html#concepts) | [Lazy](http://boost-experimental.github.io/di/extensions/index.html#lazy) | [Named Parameters](http://boost-experimental.github.io/di/extensions/index.html#named-parameters)

[Types Dumper](http://boost-experimental.github.io/di/extensions/index.html#types-dumper) | [UML Dumper](http://boost-experimental.github.io/di/extensions/index.html#uml-dumper) | [Serialize](http://boost-experimental.github.io/di/extensions/index.html#serialize)

[Mocks Provider](http://boost-experimental.github.io/di/extensions/index.html#mocks-provider)

[Scoped Scope](http://boost-experimental.github.io/di/extensions/index.html#scoped-scope) | [Session Scope](http://boost-experimental.github.io/di/extensions/index.html#session-scope) | [Shared Scope](http://boost-experimental.github.io/di/extensions/index.html#shared-scope)

==============================================================================

##Performance

----

###Environment

----

2.3 GHz Intel Core i7 / 16 GB 1600 Mhz DDR3

----

##Run-time

----

###Bind type to value

----

```cpp
#include <boost/di.hpp>

namespace di = boost::di;

auto test() {
  auto injector = di::make_injector(
    di::bind<int>.to(42)
  );

  return injector.create<int>();
}
```

----

###ASM x86-64

```
mov $0x2a,%eax
retq
```

Same as...

```
return 42;
```


----

###How?

----

No run-time branches as everything is known at compile time and might be optimized!

----

```cpp
injector.create<int>();  ---------------\
  create_successful_impl(type<int>());  |   mov $0x2a,%eax
      scope.create<int>(provider);      |-  retq
        provider.get<int>();            |
          return 42; -------------------/
```

----

###Bind interface to implementation

----

```cpp
#include <boost/di.hpp>

namespace di = boost::di;
auto test() {
  auto injector = di::make_injector(
    di::bind<interface>.to<implementation>()
  );

  return injector.create<std::unique_ptr<interface>>();
}
```

----

###ASM x86-64

```
push   %rbx
mov    %rdi,%rbx
mov    $0x8,%edi
callq  0x4009f0 <_Znwm@plt>
movq   $0x400e78,(%rax)
mov    %rax,(%rbx)
mov    %rbx,%rax
pop    %rbx
retq
```

Same as...

```cpp
return std::make_unique<implementation>();
```

----

##Compile-time

----

###Include DI header

----

```cpp
#include <boost/di.hpp>

int main() {}
```

0.050s

> Nighter STL nor Boost is used

----

![Performance](images/performance.png)

```cpp
* 4248897537 instances created
* 132 different types
* 10 modules
```

----

##Speed up compilation times

----

###Always measure!

----

###Guidelines

----

###Avoid template instantiations

----

###Avoid recursive template algorithms

----

###Do checks once and as early as possible

----

###Avoid long type names (variadic templates)

----

###Use compiler built-ins and common tricks to gain performance

```cpp
template<bool...> struct bool_seq;

template<class... Ts>
using and_ = std::is_same<
    bool_seq<Ts::value...>,
    bool_seq<(Ts::value, true)...>
>;
```

```cpp
__make_index_seq is O(1) since Clang 3.9
```

----

###Implementation

----

###Resolve

----

```cpp
template<class T>
struct dependency_concept { };

template<class I, class Impl>
struct dependency : pair<dependency_concept<I>, dependency<I, Impl>> { };

template<class... Ts>
struct injector : Ts...  { };

template<class... Ts>
auto make_injector(Ts...) {
  return injector<Ts...>{};
}
```

----

```cpp
struct binder {
  template <class TDefault, class>
  static TDefault resolve_impl(...) noexcept { return {}; }

  template <class, class TConcept, class TDependency>
  static decltype(auto)
  resolve_impl(pair<TConcept, TDependency>* dep) noexcept {
    return static_cast<TDependency&>(*dep);
  }

  template <class T, class TDefault, class TDeps>
  static decltype(auto) resolve(TDeps* deps) noexcept {
    using dependency = dependency_concept<std::decay_t<T>>;
    return resolve_impl<TDefault, dependency>(deps);
  }
};
```

----

```cpp
auto injector = make_injector(dependency<i1, impl1>{});

struct default_dependency{};

static_assert(std::is_same<dependency<i1, impl1>,
  std::decay_t<decltype(
    binder{}.resolve<i1, default_dependency>(&injector))
  >>{}
);

static_assert(std::is_same<default_dependency,
  std::decay_t<decltype(
    binder{}.resolve<i2, default_dependency>(&injector)
  )>>{}
);
```
https://wandbox.com

----

###Resolve - Benchmarks

----

| Number of dependencies | Resolve time (middle dependency) |
| ---------------------- | -------------------------------- |
| 1                      | 0.077s                           |
| 16                     | 0.079s                           |
| 32                     | 0.082s                           |
| 64                     | 0.083s                           |
| 128                    | 0.089s                           |

----

###Creatable Concept

----

###Idea

----

```cpp
                            creatable<T>
                           (make it lite)
                                 |
                  /--------------+-----------------\
                Yes                                No
                 |                                 |
        create_successful_impl                  create_impl
```

----

```cpp
template <class T> requires creatable<T>()
constexpr T create() const {
  // no checks for errors!
  return create_successful_impl(type<T>{});
}

template <class T> requires !creatable<T>()
[[deprecated("creatable constraint not satisfied")]]
constexpr T create() const {
  // checks for errors to report it
  return create_impl(type<T>{});
}
```

----

###'Name' erasure

----

Long type names may increase your compilation times a LOT!

----

```cpp
template<class... Ts> auto make_injector(Ts... args) {
  return injector<Ts...>(args...); // may produces a long type name
}

auto injector = make_injector(...);
injector.create<T>(); // slow to compile
                      // a lot of long type names comparisons
```

----

###Solution - inheritance

----

```cpp
auto injector = di::make_injector(...);

struct erase_long_type_name : decltype(injector) {
  using decltype(injector)::injector;
};

erase_long_type_name{injector}.create<T>(); // quick to compile
                                            // type name =>
                                            // erase_long_type_name
```

----

###Solution - lambda expression

----

```cpp
static auto make_injector_impl = [](auto injector) {
  using injector_t = decltype(injector);

  struct i : injector_t {
    explicit i(injector_t&& other)
      : injector_t(std::move(other)) { }
  };

  return i{std::move(injector)};
};
```

----

###'Name' erasure - Benchmark

----

| Solution                         | Number of bindings | Time    |
| -------------------------------- | ------------------ | ------- |
| Long type name                   | 256                | 5.321s  |
| Name erasure / inheritance       | 256                | 2.521s  |
| Name erasure / lambda expression | 256                | 3.278s  |

----

##More Benchmarks...

----

http://boost-experimental.github.io/di/overview

==============================================================================

##DI vs ISO C++

----

###Static reflection

----

###Deduction of constructor parameters

----

```cpp
class example {
public:
  example(int, double);
};

static_assert(is_same<
  std::tuple<int, double>
, std::function_traits_t<decltype(&example::example)>::args
>{});
```

----

###User defined attributes

----

```cpp
class example {
public:
  [[inject]]
  example(double, int); // pick me!

  example(int, double);
  example(int, double, float);
};
```

----

```cpp
class example {
public:
  example([[named("int_a")]] int a, [[named("int_b")]] int b) {
    assert(42 == a);
    assert(87 == b);
  }
};
```

```cpp
auto injector = di::make_injector(
  di::bind<int>.named("int_a").to(42)
, di::bind<int>.named("int_b").to(87)
);
```

==============================================================================

<img style="height: 500px; width: 350px;" src="images/review_manager.jpg" />

==============================================================================

##Questions?

* Documentation
    * http://boost-experimental.github.io/di

* Source Code
    * https://github.com/boost-experimental/di

* Try it online
    * http://boost-experimental.github.io/di/try_it
					</script>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({

        // Display controls in the bottom right corner
        controls: true,

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: true,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
