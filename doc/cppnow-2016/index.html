<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Experimental Boost.DI</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/league.css" id="theme">

		<!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<div class="slides">
          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$"
                   data-notes="^Note:">
					<script type="text/template">

C++Now 2016

# C++14 Dependency Injection Library

https://github.com/boost-experimental/di

Kris Jusiak

==============================================================================

##Dependency Injection

----

(DI) involves passing (injecting) one or more dependencies (or services) to a dependent object (or client) which become part of the client’s state. It is like the Strategy Pattern, except the strategy is set once, at construction. DI enables loosely coupled designs, which are easier to maintain and test

Rob Stewart

----

## "Let's make some coffee!"

<center>[![Coffee Maker](images/coffee_maker.png)](images/coffee_maker.png)</center>

----

##No Dependency Injection

```cpp
class coffee_maker {
public:
  // create dependencies in the constructor
  coffee_maker()
    : heater(std::make_shared<electric_heater>())
    , pump(std::make_unique<heat_pump>(heater))
  { }

  void brew() {
    heater->on();
    pump->pump();
  }

private:
  std::shared_ptr<iheater> heater;
  std::unique_ptr<ipump> pump;
};
```

----

##Dependency Injection

```cpp
class coffee_maker {
public:
  // inject dependencies via constructor
  coffee_maker(std::shared_ptr<iheater> heater
             , std::unique_ptr<ipump> pump)
    : heater(heater), pump(move(pump))
  { }

  void brew() {
    heater->on();
    pump->pump();
  }

private:
  std::shared_ptr<iheater> heater;
  std::unique_ptr<ipump> pump;
};
```

----

##It's all about the construction!

> "Don't call us, we'll call you", Hollywood principle

----

##Do I need Dependency Injection?

----

##Depends...

----

* DI provides loosely coupled code
  * separation of business logic and object creation
* DI provides easier to maintain code
  * different objects might be easily injected
* DI provides easier to test code
  * fakes objects might be injected

==============================================================================

##Do I need a DI Framework/Library?

----

Depending on a project and its scale you may put up with or without a DI library, however, in any project
a DI framework may **free you** from maintaining a following (boilerplate) code...

----

```cpp
auto create() {
  logger logger_;
  renderer renderer_;
  view view_{renderer_, logger_};
  model model_{logger_};
  controller controller_{model_, view_, logger_};
  user user_{logger_};
  ...
  return make_unique<app>(controller, user_, logger_).run();
}
```

----

Notice that **ORDER** in which above dependencies are created is **IMPORTANT** as well as that
**ANY** change in **ANY** of the objects constructor will **REQUIRE** a change in the code!

----

DI library, not only let you forget about maintaining this code,
but also can help you with...

----

* Testing
* Serializing
* Understanding dependencies
* Restricting types

----

Try it yourself online!

----

http://boost-experimental.github.io/di/try_it


----

Still not convinced?

----

Real-life example?

----

Let's make a web match-3 game in C++14

* Model-View-Controller
* Dependency Injection
* Meta State Machine
* Range-V3

---

[Thursday, May 12 / 9:00am - 10:30am](https://cppnow2016.sched.org/event/6Sg4/lets-make-a-web-match-3-game-in-c14-using-dependency-injectionexperimental-boostdi-meta-state-machineexperimental-boostmsm-lite-rangev3-and-msvc-and-emscripten)

---

[https://github.com/modern-cpp-examples/match3](https://github.com/modern-cpp-examples/match3)

==============================================================================

##C++ vs Java vs C# Libraries

----

Writing a DI library in C++ is not an easy task

----

* Performance is important
* Lack of static reflection
* Pointers, References, Rvalues, Smart Pointers, ...
* Qualifiers - const, volatile, ...
* Templates, Concepts, ...

----

###DI Libraries...

----

![Libraries](images/libraries.png)

----

##Benchmarks

----

TODO

----

###More Benchmarks

---

http://boost-experimental.github.io/di/benchmarks

==============================================================================

##Experimental Boost.DI

----

##Design goals

----

* ###Be as fast as possible

  * Boost.DI has none or minimal run-time overhead

----

* ###Compile as fast as possible

  * Boost.DI compiles **faster than Java-Dagger2!**

----

* ###Guarantee object creation at compile-time

  * Boost.DI resolves types at compile-time and gives short and intuitive error messages

----

* ###Be as non-intrusive as possible

  * Boost.DI deduces constructor parameters without reflection

----

* ###Be easy to extend

  * Boost.DI provides easy way to write custom scopes/policies/providers

----

###A bit of history

----

2012 - 2014

---

Version C++98 / C++11 - never released

---

[https://github.com/boost-experimental/di/tree/cpp03](https://github.com/boost-experimental/di/tree/cpp03)

----

* Compiled slowly (Boost.MPL)
* Enormous error messages
* A lot of preprocessor magic (BOOST_PP)
* A lot of workarounds for compilers (MSVC 2013)

----

2014 - Now

---

Version C++14 - v1.0.0

---

[https://github.com/boost-experimental/di](https://github.com/boost-experimental/di)

----

##Overview

----

* One header (boost/di.hpp) / generated
* 3k lines
* Neither Boost nor STL is required
* No 'if' branches
* No 'virtual' methods
* No 'exceptions' (-fno-exceptions)

----

##Tested compilers

----

* [Clang-3.4+](https://travis-ci.org/boost-experimental/di)

* [XCode-6.1+](https://travis-ci.org/boost-experimental/di)

* [GCC-5.2+](https://travis-ci.org/boost-experimental/di)

* [MSVC-2015+](https://ci.appveyor.com/project/krzysztof-jusiak/di)

----

##Quality (per commit)

----

* Travis/Appveyor build on Linux/OS X/Windows
  * Clang-3.4/3.5/3.6/3.7/3.8 (libc++ / stdlibc++)
  * GCC-5
  * MSVC-2015
* Clang static analysis / Clang-tidy (static check)
* Valgrind / Dr. Memory (dynamic memory check)
* Clang-format (style check)

----

* Documentation deployment to 'gh-pages'

----

Tests

----

##99% test code coverage

----

* Unit tests
* Functional tests
* Performance tests (benchmarks)
* Compilation-error tests (validates error message)
* Run-time generation tests (compares generated assembler)

==============================================================================

##Design

----

<img style="height:550px;" src="images/di.png" />

----

* Bindings

  * DSL to create dependencies representation which will be used by core to resolve types

----

* Scopes

  * Responsible for maintain objects life time

----

* Providers

  * Responsible for providing object instance

----

* Policies

  * Compile-time limitations for types / Run-time types visitor

----

* Config

  * Configuration for Policies and Providers

----

##In a nutshell (Pseudo-code)

----

```cpp
template<class TConfig, class... TBindings>
class core::injector {
  template<class T> constexpr auto create() const noexcept {
    TConfig::policies<T>()...;

    auto&& dependency = binder{}.resolve<T>(TBindings...);
    using ctor = ctor_traits<injector, T>();

    return wrapper<T>{
      dependency.create( // create in a dependency scope
        TConfig::provider{}.get<decltype(dependency.impl)>(
          create<ctor>()...))
    };
  }
};
```

==============================================================================

##User Guide

----

###Create objects tree

----

[![Create objects tree](images/tutorial_create_objects_tree.png)](images/tutorial_create_objects_tree.png)

----

```cpp
struct Renderer {
  int device;
};
class View {
public:
  View(std::string title, const renderer&);
};
class Model {};
class Controller {
public:
  Controller(Model&, View&) {}
};
class User {};
class App {
public:
  App(Controller&, User&) {}
};
```

----

The usual approach to create `App` would be following...

----

```cpp
Renderer renderer;
View view{"title", renderer};
Model model;
Controller controller{model, view};
User user;
App app{controller, user};
```

----

And using Boost.DI...

----

```cpp
auto app = di::make_injector().create<App>();
```

----

###Where

----

```cpp
template<class TConfig = di::config, class... TDeps>
  requires configurable<TConfig>() && boundable<TDeps...>()
auto make_injector(TDeps&&...) noexcept;
```

```cpp
template<class... TDeps> requires boundable<TDeps...>()
class injector {
public:
  injector(injector&&) = default;
  explicit injector(TDeps&&...) noexcept;

  template<class T> requires creatable<T>()
  T create() const;
};
```

----

| Type `T` | Is allowed? | Note |
| -------- | ----------- | ---- |
| `T` | ✔ | - |
| `T*` | ✔ | Ownership transfer! |
| `const T*` | ✔ | Ownership transfer! |
| `T&` | ✔ | - |
| `const T&` | ✔ | Reference with [singleton] / Temporary with [unique] |
| `T&&` | ✔ | - |
| `std::unique_ptr<T>` | ✔ | - |
| `std::shared_ptr<T>` | ✔ | - |
| `std::weak_ptr<T>` | ✔ | - |
| `boost_shared_ptr<T>` | ✔ | - |

----

###How is that possible without static reflection?

----

###User-defined/implicit/generic conversion operator

----

```cpp
struct any_type {
  template<class T>
  operator T(); // non explicit
};

int main() {
  struct example {
    example(int, double);
  };

  static_assert(
    std::is_constructible<example, any_type, any_type>::value);
}
```
https://wandbox.com

----

###Limitations

----

It doesn't work for constructor with one parameter!

> Copy constructor / Move constructor

---

> Generic converting constructor
```cpp
class example {
public:
  template<class T>
  example(T); // non explicit
};
```

----

###Let's disable the operator when type T is convertible to the parent type

----

```cpp
template<class TParent>
struct any_type {
  template<class T, class =
    std::enable_if_t<!std::is_convertible<TParent, T>{}>
  > operator T();
};

int main() {
  struct example {
    example(int, double);
  };

  static_assert(
    !std::is_constructible<example, any_type<example>>::value);
}
```
https://wandbox.com

----

###Calculate the number of parameters?

----

```cpp
constexpr auto BOOST_DI_CFG_CTOR_LIMIT_SIZE = 10;

template<class T, std::size_t>
using any_type_t = any_type<T>;

template<class...>
struct is_constructible;

template<class T, std::size_t... Ns>
struct is_constructible<T, std::index_sequence<Ns...>>
  : std::is_constructible<T, any_type_t<T, Ns>...>
{ };
```

----

```cpp
template <class T, std::size_t... Ns>
constexpr auto ctor(std::index_sequence<Ns...>) noexcept {
  auto value = 0;
  int _[]{0, (is_constructible<T, std::make_index_sequence<Ns>>{}
    ? value = Ns : value)...};
  return value;
}

int main() {
  struct example {
    example(int, double, float);
  };

  static_assert(3 == ctor<example>(
    std::make_index_sequence<BOOST_DI_CFG_CTOR_LIMIT_SIZE>{}));
}
```
https://wandbox.com

----

###How it's done in DI?

----

###is braces constructible

----

```cpp
template <class T, class... TArgs>
decltype(void(T{declval<TArgs>()...}), true_type{})
test_is_braces_constructible(int);

template <class, class...>
false_type test_is_braces_constructible(...);

template <class T, class... TArgs>
using is_braces_constructible =
  decltype(test_is_braces_constructible<T, TArgs...>(0));

template <class T, class... TArgs>
using is_braces_constructible_t =
  typename is_braces_constructible<T, TArgs...>::type;

```

```cpp
struct example { int a; int b; };
static_assert(is_braces_constructible<example, any_type, any_type>{});
```

----

###Implementation (Pseudo-code)

----

```cpp
template<class TInjector, class TParent>
struct any_type {
  template<class T, class =
    std::enable_if_t<!std::is_convertible<TParent, T>{}>
  > operator T() {
    return injector_.template create<T>();
  }

  const TInjector& injector_;
};
```

----

```cpp
template<class TInjector, class T> auto ctor_traits() {
  if (has_inject<T>() { // BOOST_DI_INJECT
    return pair<direct, typename T::inject>{};
  }
  for (auto i = BOOST_DI_CFG_CTOR_LIMIT_SIZE; i >= 0; --i) {
    if (is_constructible<T, any_type<TInjector, T>...>())
      return pair<direct, any_type<TInjector, T>...>{};
    }
  }
  for (auto i = BOOST_DI_CFG_CTOR_LIMIT_SIZE; i >= 0; --i) {
    if (is_braces_constructible<T, any_type<TInjector, T>...>())
      return pair<uniform, any_type<TInjector, T>...>{};
    }
  }
  return error(...); // concepts emulation
};
```

----

###Coming back to the design...

----

```cpp
template<class TConfig, class... TBindings>
class core::injector {
  template<class T> constexpr auto create() const noexcept {
    TConfig::policies<T>()...;
    auto&& dependency = binder{}.resolve<T>(TBindings...);

    using ctor = ctor_traits<injector, T>(); // -\
     // pair<direct/uniform, TCtor...>  <--------/

    return wrapper<T>{
      dependency.create( // create in a dependency scope
        TConfig::provider{}.get<decltype(dependency.impl)>(
          create<ctor>()...))
    };
  }
};
```

----

##First steps with bindings

----

###Interfaces...

----

```cpp
class iview {
public:
  virtual ~iview() noexcept = default;
  virtual void update() =0;
};

class gui_view: public iview {
public:
  gui_view(std::string title, const renderer&) {}
  void update() override {}
};

class text_view: public iview {
public:
  void update() override {}
};
```

----

```cpp
auto injector = di::make_injector(
  di::bind<iview>.to<gui_view>() // bind interface to implementation
);
```

```cpp
assert(dynamic_cast<gui_view*>(
  injector.create<std::unique_ptr<iview>().get())
);
```

----

###Values...

----

```cpp
struct T {
  int& a;
  double b;
};
```

```cpp
 auto i = 42;
 auto injector = di::make_injector(
    di::bind<int>.to(i),
    di::bind<double>.to(87.0)
 );
 injector.create<T>(); // will create T{i, 87.0};
```
https://wandbox.com

----

###Dynamic conditions....

----

```cpp
auto use_gui_view = true/false;

auto injector = di::make_injector(
  di::bind<iview>.to([&](const auto& injector) -> iview& {
    if (use_gui_view)
      return injector.template create<gui_view&>();
    else
      return injector.template create<text_view&>();
  })
);
```

```cpp
use_gui_view = true;
assert(dynamic_cast<gui_view*>(
  injector.create<std::unique_ptr<iview>().get())
);

use_gui_view = false;
assert(dynamic_cast<text_view*>(
  injector.create<std::unique_ptr<iview>().get())
);
```

----

###Multi

----

```cpp
class iclient {
 public:
   virtual ~iclient() noexcept = default;
   virtual void process() = 0;
};

class user : public iclient {
 public:
   void process() override {};
};

class timer : public iclient {
 public:
   void process() override {};
};

class app {
 public:
  app(controller&, std::vector<std::unique_ptr<iclient>>);
};
```

And our bindings...

```cpp
di::bind<iclient*[]>.to<user, client>()
```

----

##Short and informative error messages

----

* Concepts emulation

```cpp
#define BOOST_DI_REQUIRES(...) \
  typename enable_if<__VA_ARGS__, int>::type

#define BOOST_DI_REQUIRES_MSG(...) \
  typename concept_check<__VA_ARGS__>::type
```

----

```cpp
template <class T>
struct concept_check {
  static_assert(T::value, "constraint not satisfied");
};

template <>
struct concept_check<true_type> {
  using type = int;
};
```

----

```cpp
auto injector = di::make_injector().create<iview&>();
```

----

###Clang

----

```cpp
error: 'create<app>' is deprecated: creatable constraint not satisfied
  injector.create<app>();
           ^
note: 'create<app>' has been explicitly marked deprecated here
  create
  ^
error: inline function 'abstract_type<iview>::is_not_bound::error'
 error(_ = "type is not bound, did you forget to add:
           'di::bind<interface>.to<implementation>()'?");

note: used here
      return constraint_not_satisfied{}.error();
```

----

###GCC

----

```cpp
error: ‘T injector<...>::create() const [with T = app]’ is deprecated:
  creatable constraint not satisfied
   injector.create<app>();
                        ^
note declared here
   create
   ^
error: inline function ‘T* abstract_type<T>::is_not_bound::error(_)
  [with T = iview]’ used but never defined
  error(_ = "type is not bound, did you forget to add:
            'di::bind<interface>.to<implementation>()'?");
```

----

###MSVC

----

```cpp
error C4996: 'injector<...>::create': creatable constraint not
                                      satisfied
        with
        [
            TConfig=config
        ]
note see declaration of 'injector<...>::create'
        with
        [
            TConfig=config
        ]
error C4506: no definition for inline function
            'iview *abstract_type<T>::is_not_bound::error(_)'
        with
        [
            T=iview
        ]
```

----

###BOOST DI CFG DIAGNOSTICS LEVEL

----

| Value | Description |
| ------------------------------ | ----------- |
| 0                              | 1 line error |
| 1 (default)                    | as `0` + info why type couldn't be created + suggestion how to fix it |
| 2                              | as `1` + call stack creation hierarchy |

----

##BOOST DI CFG DIAGNOSTICS LEVEL=0

----

```cpp
error: 'create<app>' is deprecated: creatable constraint not satisfied
```

----

##BOOST DI CFG DIAGNOSTICS LEVEL=1

----

```cpp
error: 'create<app>' is deprecated: creatable constraint not satisfied
  injector.create<app>();

error: inline function 'abstract_type<iview>::is_not_bound::error'
 error(_ = "type is not bound, did you forget to add:
           'di::bind<interface>.to<implementation>()'?");
```
----

##BOOST DI CFG DIAGNOSTICS LEVEL=2

----

```cpp
error: 'create<app>' is deprecated: creatable constraint not satisfied

error: function ‘T creating<T>::type(_) [with T = app]’
error: function ‘T creating<T>::type(_) [with T = controller]’

error: inline function 'abstract_type<iview>::is_not_bound::error'
 error(_ = "type is not bound, did you forget to add:
           'di::bind<interface>.to<implementation>()'?");
```

----

###How?

----

Linking error + warning (inline function is not defined)

----

```cpp
template <class T>
struct abstract_type {
  struct is_not_bound {
    operator T*() const {
      using constraint_not_satisfied = is_not_bound;
      return constraint_not_satisfied{}.error();
    }
    // clang-format off
    static inline T*
      error(_ = "type is not bound, did you forget to add:
          'di::bind<interface>.to<implementation>()'?");
    // clang-format on
  };
```

----

Trigger the error

----

```cpp
#pragma clang diagnostic error "-Wundefined-inline"
```

----

```cpp
  template <class T
, BOOST_DI_REQUIRES(is_creatable<T, no_name, aux::true_type>{})>
  T create() const {
    return create_successful_impl<aux::true_type>(aux::type<T>{});
  }

  template <class T
, BOOST_DI_REQUIRES(!is_creatable<T, no_name, aux::true_type>{})>
  BOOST_DI_DEPRECATED("creatable constraint not satisfied")
  T create() const {
    return create_impl<aux::true_type>(aux::type<T>{});
  }
```


----

##Decide the life times

----

| Type | Scope |
|------|-------|
| T | [unique] |
| T& | [singleton] |
| const T& | [unique] (temporary) / [singleton] |
| T* | [unique] (ownership transfer) |
| const T* | [unique] (ownership transfer) |
| T&& | [unique] |
| std::unique_ptr<T> | [unique] |
| std::shared_ptr<T> | [singleton] |
| boost::shared_ptr<T> | [singleton] |
| std::weak_ptr<T> | [singleton] |

Well, `Boost.DI` supports scopes which are response for maintaining the life time of created objects.
By default there are 4 scopes

* deduce scope (default)
* instance scope (bind<>.to(value) where value is maintained by the user)
* unique scope (one instance per request)
* singleton scope (shared instance)

----

| Type | Scope |
|------|-------|
| T, T&&, const T&, T*, std::unique_ptr<T> | unique |
| const T&, T&, std::shared_ptr<T>, boost::shared_ptr<T>, std::weak_ptr<T> | singleton |

----

Changing the scope for given type.

```cpp
auto injector = di::make_injector(
  di::bind<iview>.to<gui_view>().in(di::singleton) // explicitly
);
```

What if I want to change `gui_view` to be a different instance per each request. Let's change the scope to [unique] then.

```cpp
auto injector = di::make_injector(
  di::bind<iview>.to<gui_view>().in(di::unique)
);
```

----

##Annotations to the rescue

----

```cpp
class model {
 public:
   model(int size, double precision) { }
   model(int rows, int cols) { }
};
```

We can't create `model` due to constructor ambiguity.

```cpp
di::make_injector().create<model>(); // compile error
```

----

Names...

```cpp
auto Rows = []{};
auto Cols = []{};
```

```cpp
class model {
 public:
   model(int size, double precision) { }

   BOOST_DI_INJECT(model, (named = Rows) int rows
                        , (named = Cols) int cols);
};

model::model(int rows, int cols) {}
```

----

Finally, we have to bind our values.

```cpp
auto injector = di::make_injector(
  di::bind<int>.named(Rows).to(6)
, di::bind<int>.named(Cols).to(8)
);

di::make_injector().create<model>(); // OKAY
```

----

##Split your configuration

----

But my project has hundreds of interfaces and I would like to split my bindings into separate components.

Let's split our configuration then and keep our `model` bindings separately from `app` bindings.

----

```cpp
auto model_module = [] {
  return di::make_injector(
    di::bind<int>.named(Rows).to(6)
  , di::bind<int>.named(Cols).to(8)
  );
};
```

----

```cpp
auto app_module = [](const bool& use_gui_view) {
  return di::make_injector(
    di::bind<iview>.to([&](const auto& injector) -> iview& {
      if (use_gui_view)
        return injector.template create<gui_view&>();
      else
        return injector.template create<text_view&>();
    })
  , di::bind<timer>.in(di::unique) // different per request
  , di::bind<iclient*[]>().to<user, timer>() // bind many clients
  );
};
```

----

And glue them into one injector the same way...

```cpp
  auto injector = di::make_injector(
    model_module()
  , app_module(use_gui_view)
  );
```

----

But I would like to have a module in `cpp` file, how can I do that?

```cpp
di::injector<model&> model_module() {
  return di::make_injector(
    di::bind<int>.named(Rows).to(6)
  , di::bind<int>.named(Cols).to(8)
  );
}
```

----

```cpp
di::injector<app> app_module(const bool& use_gui_view) {
  return di::make_injector(
    di::bind<iview>.to([&](const auto& injector) -> iview& {
      if (use_gui_view)
        return injector.template create<gui_view&>();
      else
        return injector.template create<text_view&>();
    })
  , di::bind<timer>.in(di::unique) // different per request
  , di::bind<iclient*[]>.to<user, timer>() // bind many clients
  , model_module()
  );
}
```

----

```cpp
  auto injector = di::make_injector(
    model_module()
  , app_module(use_gui_view)
  );

  injector.create<app>();
```

----

##Extensions

----

serialziation

----

is_constructible

----

print types/uml

----

mocks injector

==============================================================================

##Performance

----

###Environment

----

2.3 GHz Intel Core i7 / 16 GB 1600 Mhz DDR3

----

##Run-time

----

###Bind type to value

----

```cpp
#include <boost/di.hpp>

namespace di = boost::di;

auto test() {
  auto injector = di::make_injector(
    di::bind<int>.to(42)
  );

  return injector.create<int>();
}
```

----

###ASM x86-64

```
mov $0x2a,%eax
retq
```

Same as...

```
return 42;
```


----

###How?

----

No run-time branches as everything is known at compile time and might be optimized!

----

```cpp
injector.create<int>();  ---------------\
  create_successful_impl(type<int>());  |   mov $0x2a,%eax
      scope.create<int>(provider);      |-  retq
        provider.get<int>();            |
          return 42; -------------------/
```

----

###Bind interface to implementation

----

```cpp
#include <boost/di.hpp>

namespace di = boost::di;
auto test() {
  auto injector = di::make_injector(
    di::bind<interface>.to<implementation>()
  );

  return injector.create<std::unique_ptr<interface>>();
}
```

----

###ASM x86-64

```
push   %rbx
mov    %rdi,%rbx
mov    $0x8,%edi
callq  0x4009f0 <_Znwm@plt>
movq   $0x400e78,(%rax)
mov    %rax,(%rbx)
mov    %rbx,%rax
pop    %rbx
retq
```

Same as...

```cpp
return std::make_unique<implementation>();
```

----

##Compile-time

----

###Include DI header

----

```cpp
#include <boost/di.hpp>

int main() {}
```

0.050s

> Nighter STL nor Boost is used

----

![Performance](images/performance.png)

```cpp
* 4248897537 instances created
* 132 different types
* 10 modules
```

----

##Speed up compilation times

----

###Always measure!

----

###Guidelines

----

###Avoid template instantiations

----

###Avoid recursive template algorithms

----

###Do checks once and as early as possible

----

###Avoid long type names (variadic templates)

----

###Use compiler built-ins and common tricks to gain performance

```cpp
template<bool...> struct bool_seq;

template<class... Ts>
using and_ = std::is_same<
    bool_seq<Ts::value...>,
    bool_seq<(Ts::value, true)...>
>;
```

```cpp
__make_index_seq is O(1) since Clang 3.9
```

----

###Implementation

----

###Resolve

----

```cpp
template<class T>
struct dependency_concept { };

template<class I, class Impl>
struct dependency : pair<dependency_concept<I>, dependency<I, Impl>> { };

template<class... Ts>
struct injector : Ts...  { };

template<class... Ts>
auto make_injector(Ts...) {
  return injector<Ts...>{};
}
```

----

```cpp
struct binder {
  template <class TDefault, class>
  static TDefault resolve_impl(...) noexcept { return {}; }

  template <class, class TConcept, class TDependency>
  static decltype(auto)
  resolve_impl(pair<TConcept, TDependency>* dep) noexcept {
    return static_cast<TDependency&>(*dep);
  }

  template <class T, class TDefault, class TDeps>
  static decltype(auto) resolve(TDeps* deps) noexcept {
    using dependency = dependency_concept<std::decay_t<T>>;
    return resolve_impl<TDefault, dependency>(deps);
  }
};
```

----

```cpp
auto injector = make_injector(dependency<i1, impl1>{});

struct default_dependency{};

static_assert(std::is_same<dependency<i1, impl1>,
  std::decay_t<decltype(
    binder{}.resolve<i1, default_dependency>(&injector))
  >>{}
);

static_assert(std::is_same<default_dependency,
  std::decay_t<decltype(
    binder{}.resolve<i2, default_dependency>(&injector)
  )>>{}
);
```
https://wandbox.com

----

###Resolve - Benchmarks

----

| Number of dependencies | Resolve time (middle dependency) |
| ---------------------- | -------------------------------- |
| 1                      | 0.077s                           |
| 16                     | 0.079s                           |
| 32                     | 0.082s                           |
| 64                     | 0.083s                           |
| 128                    | 0.089s                           |

----

###Creatable Concept

----

###Idea

----

```cpp
                            creatable<T>
                           (make it lite)
                                 |
                  /--------------+-----------------\
                Yes                                No
                 |                                 |
        create_successful_impl                  create_impl
```

----

```cpp
  template <class T> requires creatable<T>()
  T create() const {
    // no checks for errors!
    return create_successful_impl(type<T>{});
  }

  template <class T> requires !creatable<T>()
  [[deprecated("creatable constraint not satisfied")]]
  T create() const {
    // checks for errors to report it
    return create_impl(type<T>{});
  }
```

----

###'Name' erasure

----

Long type names may increase your compilation times a LOT!

----

```cpp
template<class... Ts> auto make_injector(Ts... args) {
  return injector<Ts...>(args...); // may produces a long type name
}

auto injector = make_injector(...);
injector.create<T>(); // slow to compile
                      // a lot of long type names comparisons
```

----

###Solution - inheritance

----

```cpp
auto injector = di::make_injector(...);

struct erase_long_type_name : decltype(injector) {
  using decltype(injector)::injector;
};

erase_long_type_name{injector}.create<T>(); // quick to compile
                                            // type name =>
                                            // erase_long_type_name
```

----

###Solution - lambda expression

----

```cpp
static auto make_injector_impl = [](auto injector) {
  using injector_t = decltype(injector);

  struct i : injector_t {
    explicit i(injector_t&& other)
      : injector_t(std::move(other)) { }
  };

  return i{std::move(injector)};
};
```

----

###'Name' erasure - Benchmark

----

| Solution                         | Number of bindings | Time    |
| -------------------------------- | ------------------ | ------- |
| Long type name                   | 256                | 5.321s  |
| Name erasure / inheritance       | 256                | 2.521s  |
| Name erasure / lambda expression | 256                | 3.278s  |

----

##More Benchmarks...

----

http://boost-experimental.github.io/di/overview

==============================================================================

##DI vs ISO C++

----

###Static reflection

----

###Deduction of constructor parameters

----

```cpp
class example {
public:
  example(int, double);
};

static_assert(is_same<
  std::tuple<int, double>
, std::function_traits_t<decltype(&example::example)>::args
>{});
```

----

###User defined attributes

----

```cpp
class example {
public:
  [[inject]]
  example(double, int); // pick me!

  example(int, double);
  example(int, double, float);
};
```

----

```cpp
class example {
public:
  example([[named("int_a")]] int a, [[named("int_b")]] int b) {
    assert(42 == a);
    assert(87 == b);
  }
};
```

```cpp
auto injector = di::make_injector(
  di::bind<int>.named("int_a").to(42)
, di::bind<int>.named("int_b").to(87)
);
```

==============================================================================

<img style="height: 500px; width: 350px;" src="images/review_manager.jpg" />

==============================================================================

##Questions?

* Documentation
    * http://boost-experimental.github.io/di

* Source Code
    * https://github.com/boost-experimental/di

* Try it online
    * http://boost-experimental.github.io/di/try_it
					</script>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({

        // Display controls in the bottom right corner
        controls: true,

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: true,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
