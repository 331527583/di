[/
 /
 / Copyright (c) 2014 Krzysztof Jusiak (krzysztof at jusiak dot net)
 /
 / Distributed under the Boost Software License, Version 1.0.
 / (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /
 /]

[section Modules]

[heading Description]
Modules allow to split the configuration into smaller injectors.
Module is a type with `configure` method returning __injectors_injector__ type.
Activation of `Module` is done by passing it into injector.

[heading Synopsis]
    class module {
    public:
        auto configure() const noexcept {
            return __di_make_injector__(...);
        }
    };

    class module_exposed {
    public:
        __di_injector__<interface> configure() const noexcept {
            return __di_make_injector__(...);
        }
    };

[table Parameters
    [[Parameter][Requirement][Description][Returns][Throw]]
    [[`configure()`][None][Create bindings configuration][__di_make_injector__<...>][Does not throw]]
]

[heading Expression Semantics]
    __di_make_injector__(module{})

[*Return type]: `__di_injector__<...>`

[heading Header]
    #include <__di_hpp__>

[heading Examples]
    class module {
    public:
        auto configure() const noexcept {
            return __di_make_injector__(
                __di_bind__<int>.to(42)
              , __di_bind__<interface1, implementation1>
            );
        }
    };

    class exposed_module {
    public:
        di::injector<complex> configure() const noexcept {
            return __di_make_injector__(
                __di_bind__<interface2, implementation2>
            );
        }
    };

    auto injector = __di_make_injector__(
        module{}, exposed_module{}
        // exposed_module{}, module{} // order of passed modules is not important
    );

    assert(dynamic_cast<implementation1*>(injector.__di_injector_create__<unique_ptr<interface1>>().get()));
    assert(42 == injector.__di_injector_create__<int>());
    injector.__di_injector_create__<complex>(); // okay
    injector.__di_injector_create__<unique_ptr<interface2>>(); // compile error, only `complex` was exposed by module

[tip `__modules__/__bindings__` might be mixed whilst creating an injector, order is not important.]

[heading More Examples]
    ``__examples_modules__`` | ``__more_examples_modules_hpp_cpp__``

[heading See Also]

* __injectors__
* __injectors_injector__
* __injectors_make_injector__

[endsect]

