[/
 /
 / Copyright (c) 2014 Krzysztof Jusiak (krzysztof at jusiak dot net)
 /
 / Distributed under the Boost Software License, Version 1.0.
 / (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /
 /]

[section Rationale]

`Boost.DI` design was driven by few main goals:

* User interface should be compact and eliminate boilerplate code as much as possible (common things should be achieved in easy way and harder should be possible)
    * achieved with automatic scopes deduction/automatic interface deduction

```
    class example {
    public:
        example(std::shared_ptr<i>);
    };
```

```
    Dependency configuration and creation.

        di::make_injector(di::deduce<impl>()).create<example>();

            equals...

        di::make_injector(di::bind<i, impl>()).create<example>();

            equals...

        di::make_injector(di::shared<di::bind<i, impl>>()).create<example>();
```

* Dependencies should be resolved during compilation time (no runtime exceptions that dependency can't be resolved)
    * achieved with compile time dependency resolving

* Constructor injection should be as less intrusive as possible
    * see [link constructor_injection Constructor Injection]

* Creation overhead should be as small as possible
    * achieved with compile time dependency resolving to minimize runtime overhead

* Binding front end should be easily extensible
    * achieved with `Dependency` class, user interface for binding has to return list of `Dependency` classes

and maybe the most important that `Boost.DI` shouldn't be a copy of existing frameworks for Java and other languages like `Google Guice`
and use whole potential of `C++` instead whilst not ignoring useful concepts in the same time.

[section Design]
Having core feature - `constructor injection` in place `Boost.DI` design presents as follows.

[@images/di.png [$images/di.png [width 75%] [height 75%] ]]
Generated with [@http://plantuml.sourceforge.net PlantUML].

[note During implementation of `Boost.DI` a lot of concepts were checked
and a many approaches were taken. To track different design's
please refer to commits history.]

`Boost.DI` architecture.

[table
    [ [Component] [Description] ]
    [ [Core] [Responsible for resolving requested types (implementation detail)] ]
    [ [Concepts] [DSL to create dependencies representation which will be used by core to resolve types] ]
    [ [Scopes] [Responsible for maintain objects life time] ]
    [ [Wrappers] [Responsible for conversion to required type] ]
    [ [Policies] [Compile time assertions for types] ]
]

[#constructor_injection]
Having above in mind, main concern was related how to make constructor injection as less intrusive as possible (avoid macros/registration/reflection).
Problem was solved purely in `C++` with.

* Verifying how many arguments constructor has using `has_ctor`
* Conversion to requested type using `type conversion operator`

```
struct any_type {
    template<typename U> operator U();
};

template<typename T, typename... TArgs>
struct has_ctor {
    template<typename U> static yes_tag test(decltype(U(TArgs()...)*);
    template<typename> static no_tag test(...);

    static const bool value = sizeof(test<T>(0)) == sizeof(yes_tag);
};

class injector {
public:
    template<typename T>
    T create(enable_if<has_ctor<T, any_type...>>::type* = 0) const {
        return T(any_type()...);
    }
};

struct example {
    example(int i, int double) { }
};

injector().create<example>();
```
[note Purpose of above pseudo code is to illustrate basic idea, if you interested in the implementation details take a look into `Boost.DI` source code.]

Approach presented above although meet all the requirements cause a lot of tricky issues as well, which are listed below.

[h5 Constructor Parameters Deduction]

# for type T
    # for N = 1 to `BOOST_DI_CFG_CTOR_LIMIT_SIZE`
    # if T has constructor with N parameters (which might be converted using `conversion operator`) (see `has_ctor`) then goto `2`
# generate list of `any_type` with N elements which represents constructor parameters (notice that `any_type` is convertible to actual constructor parameter)

[table
    [[Tests: [@test/ut/type_traits/has_ctor_ut.cpp] | [@test/ut/type_traits/ctor_traits_ut.cpp]]]
]

[h5 Binding Resolution Algorithm]

# for type T
    # set `current_weight` to 0 and `best_dependency` to default dependency (TDefault)
    # for all given dependencies
        # if `dependency` scope is set to `deduce` rebind it accordingly to one of non virtual scopes (using `scope traits - see deduce scope`)
        # for all given dependency requirements (TBind) calculate weight
            # `weight` = requirement1 * 10, requirement2 * 100, ..., requirementN * (N times 10)
        # if `weight` > `current_weight`
            # set `current_weight` to `weight`
            # set `best_dependency` to `dependency`
    # return `best_dependency`

[table
    [[Tests: [@test/ut/core/binder_ut.cpp]]]
]

[h5 Type Creation Algorithm]

# for type T
    # get constructor parameters
        # if T has `constructor` traits (set using `BOOST_DI_INJECT`)
            # get `constructor` parameters from traits
        # else
            # deduce `constructor` using `Constructor Parameters Deduction`
    # create T with `constructor` parameters T(`constructor parameters`...)
        # for all `constructor` parameters resolve best dependency using `Binding Resolution Algorithm`
            # allocate required type and pass it to `dependency` scope
            # return wrappered type from scope which is converted to actual constructor parameter

[table
    [[Tests: [@test/ut/core/creator_ut.cpp] | [@test/ut/injector_ut.cpp] | [@test/mt/core/module_mt.cpp] | [@test/mt/injector_mt.cpp] | [@test/mt/make_injector_mt.cpp]]]
]

[endsect]

[include performance.qbk]

[section Notes]

* Ambiguous constructors with the same - longest - number of parameters
[table
    [[Issue][Solution]]
    [
        [
            ```
                                                                      .
            struct example {
                explicit example(int);
                example(int, double);
                example(int, double, float); // ambiguity
                example(int, float, double); // ambiguity
            };
            ```
        ]
        [
            ```
                                                                                                         .
            use BOOST_DI_INJECT to point which constructor should be chosen by Boost.DI
                struct example {
                    explicit example(int);
                    example(int, double);
                    example(int, double, float);
                    BOOST_DI_INJECT(example, int, float, double);
                };
            ```
        ]
    ]
]

* Constructor with variadic number of parameters
[table
    [[Issue][Solution]]
    [
        [
            ```
                                                                      .
            struct example {
                template<typename... TArgs>
                explicit example(TArgs&&...);
            };
            ```
        ]
        [
            ```
                                                                                                         .
            use BOOST_DI_INJECT_TRAITS to define the constructor
                namespace boost { namespace di {
                    template<>
                    struct ctor_traits<example> {
                        BOOST_DI_INJECT_TRAITS(int, double); // or in definition of the class
                    };
                }} // boost::di
            ```
        ]
    ]
]


* Copy constructors
[table
    [[Issue][Solution]]
    [
        [
            ```
                                                                      .
            struct example {
                example(const example&);
                example(int); // ambiguous in c++03
            };
            ```
        ]
        [
            ```
                                                                                                         .
            In C++11 copy constructors ambiguity might be disabled using default template parameters
                template<
                    typename U
                  , typename = typename disable_if<is_same_base_of<T, U>>::type
                >
                operator U();

            In C++03 constructor has to be explicitly pointed out
            struct example {
                example(const example&);
                BOOST_DI_INJECT(example, (int)); // ok in c++03
            };

            Or by adding dummy parameter to the constructor
            struct example {
                example(const example&);
                example(int, int = 0); // ok in c++03
            };
            ```
        ]
    ]
]

* Constructor with non-copyable types
[table
    [[Issue][Solution]]
    [
        [
            ```
                                                                      .
            struct example {
                 // moveable types are supported
                example(std::auto_ptr<int>, std::unique_ptr<int>);
            };
            ```
        ]
        [
            ```
                                                                                                         .
            struct any_type {
                template<typename U> operator U();
                template<typename U> operator aux::auto_ptr<U>&(); // for std::auto_ptr
            };
            ```
        ]
    ]
]

* Constructor with types which have `conversion constructor`
[table
    [[Issue][Solution]]
    [
        [
            ```
                                                                      .
            template<typename>
            struct example {
                template<typename T>
                example(T);
            };

            struct app {
                app(example<int>);
            };
            ```
        ]
        [
            ```
                                                                                                         .
            use BOOST_DI_INJECT to explicitly point out the constructor parameters
                struct app {
                    BOOST_DI_INJECT(app, example<int>);
                };

            make example constructor explicit if possible
                template<typename>
                struct example {
                    template<typename T>
                    explicit example(T);
                };

            if conversion constructor might be disabled, might be worth to do so
            boost::function has a conversion constructor from any type but integral types
                template<>
                struct is_integral<any_type>
                    : mpl::true_
                { };
            ```
        ]
    ]
]

* Inheriting constructors
[table
    [[Issue][Solution]]
    [
        [
            ```
                                                                      .
            struct a {
                a(int, double);
                a(int, double, float);
            };

            struct b : a {
                using a::a;
            };

            struct app {
                app(b);
            };
            ```
        ]
        [
            ```
                                                                                                         .
            Support without any workarounds
            ```
        ]
    ]
]

* `BOOST_DI_INJECT` and default parameters
[table
    [[Issue][Solution]]
    [
        [
            ```
                                                                      .
            struct example {
                BOOST_DI_INJECT(explicit example
                              , int = 0
                              , double = 0.0);
            };
            ```
        ]
        [
            ```
                                                                                                         .
            BOOST_DI_INJECT creates a function instead of direct traits
                struct example {
                    static void boost_di_injector__(int = 0, double = 0.0);
                    explicit example(int = 0, double = 0.0);
                };

                paramter_types<decltype(&example::boost_di_injector__)>::type -> mpl::vector<int, double>
            ```
        ]
    ]
]

* `BOOST_DI_INJECT` with inheritance
[table
    [[Issue][Solution]]
    [
        [
            ```
                                                                      .
            struct a {
                BOOST_DI_INJECT(a, int, double);
            };

            struct b : a { };

            std::make_unique<b>(); // error b doesn't have
                                   // constructor with 2 parameters
            ```
        ]
        [
            ```
                                                                                                         .
            use BOOST_DI_INJECT or BOOST_DI_INJECT_TRAITS to explicitly point that constructor is empty

            struct a {
                BOOST_DI_INJECT(a, int, double);
            };

            struct b : a {
                BOOST_DI_INJECT_TRAITS(); // or BOOST_DI_INJECT(b);
            };

            std::make_unique<b>();
            ```
        ]
    ]
]

* Function parameters evaluation order with shared binding
[table
    [[Issue][Solution]]
    [
        [
            ```
                                                                      .
            struct a { a(int); };
            struct b { b(aux::shared_ptr<a>); };

            // parameters evaluation order is not specified
            struct c { c(aux::shared_ptr<a>, aux::shared_ptr<b>); };

            di::make_injector(
                bind<int>::when<call_stack<a>>::to(42)
              , shared<a>
            );
            ```
        ]
        [
            ```
                                                                                                         .
            be aware and avoid binding which may be affected by parameters evaluation order
            ```
        ]
    ]
]

[table
    [[Tests: [@test/vt/compiler_support_vt.cpp]]]
]

[warning GCC/Clang/MSVC/Intel compilers differ with they way template conversion operator is handled.]
[endsect]


[endsect]

