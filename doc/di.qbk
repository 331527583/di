[/
 /
 / Copyright (c) 2012-2013 Krzysztof Jusiak (krzysztof at jusiak dot net)
 /
 / Distributed under the Boost Software License, Version 1.0.
 / (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /
 /]

[library Boost.DI (Dependency Injection)
    [quickbook 1.5]
    [version 1.0]
    [id di]
    [copyright 2012 2013 Krzysztof Jusiak]
    [authors [Jusiak, Krzysztof]]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
    [source-mode c++]
]

[section Introduction]
[endsect]

[section Hello World]
[endsect]

[section Construction]

[section BOOST_DI_CTOR]
[endsect]

[section BOOST_DI_CTOR_TRAITS]
[endsect]

[section BOOST_DI_CREATE]

[section factory]
[endsect]

[endsect]

[section di::ctor_traits]
[endsect]

[section di_ctor_traits.py]
[endsect]

[endsect]

[section Injector]

[section create]
[endsect]

[section visit]
text visitor
uml visitor
[endsect]

[section call]
[endsect]

[section make_injector]
[endsect]

[endsect]

[section Concepts]

[section bind]
[endsect]

[section scope]
[endsect]

[section call_stack]
[endsect]

[section named]
[endsect]

[section provider]
[endsect]

[endsect]

[section Scopes]

[section deduce]
[endsect]

[section per_request]
[endsect]

[section singleton]
[endsect]

[section session]
[endsect]

[section external]
[endsect]

[section custom_scope]
[endsect]

[endsect]

[section Policies]

[section arguments_permission]
[endsect]

[section binding_correctness]
[endsect]

[section circular_dependencies]
[endsect]

[section creation_ownership]
[endsect]

[endsect]

[section Testing]
[endsect]

[section Tweaking]
    -DBOOST_MPL_CFG_NO_PREPROCESSED_HEADERS -DBOOST_MPL_LIMIT_VECTOR_SIZE=30
    BOOST_DI_CTOR_CFG_VA_ARGS || BOOST_DI_CTOR_CFG_BRACKET
    #define BOOST_DI_CONSTRUCTOR boost_di_constructor__
    #define BOOST_DI_CREATE boost_di_create__
[endsect]

[section Reference]

[section Header <boost/di.hpp>]
This header exists simply as a convenience to the user, including all of the headers in the boost/di directory.

    // ctor
    #include "boost/di/ctor.hpp"

    // concepts
    #include "boost/di/concepts.hpp"

    // scopes
    #include "boost/di/scopes/deduce.hpp"
    #include "boost/di/scopes/external.hpp"
    #include "boost/di/scopes/per_request.hpp"
    #include "boost/di/scopes/session.hpp"
    #include "boost/di/scopes/singleton.hpp"

    // injector
    #include "boost/di/injector.hpp"
    #include "boost/di/make_injector.hpp"

    // utilities
    #include "boost/di/named.hpp"
    #include "boost/di/provider.hpp"

    // policies
    #include "boost/di/policies/arguments_permission.hpp"
    #include "boost/di/policies/binding_correctness.hpp"
    #include "boost/di/policies/circular_dependencies.hpp"
    #include "boost/di/policies/creation_ownership.hpp"

[endsect]

[section Header <boost/di/concepts.hpp>]

    namespace boost {
    namespace di {

    template<typename TExpected, typename TGiven = TExpected>
    struct bind;

    template<int N>
    struct bind_int;

    template<typename T>
    struct bind_string;

    template<typename TScope>
    struct scope;

    template<typename... T>
    struct deduce;

    template<typename... T>
    struct per_request;

    template<typename... T>
    struct singleton;

    template<typename... T>
    struct session;

    template<typename... T>
    struct call_stack;

    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/ctor.hpp>]
    BOOST_DI_CTOR_TRAITS(...)

    BOOST_DI_CTOR(type, ...)

[endsect]

[section Header <boost/di/injector.hpp>]

    namespace boost {
    namespace di {

    template<typename...>
    class injector {
    public:
        typedef unspecified deps;
        typedef unspecified policies;

        template<typename... TArgs>
        explicit injector(const TArgs&...);

        template<typename... TArgs>
        injector<TArgs...> operator()(const TArgs&...);

        template<typename T>
        T create();

        template<typename T, typename TVisitor>
        T create(const TVisitor&);

        template<typename TAction>
        void call(const TAction&);
    };

    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/make_injector.hpp>]

    namespace boost {
    namespace di {

    template<typename... T>
    injector<T...> make_injector(const T...&);

    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/named.hpp>]

    namespace boost {
    namespace di {

    template<
        typename T
      , typename TName = void
      , typename = void
    >
    class named {
    public:
        typedef T named_type;
        typedef TName name;

        template<typename U>
        struct rebind
        {
            typedef named<U, TName> other;
        };

        named(T object = T()); //non explicit

        operator T() const;
        operator T&();
    };

    template<
        typename T
      , typename TName = void
      , typename enable_if<is_smart_ptr<T> >::type
    >
    class named {
        typedef typename T::element_type element_type;

    public:
        typedef T named_type;
        typedef TName name;

        template<typename U>
        struct rebind
        {
            typedef named<U, TName> other;
        };

        named(T = T()); //non explicit

        named(element_type*); // non explicit

        operator T() const;
        element_type* operator->() const;
        element_type& operator*() const;
        element_type* get() const;

        void reset();
        void reset(element_type*);
    };

    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/provider.hpp>]

    namespace boost {
    namespace di {

    template<typename T>
    class provider {
    public:
        virtual ~provider();
        virtual T get() const = 0;
    };

    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/scopes/deduce.hpp>]

    namespace boost {
    namespace di {
    namespace scopes {

    class deduce {
    public:
        template<typename, typename>
        class scope { };
    };

    } // namespace scopes
    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/scopes/external.hpp>]

    namespace boost {
    namespace di {
    namespace scopes {

    template<
        template<typename> class TConvertible = convertibles::value
    >
    class external {
    public:
        typedef unspecified is_priority;

        template<typename TExpected, typename = TExpected>
        class scope {
        public:
            typedef TConvertible<TExpected> result_type;

            template<typename T>
            explicit scope(const T&);

            template<typename... T>
            result_type create(const T&...);
        };
    };

    } // namespace scopes
    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/scopes/per_request.hpp>]

    namespace boost {
    namespace di {
    namespace scopes {

    template<
        template<typename> class TConvertible = convertibles::copy
    >
    class per_request {
    public:
        template<typename TExpected, typename = TExpected>
        class scope {
        public:
            typedef TConvertible<TExpected> result_type;

            template<typename... T>
            result_type create(const T&...);
        };
    };

    } // namespace scopes
    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/scopes/session.hpp>]

    namespace boost {
    namespace di {
    namespace scopes {

    template<
        template<typename> class TConvertible = convertibles::shared
    >
    class session {
    public:
        template<typename TExpected, typename = TExpected>
        class scope {
        public:
            typedef TConvertible<TExpected> result_type;

            template<typename... T>
            result_type create(const T&...);
        };
    };

    } // namespace scopes
    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/scopes/singleton.hpp>]

    namespace boost {
    namespace di {
    namespace scopes {

    template<
        template<typename> class TConvertible = convertibles::shared
    >
    class singleton {
    public:
        template<typename TExpected, typename = TExpected>
        class scope {
        public:
            typedef TConvertible<TExpected> result_type;

            template<typename... T>
            result_type create(const T&...);
        };
    };

    } // namespace scopes
    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/policies/arguments_permission.hpp>]

    namespace boost {
    namespace di {
    namespace policies {

    struct allow_smart_ptrs;
    struct allow_refs;
    struct allow_rvalue_refs;
    struct allow_ptrs;
    struct allow_copies;

    template<typename... T>
    class arguments_permission {
    public:
        typedef unspecified is_policy;

        template<typename TDeps, typename TGiven>
        struct verify;
    };

    } // namespace policies
    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/policies/binding_correctness.hpp>]

    namespace boost {
    namespace di {
    namespace policies {

    template<typename... T>
    class binding_correctness {
    public:
        typedef unspecified is_policy;

        template<typename TDeps, typename TGiven>
        struct verify;
    };

    } // namespace policies
    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/policies/circular_dependencies.hpp>]

    namespace boost {
    namespace di {
    namespace policies {

    template<typename... T>
    class circular_dependencies {
    public:
        typedef unspecified is_policy;

        template<typename TDeps, typename TGiven>
        struct verify;
    };

    } // namespace policies
    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/policies/creation_ownership.hpp>]

    namespace boost {
    namespace di {
    namespace policies {

    template<typename... T>
    class creation_ownership {
    public:
        typedef unspecified is_policy;

        template<typename TDeps, typename TGiven>
        struct verify;
    };

    } // namespace policies
    } // namespace di
    } // namespace boost

[endsect]

[endsect]

[section Tested/Supported by compilers]
* GCC 4.7.3/4.8.1
* Clang 3.2/3.3
* Intel C++ 14.0.0
* MinGW 4.7.3/4.8.1
* Visual Studio 2013 RC
[endsect]

[endsect]

