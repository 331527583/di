[/
 /
 / Copyright (c) 2012-2013 Krzysztof Jusiak (krzysztof at jusiak dot net)
 /
 / Distributed under the Boost Software License, Version 1.0.
 / (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /
 /]

[library Boost.DI (Dependency Injection)
    [quickbook 1.5]
    [version 1.0]
    [id di]
    [copyright 2012 2013 Krzysztof Jusiak]
    [authors [Jusiak, Krzysztof]]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
    [source-mode c++]
]

[def __BOOST_DI_CTOR [link di.reference.ctor `BOOST_DI_CTOR `]]

[section Overview]

"Google Guice"
"With dependency injection, objects accept dependencies in their constructors. To construct an object, you first build its dependencies. But to build each dependency, you need its dependencies, and so on. So when you build an object, you really need to build an object graph.
Building object graphs by hand is labour intensive, error prone, and makes testing difficult. Instead, Guice can build the object graph for you. 

Motivation
https://code.google.com/p/google-guice/wiki/Motivation

Description

* supports dependency injection by constructors
* supports scopes (deduce, per_request, singleton, session) + custom scopes
* supports scope deduction from parameter (by default, ex: shared_ptr -> singleton, unique_ptr, lvalue -> per_request)
* supports C++03 and C++11 standard
* supports c++11 smart pointers, rvalue references and combinations between boost and std smart pointers
* supports named parameters (named<int, my_int>>
* supports creation of dynamic dependent factories
* supports binding external values (passed by the client)
* supports generation of constructor traits via python script using clang (to avoid using BOOST_DI_CTOR macro)
* supports compile time policies (circular dependencies, creation ownership, not safe arguments, undefined behaviors)
* supports module structure (injectors might be used separately or together)
* supports run time visitor through the objection creation (ex: for generation UML diagrams)
* supports mocks testing facilities (ex: to create mock hierarchy)
* minimal overhead / compile time approach


[endsect]

[section User's Guide]

[section Getting Started]

Requirements

* Boost.DI depends on some Boost libraries:
* Boost.Config
* Boost.SmartPtr
* Boost.MPL
* Boost.Utility/enable_if
* Boost.TypeTraits

Header only library

Exception safety

Thread Safety

Configuration
    BOOST_MPL_LIMIT_VECTOR_SIZE
    BOOST_DI_CTOR_CFG_VA_ARGS || BOOST_DI_CTOR_CFG_BRACKET
    #define BOOST_DI_CONSTRUCTOR boost_di_constructor__
    #define BOOST_DI_CREATE boost_di_create__

Tested Compilers

* GCC 4.7.3/4.8.1
* Clang 3.2/3.3
* Intel C++ 14.0.0
* MinGW 4.7.3/4.8.1
* Visual Studio 2013 RC

[endsect]


[section Tutorial]
But first, Guice needs to be configured to build the graph exactly as you want it.
To illustrate, we'll start the RealBillingService class that accepts its dependent interfaces CreditCardProcessor and TransactionLog in its constructor. To make it explicit that the RealBillingService constructor is invoked by Guice, we add the BOOST_DI_CTOR:
"

configure:

using config = injector<DatabaseTransactionLog>;
or
using config = injector<bind<TransactionLog, DatabaseTransactionLog>>;

using config = injector<PaypalCreditCardProcessor>;
or
using config = injector<bind<CreditCardProcessor, PaypalCreditCardProcessor>>;

The modules are the building blocks of an injector, which is Guice's object-graph builder

auto billingService = config().create<RealBillingService>();
auto billingService = make_injector(config()).create<RealBillingService>();

[endsect]

[section Examples]

[section hello world]

[table
    [[C++98/03] [C++11]]
    [
        [```
            #include <boost/di.hpp>

            namespace di = boost::di;

            namespace {
            struct i { virtual ~i() { } };
            struct impl : i { };
            struct c
            {
                BOOST_DI_CTOR(c
                  , boost::shared_ptr<i> p1     // i->impl, p1 == hello_world.p1
                  , double p2                   // p2 = 0.0
                ) { }
            };

            struct hello_world
            {
                BOOST_DI_CTOR(hello_world
                    , std::shared_ptr<i> p1     // i->impl
                    , std::unique_ptr<i> p3     // i->impl, p3 != p1 != c.p1
                    , c p4                      // by value
                    , int p5                    // p5 = 0
                ) { }
            };
            } // namespace

            int main() {
                using injector_t = di::injector<
                    impl // -> di::bind<i, impl>
                         // -> di::deduce<di::bind<i, impl>>
                         // -> di::singleton<di::bind<i, impl>>
                >;

                injector_t().create<hello_world>();
            }
        ```]

        [```
            #include <boost/di.hpp>

            namespace di = boost::di;

            namespace {
            struct i { virtual ~i() { } };
            struct impl : i { };
            struct c
            {
                BOOST_DI_CTOR(c
                  , boost::shared_ptr<i> p1     // i->impl, p1 == hello_world.p1
                  , double p2                   // p2 = 0.0
                ) { }
            };

            struct hello_world
            {
                BOOST_DI_CTOR(hello_world
                    , std::shared_ptr<i> p1     // i->impl
                    , std::unique_ptr<i> p3     // i->impl, p3 != p1 != c.p1
                    , c p4                      // by value
                    , int p5                    // p5 = 0
                ) { }
            };
            } // namespace

            int main() {
                using injector_t = di::injector<
                    impl // -> di::bind<i, impl>
                         // -> di::deduce<di::bind<i, impl>>
                         // -> di::singleton<di::bind<i, impl>>
                >;

                injector_t().create<hello_world>();
            }
        ```]
    ]
    [
        [full code example: [@http://examples/hello_world.cpp hello_world_03.cpp]]
        [full code example: [@http://examples/hello_world.cpp hello_world_11.cpp]]
    ]
]

[endsect]

[section boost and smart pointers]

[note conversion between boost and std smart pointers cause overhead and weak ptr conversions aren't supported]
[endsect]

[section concepts]
[endsect]

[section policies]
[endsect]

[section custom policy]
[endsect]

[section scopes / deduce / per_request / singleton / session]
[endsect]

[section custom scope]
[endsect]

[section ctor]
[endsect]

[section factory]
[endsect]

[section externals]
[endsect]

[section injector/make injector]
[endsect]

[section named parameters]
[endsect]

[section provider]
[endsect]

[section testing]
[endsect]

[section visitor / text visitor]
[endsect]

[endsect]

[section Concepts]

[section constructor injection]

Constructor injection is straightforward. Because Java technology guarantees constructor invocation, you don't need to worry about objects arriving in an uninitialized state — whether or not Guice creates them. You can also mark your fields final.
According to the Guice best practices guide, constructor injection is the preferred way to ask for your dependencies

[section BOOST_DI_CTOR]

[table BOOST_DI_CTOR
    [
        [
            struct c {
                BOOST_DI_CTOR(c, int i = 0, double = 0.0) { }
            };
        ]
        [
            struct c {
                static void boost_di_ctor__(int i = 0, double = 0.0);
                c(int i = 0, double = 0.0) { }
            };
        ]
    ]
]

[endsect]

[section BOOST_DI_CTOR_TRAITS]

[table BOOST_DI_CTOR_TRAITS
    [
        [
            struct c {
                BOOST_DI_CTOR_TRAITS(int, named<double,  my_name>);
                c(int, double) { }
            };
        ]
        [
            struct c {
                static void boost_di_ctor__(int, named<double, my_name>);
                c(int, double) { }
            };
        ]
    ]
]

[endsect]

[section BOOST_DI_CREATE]

[table BOOST_DI_CREATE
    [
        [
            struct i_factory {
                i* BOOST_DI_CREATE(int i) {
                    if (i) {
                        return new impl();
                    }

                    return nullptr;
                }
            };
        ]
        [
            struct i_factory {
                i* boost_di_create__(int i) {
                    if (i) {
                        return new impl();
                    }

                    return nullptr;
                }
            };
        ]
    ]
]

    class i_factory
    {
    public:
        i* BOOST_DI_CREATE(eid id) {
            switch(id) {
                case e1: return new impl1();
                case e2: return new impl2();
            }

            return nullptr;
        }
    };

    int main() {
        auto injector = di::make_injector(
            di::bind<eid>::to(e1)
          , di::bind<i, i_factory>()
        );

        injector.create<c>();

        return 0;
    }

[endsect]

[section di::ctor_traits]

    struct c
    {
        c(int, int) { }
    };

    namespace boost {
    namespace di {

    template<>
    struct ctor_traits<c>
    {
        static void ctor(int, di::named<int, name>);
    };

    } // namespace di
    } // namespace boost

    injector.create<c>();

[endsect]

[section di_ctor_traits.py]

usage
    Usage: di_ctor_traits.py [options] files...

    Options:
      -h, --help                show this help message and exit
      -o FILE, --output=FILE    output file (default='di_ctor_traits.hpp')
      -l LIMIT, --limit=LIMIT   limit to constructors within declaration (default='')

example
    ./di_ctor_traits.py file1.hpp file2.hpp -o di_ctor_traits.hpp -l "namespace" -- -D PROJECT -Iproject/include

    class c
    {
    public:
        c(int);
    };

    /*
     * file generated by di_ctor_traits: di_ctor_traits.hpp
     */
    #ifndef DI_CTOR_TRAITS_HPP
    #define DI_CTOR_TRAITS_HPP

    #include "..."

    namespace boost {
    namespace di {

    template<>
    struct ctor_traits<c>
    {
        static void ctor(int);
    };

    } // namespace di
    } // namespace boost

    #endif // DI_CTOR_TRAITS_HPP

[endsect]

[endsect]

[section binding]

DI is designed to do popular things easy:

bind<int>::in_call<c1, call_stack<c1, c2, c3>>()

Binding Resolution

The injector's process of resolving an injection request depends on the bindings and the annotations of the types involved. Here's how an injection request is resolved:

Use explicit bindings.
If the binding links to another, follow this resolution algorithm for that.
If the binding specifies an instance, return that.
If the binding specifies a provider, use that.
Ask a parent injector. If this injector has a parent injector, ask that to resolve the binding. If it succeeds, use that. Otherwise proceed.
Ask child injectors. If any child injector already has this binding, give up. A blacklist of bindings from child injectors is kept so injectors don't need to maintain references to their child injectors.
Handle Provider injections. If the type is Provider<T>, resolve T instead, using the same binding annotation, if it exists.
Convert constants. If there is a constant string bound with the same annotation, and a TypeConverter that supports this type, use the converted String.
If the dependency has a binding annotation, give up. Guice will not create default bindings for annotated dependencies.
If the dependency is an array or enum, give up.
Handle TypeLiteral injections. If the type is TypeLiteral<T>, inject that value, using context for the value of the type parameter.
Use resolution annotations. If the dependency's type has @ImplementedBy or @ProvidedBy, lookup the binding for the referenced type and use that.
If the dependency is abstract or a non-static inner class, give up.
Use a single @Inject or public no-arguments constructor.
Validate bindings for all dependencies — the constructor's parameters, plus @Inject methods and fields of the type and all supertypes.
Invoke the constructor.
Inject all fields. Supertype fields are injected before subtype fields.
Inject all methods. Supertype methods are injected before subtype methods.
[endsect]

[section injector]
[endsect]

[section named]
[endsect]

[section provider]
[endsect]

[endsect]

[section Scopes]

By default, DI returns a deduced instance each time it supplies a value

table - scope_traits
    per_request, T*, T
    singleton, T*, T

Applying scopes:

make_injector(
    singleton<impl>
  , per_request<impl2>
);

Singletons:
    has to be thread safe

    namespace boost {
    namespace di {
    namespace scopes {

    class scope {
    public:
        template<typename T, typename = T>
        class scope {
        public:
            typedef unspecified result_type;
            // typedef unspecified is_priority;

            template<typename... T>
            result_type create(const T&...);
        };
    };

    } // namespace scopes
    } // namespace di
    } // namespace boost

[section deduce]

Synopsis

    class deduce {
    public:
        template<typename T, typename = T>
        class scope;
    };

Description


Header

    #include <boost/di/scopes/deduce.hpp>

Example

    using injector_t = injector<impl>;
    assert(injector_t().create<impl2>());


    injector<
        bind<i, impl>
    >;

    injector<
        scope<deduce>::bind<
            bind<i, impl>
        >
    >;

[endsect]

[section external]

    auto injector = make_injector(
        bind<int>::to(0)
      , bind<int>::in_call<some_class>::to(1)
      , bind<int>::in_call<some_class>::in_name<some_name>::to(2)
    );


[endsect]

[section per_request]

    auto injector = make_injector(
        per_request<int>
      , per_request<
    );

[endsect]

[section singleton]
[endsect]

[section session]
[endsect]

[section custom_scope]

    struct entry { };
    struct exit { };

    struct custom_scope {
        template<typename T, typename>
        struct scope
        {
            typedef T result_type;
            //typedef scope is_priority;

            void call(const entry&);
            void call(const exit&);

            template<typename... Args>
            result_type create(Args&&... args);
        };
    };

    using injector_t = injector<
        scope<custom_scope>::bind<
            types...
        >
    >;

    injector_t injector;

    injector.call(entry());
    injector.create<type>();
    injector.call(exit());

[endsect]

[endsect]

[section Policies]

[section arguments_permission]

    injector<arguments_permission<>>().create<int>(); // compile fail
    injector<arguments_permission<allow_copies>>().create<int>(); // ok
    injector<arguments_permission<allow_copies, allow_ptrs>>().create<int*>(); // ok

[endsect]

[section binding_correctness]

    struct c {
        BOOST_DI_CTOR(c, int);
    };

    injector<
        binding_correctness
      , injector<
            bind<double>::in_call<c>
        >
    >().create<c>; // error -> double is not an argument of 'c' constructor

    struct s { s(int); };
    struct k { k(shared_ptr<s>); };
    struct c { c(shared_ptr<s>, shared_ptr<k>); }; //arguments evaluation order is not specified
    injector<
        bind<int>::in_call<s>::to(i)
      , singleton<s>
    >().create<c>();

[endsect]

[section circular_dependencies]

    struct cd2;
    struct cd1 { cd1(cd2*); };
    struct cd2 { cd2(cd1*); };
    make_injector().create<cd1>(); //error

[endsect]

[section creation_ownership]

    injector_.create<const c1&>(); //error
    injector_.create<c1&>(); //error

[endsect]

[endsect]

[section Performance]
[endsect]

[section Reference]

[section Header <boost/di.hpp>]
This header exists simply as a convenience to the user, including all of the headers in the boost/di directory.

    // ctor
    #include "boost/di/ctor.hpp"

    // concepts
    #include "boost/di/concepts.hpp"

    // scopes
    #include "boost/di/scopes/deduce.hpp"
    #include "boost/di/scopes/external.hpp"
    #include "boost/di/scopes/per_request.hpp"
    #include "boost/di/scopes/session.hpp"
    #include "boost/di/scopes/singleton.hpp"

    // injector
    #include "boost/di/injector.hpp"
    #include "boost/di/make_injector.hpp"

    // utilities
    #include "boost/di/named.hpp"
    #include "boost/di/provider.hpp"

    // policies
    #include "boost/di/policies/arguments_permission.hpp"
    #include "boost/di/policies/binding_correctness.hpp"
    #include "boost/di/policies/circular_dependencies.hpp"
    #include "boost/di/policies/creation_ownership.hpp"

[endsect]

[section Header <boost/di/concepts/bind.hpp>]

    namespace boost {
    namespace di {
    namespace concepts {

    template<
        typename TExpected
      , typename TGiven
    >
    struct bind {
        template<typename... T>
        struct in_call {
            template<TName>
            struct in_name;
        };

        template<TName>
        struct in_name {
            template<typename... T>
            struct in_call;
        };
    };

    } // namespace concepts
    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/concepts/dependency.hpp>]

    namespace boost {
    namespace di {
    namespace concepts {

    template<
        typename TScope
      , typename TExpected
      , typename TGiven = TExpected
      , typename TContext = mpl::vector0<>
      , typename TBind = typename mpl::lambda<
            is_same<mpl::_1, TExpected>
        >::type
    >
    class dependency {
    public:
        typedef dependency type;
        typedef typename TScope scope;
        typedef typename TExpected expected;
        typedef typename TGiven given;
        typedef TContext context;
        typedef TBind bind;

        template<typename T>
        struct rebind {
            typedef dependency<T, TExpected, TGiven, TContext, TBind> other;
        };

        dependency() { }

        template<typename T>
        explicit dependency(const T&);

        template<typename T>
        dependency<T> to(const T&);

        template<typename T>
        dependency<T> to(T&);

        template<typename T>
        dependency<T> to(shared_ptr<T>);

        template<typename T>
        dependency<T> to(std::shared_ptr<T>);
    };

    } // namespace concepts
    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/concepts/scope.hpp>]

    namespace boost {
    namespace di {
    namespace concepts {

    template<typename TScope>
    struct scope {
        template<typename... T>
        struct bind {
            template<TName>
            struct in_name;
        };

        template<T>
        struct bind {
            template<typename... T>
            struct in_call {
                template<TName>
                struct in_name;
            };

            template<typename TName>
            struct in_name {
                template<typename... T>
                struct in_call;
            };
        };
    };

    } // namespace concepts
    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/convertibles/copy.hpp>]

    namespace boost {
    namespace di {
    namespace concepts {

    template<typename T>
    struct copy {
        template<typename I>
        explicit copy(const I&);

        operator T*() const;

        template<typename I, typename TName>
        operator named<I, TName>() const;

        template<typename I>
        operator shared_ptr<I>() const;

        template<typename I, typename TName>
        operator named<shared_ptr<I>, TName>() const;

        template<typename I>
        operator std::auto_ptr<I>&() const;

        template<typename I, typename TName>
        operator named<std::auto_ptr<I>, TName>&() const;

        template<typename I>
        operator std::shared_ptr<I>() const;

        template<typename I, typename TName>
        operator named<std::shared_ptr<I>, TName>() const;

        template<typename I>
        operator std::unique_ptr<I>() const;

        template<typename I, typename TName>
        operator named<std::unique_ptr<I>, TName>() const;
    };

    } // namespace concepts
    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/convertibles/ref.hpp>]

    namespace boost {
    namespace di {
    namespace concepts {

    template<typename T>
    struct ref {
        explicit ref(const reference_wrapper<T>&);

        operator T&() const;

        template<typename I, typename TName>
        operator named<I, TName>() const;
    };

    } // namespace concepts
    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/convertibles/shared.hpp>]

    namespace boost {
    namespace di {
    namespace concepts {

    template<typename T>
    struct shared {
        shared() { }
        explicit shared(shared_ptr<T>);
        explicit shared(std::shared_ptr<T>);

        bool operator!() const;

        void reset();

        void reset(T*);

        template<typename I>
        operator shared_ptr<I>() const;

        template<typename I, typename TName>
        operator named<shared_ptr<I>, TName>() const;

        template<typename I>
        operator weak_ptr<I>() const;

        template<typename I, typename TName>
        operator named<weak_ptr<I>, TName>() const;

        template<typename I>
        operator std::shared_ptr<I>() const;

        template<typename I, typename TName>
        operator named<std::shared_ptr<I>, TName>() const;
    };

    } // namespace concepts
    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/convertibles/value.hpp>]

    namespace boost {
    namespace di {
    namespace concepts {

    template<typename T>
    struct value {
        explicit value(T);

        operator T() const;
        operator T&&() const;
        template<typename I, typename TName>
        operator named<I, TName>() const;
    };

    } // namespace concepts
    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/concepts.hpp>]

    namespace boost {
    namespace di {

    template<typename TExpected, typename TGiven = TExpected>
    struct bind;

    template<int N>
    struct bind_int;

    template<typename T>
    struct bind_string;

    template<typename TScope>
    struct scope;

    template<typename... T>
    struct deduce;

    template<typename... T>
    struct per_request;

    template<typename... T>
    struct singleton;

    template<typename... T>
    struct session;

    template<typename... T>
    struct call_stack;

    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/ctor.hpp>]
    BOOST_DI_CTOR_TRAITS(...)

    BOOST_DI_CTOR(type, ...)

[endsect]

[section Header <boost/di/injector.hpp>]

    namespace boost {
    namespace di {

    template<typename...>
    class injector {
    public:
        typedef unspecified deps;
        typedef unspecified policies;

        template<typename... TArgs>
        explicit injector(const TArgs&...);

        template<typename... TArgs>
        injector<TArgs...> operator()(const TArgs&...);

        template<typename T>
        T create();

        template<typename T, typename TVisitor>
        T create(const TVisitor&);

        template<typename TAction>
        void call(const TAction&);
    };

    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/make_injector.hpp>]

    namespace boost {
    namespace di {

    template<typename... T>
    injector<T...> make_injector(const T...&);

    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/named.hpp>]

    namespace boost {
    namespace di {

    template<
        typename T
      , typename TName = void
      , typename = void
    >
    class named {
    public:
        typedef T named_type;
        typedef TName name;

        template<typename U>
        struct rebind
        {
            typedef named<U, TName> other;
        };

        named(T object = T()); //non explicit

        operator T() const;
        operator T&();
    };

    template<
        typename T
      , typename TName = void
      , typename enable_if<is_smart_ptr<T> >::type
    >
    class named {
        typedef typename T::element_type element_type;

    public:
        typedef T named_type;
        typedef TName name;

        template<typename U>
        struct rebind
        {
            typedef named<U, TName> other;
        };

        named(T = T()); //non explicit

        named(element_type*); // non explicit

        operator T() const;
        element_type* operator->() const;
        element_type& operator*() const;
        element_type* get() const;

        void reset();
        void reset(element_type*);
    };

    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/provider.hpp>]

    namespace boost {
    namespace di {

    template<typename T>
    class provider {
    public:
        virtual ~provider();
        virtual T get() const = 0;
    };

    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/scopes/deduce.hpp>]

    namespace boost {
    namespace di {
    namespace scopes {

    class deduce {
    public:
        template<typename, typename>
        class scope { };
    };

    } // namespace scopes
    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/scopes/external.hpp>]

    namespace boost {
    namespace di {
    namespace scopes {

    template<
        template<typename> class TConvertible = convertibles::value
    >
    class external {
    public:
        typedef unspecified is_priority;

        template<typename TExpected, typename = TExpected>
        class scope {
        public:
            typedef TConvertible<TExpected> result_type;

            template<typename T>
            explicit scope(const T&);

            template<typename... T>
            result_type create(const T&...);
        };
    };

    } // namespace scopes
    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/scopes/per_request.hpp>]

    namespace boost {
    namespace di {
    namespace scopes {

    template<
        template<typename> class TConvertible = convertibles::copy
    >
    class per_request {
    public:
        template<typename TExpected, typename = TExpected>
        class scope {
        public:
            typedef TConvertible<TExpected> result_type;

            template<typename... T>
            result_type create(const T&...);
        };
    };

    } // namespace scopes
    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/scopes/session.hpp>]

    namespace boost {
    namespace di {
    namespace scopes {

    template<
        template<typename> class TConvertible = convertibles::shared
    >
    class session {
    public:
        template<typename TExpected, typename = TExpected>
        class scope {
        public:
            typedef TConvertible<TExpected> result_type;

            template<typename... T>
            result_type create(const T&...);
        };
    };

    } // namespace scopes
    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/scopes/singleton.hpp>]

    namespace boost {
    namespace di {
    namespace scopes {

    template<
        template<typename> class TConvertible = convertibles::shared
    >
    class singleton {
    public:
        template<typename TExpected, typename = TExpected>
        class scope {
        public:
            typedef TConvertible<TExpected> result_type;

            template<typename... T>
            result_type create(const T&...);
        };
    };

    } // namespace scopes
    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/policies/arguments_permission.hpp>]

    namespace boost {
    namespace di {
    namespace policies {

    struct allow_smart_ptrs;
    struct allow_refs;
    struct allow_rvalue_refs;
    struct allow_ptrs;
    struct allow_copies;

    template<typename... T>
    class arguments_permission {
    public:
        typedef unspecified is_policy;

        template<typename TDeps, typename TGiven>
        struct verify;
    };

    } // namespace policies
    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/policies/binding_correctness.hpp>]

    namespace boost {
    namespace di {
    namespace policies {

    class binding_correctness {
    public:
        typedef unspecified is_policy;

        template<typename TDeps, typename TGiven>
        struct verify;
    };

    } // namespace policies
    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/policies/circular_dependencies.hpp>]

    namespace boost {
    namespace di {
    namespace policies {

    class circular_dependencies {
    public:
        typedef unspecified is_policy;

        template<typename TDeps, typename TGiven>
        struct verify;
    };

    } // namespace policies
    } // namespace di
    } // namespace boost

[endsect]

[section Header <boost/di/policies/creation_ownership.hpp>]

    namespace boost {
    namespace di {
    namespace policies {

    class creation_ownership {
    public:
        typedef unspecified is_policy;

        template<typename TDeps, typename TGiven>
        struct verify;
    };

    } // namespace policies
    } // namespace di
    } // namespace boost

[endsect]

[endsect]
[endsect]

[section Integration with Boost libraries]

[section Boost Meta State Machine]
[endsect]

[endsect]

[section Revision History]
[endsect]

