[/
 /
 / Copyright (c) 2014 Krzysztof Jusiak (krzysztof at jusiak dot net)
 /
 / Distributed under the Boost Software License, Version 1.0.
 / (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /
 /]

[section Introduction & Motivation]

Boost.DI is C++ 03 / C++ 11 header only library providing compile time, macro free constructor dependency injection functionality.

[h6 Dependency Injection?]

"Dependency Injection is a set of software design principles and patterns that enable us to develop loosely coupled code" [1].
Loose coupling code make code more maintainable, which is one of an obvious goals in software engineering.
In simple worlds might be described with the Hollywood principle: "Don't call us, we'll call you".

Dependency Injection allow us to separate business logic and object creation,
which is a really good thing, because it give us the possibility to write maintainable and testable code.

There are many forms of dependency injection about which you can read in [2]:

* Constructor injection
* Interface injection
* Setter injection
* Member injection

Constructor injection is the most powerful and the cleanest way of dependency injection,
it's also the preferable as well becauase you don't need to worry about objects arriving in an uninitialized state.
This library provide the functionality for constructor and interface injection.

[link See11] widely explains advantages of using dependency injection, which might be sum up by:

* Parallel Development
    * allows many teams to work separately on different modules

* Extensibility
    * lose coupling, declarative approach are features which make code easy to extend
    * promotes business logic code over boilerplate code

* Maintainability
    * separation between object creation and business logic make code easy maintainable
    * reduce `Dependency Carrying` - passing dependnecies which aren't used directly and passed further

* Testability
    * possibility of passing all required parameters via constructor give the opportunity to use fakes for testing purposes

* Readbility

[note Service locator - similar in a lot of cases to dependency injection - anti pattern, because force unnatural code structure and a lot of resolve calls]

[h6 Dependency Injection Library?]

But do we really need dependency injection library, we can inject all dependencies ourselves?
Well, we don't need it to apply all the goods of dependency injection, but it may make our life easier.
Programmers should be `lazy` and shouldn't have to write tedious, boilerplate code (which is hard to test - how to test factories?).
Frameworks needs are scaling with the project size, the bigger project is, the more frameworks will be used.
Using library may give you additional advantages like logging, generating diagrams, compile time checking or restrictions,
additional conversions, etc... in general it give you full control of what and how will be injected in easy and user friendly way.
Depenendy injection frameowkr of some sort will be created either way during the implemention of the project
With that said, if you do not use a dependency injection framework, you end up in creating one (or parts of it) yourself. Furthermore, dependencies can be passed through constructors or setters and this can be achieved without dependency injection. The benefit of dependency injection is that the framework takes care of all objects creation and configuration for you. Therefore instead of creating and configuring the objects yourself, the dependency framework does it for you.

[h6 Motivation example]

[import ../example/cpp_11/motivation.cpp]
[motivation_cpp_11]

[tip Good practise: composition root is a (preferably) unique location in an application where modules are composed together in 1]

```
class email
{
public:
    void send(const std::string& message) { ... }
};
```

```
class person
{
public:
    void send_hello_world() {
        email_.send("hello world");
    }

private:
    email email_;
};
```

* coupeld (person depends on email)

Let's follow "define, implement and use" principle

define
```
class imessage
{
public:
    virtual ~imessage() { }
    virtual void send(const std::string&) = 0;
};
```

implement
```
class email : public imessage
{
public:
    virtual ~email() { }
    void send(const std::string& message) override { ... }
};
```

```
class person
{
public:
    person(const service_locator& sl)
        : message_(sl.resolve<imessage>())
    { }

    void send_hello_world() {
        message_->send("hello world");
    }

private:
    std::unique_ptr<imessage> message_;
};
```

use
```
class person
{
public:
    person(std::unique_ptr<imessage> message)
        : message_(message)
    { }

    void send_hello_world() {
        message_->send("hello world");
    }

private:
    std::unique_ptr<imessage> message_;
};
```

```
```

implement others
```
class tweet : public imessage
{
public:
    virtual ~email() { }
    void send(const std::string& message) override { ... }
};
```

complexity was added but we can use di then

```
auto injector = di::make_injector(
    bind<imessage, email>();
);

auto person_ = injector.create<person>();
```

* Benefits of using Dependency Injection Framework

 * changing the signature won't require any changes
 * changing will only require change the module service
 * we cant easily make integreation tests
 * unit tests, we won't need it but for

[endsect]

