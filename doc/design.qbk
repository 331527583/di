[section Design Rationale]

Basic design of Boost.DI involves two main concepts:

* verifying how many arguments constructor has using `has_ctor`
* conversion to requested type using `type conversion operator`

```
struct any_type {
    template<typename U> operator U();
};

template<typename T, typename... TArgs>
struct has_ctor {
    template<typename U> static yes_tag test(decltype(U(TArgs()...)*);
    template<typename> static no_tag test(...);

    static const bool value = sizeof(test<T>(0)) == sizeof(yes_tag);
};

struct converter {
    template<typename T> operator T() {
        return T();
    }
};

class injector {
    template<typename T>
    struct ctor {
        constexpr int max() const {
            for (auto i = MAX_CTOR_SIZE; i > 0; --i) {
                if (has_ctor<T, mpl::int_<i>>::value) {
                    return i;
                }
            }

            return 0;
        }
    };

public:
    template<typename T>
    T create() const {
        return create_impl<T, generate_converters<ctor<T>::max()>>();
    }

private:
    template<typename T, typename... TConverters>
    T create_impl() const {
        return T(TConverters()...);
    }
};

struct example {
    example(int i, int double) { }
};

injector().create<example>();
```
[note Purpose of above pseudo code is to illustrate basic idea, if you interested in the implementation details take a look into Boost.DI source code.]
[table
    [[Tests: [@test/vt/compiler_support_vt.cpp]]]
]

That's the main idea, obviously Boost.DI is more complex that that.
The latest design is shown below.

[@images/di.png [$images/di.png [width 75%] [height 75%] ]]
Generated with [@http://plantuml.sourceforge.net PlantUML].

During implementation of Boost.DI a lot of concepts were checked
and a many approaches were taken. To track different design's
please refer to commits history.

Boost.DI architecture might be split into few main parts

[table
    [ [Component] [Description] ]
    [ [Core] [Responsible for resolving requested types (implementation detail)] ]
    [ [Concepts] [DSL to create dependencies representation which will be used by core to resolve types] ]
    [ [Scopes] [Responsible for maintain objects life time] ]
    [ [Wrappers] [Responsible for conversion to required type] ]
    [ [Policies] [Compile time assertions for types] ]
]

[h5 Constructor Arguments Deduction]

# for type T
    # for N = 1 to `BOOST_DI_CFG_CTOR_LIMIT_SIZE`
    # if T has constructor with N parameters goto `a`
# generate list of `any_type` with N elements

[h5 Binding Resolution Algorithm]

# for type T
    # for all dependencies
    # if scope was set to `deduce` rebind it accordingly to type definition (using `scope traits - see deduce scope`)

[h5 Type Creation Algorithm]

# for type T
    # for all dependencies
    # if scope was set to `deduce` rebind it accordingly to type definition (using `scope traits`)

[endsect]

