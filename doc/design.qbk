[/
 /
 / Copyright (c) 2014 Krzysztof Jusiak (krzysztof at jusiak dot net)
 /
 / Distributed under the Boost Software License, Version 1.0.
 / (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /
 /]

[section Design Rationale]

Basic design of Boost.DI involves two main concepts:

* verifying how many arguments constructor has using `has_ctor`
* conversion to requested type using `type conversion operator`

```
struct any_type {
    template<typename U> operator U();
};

template<typename T, typename... TArgs>
struct has_ctor {
    template<typename U> static yes_tag test(decltype(U(TArgs()...)*);
    template<typename> static no_tag test(...);

    static const bool value = sizeof(test<T>(0)) == sizeof(yes_tag);
};

class injector {
public:
    template<typename T>
    T create(enable_if<has_ctor<T, any_type...>>::type* = 0) const {
        return T(any_type()...);
    }
};

struct example {
    example(int i, int double) { }
};

injector().create<example>();
```
[note Purpose of above pseudo code is to illustrate basic idea, if you interested in the implementation details take a look into Boost.DI source code.]

* Problematic cases

    * Ambiguous constructors with the same - longest - number of parameters
    [table
        [[Issue][Solution]]
        [
            [
                ```
                                                                          .
                struct example {
                    explicit example(int);
                    example(int, double);
                    example(int, double, float); // ambiguity
                    example(int, float, double); // ambiguity
                };
                ```
            ]
            [
                ```
                                                                                                             .
                use BOOST_DI_INJECT to point which constructor should be chosen by Boost.DI
                    struct example {
                        explicit example(int);
                        example(int, double);
                        example(int, double, float);
                        BOOST_DI_INJECT(example, int, float, double);
                    };
                ```
            ]
        ]
    ]

    * Constructor with variadic number of parameters
    [table
        [[Issue][Solution]]
        [
            [
                ```
                                                                          .
                struct example {
                    template<typename... TArgs>
                    explicit example(TArgs&&...);
                };
                ```
            ]
            [
                ```
                                                                                                             .
                use BOOST_DI_INJECT_TRAITS to define the constructor
                    namespace boost { namespace di {
                        template<>
                        struct ctor_traits<example> {
                            BOOST_DI_INJECT_TRAITS(int, double); // or in definition of the class
                        };
                    }} // boost::di
                ```
            ]
        ]
    ]


    * Copy constructors
    [table
        [[Issue][Solution]]
        [
            [
                ```
                                                                          .
                struct example {
                    example(const example&);
                    example(int); // ambiguous in c++03
                };
                ```
            ]
            [
                ```
                                                                                                             .
                In C++11 copy constructors ambiguity might be disabled using default template parameters
                    template<
                        typename U
                      , typename = typename disable_if<is_same_base_of<T, U>>::type
                    >
                    operator U();

                In C++03 constructor has to be explicitly pointed out
                struct example {
                    example(const example&);
                    BOOST_DI_INJECT(example, (int)); // ok in c++03
                };

                Or by adding dummy parameter to the constructor
                struct example {
                    example(const example&);
                    example(int, int = 0); // ok in c++03
                };
                ```
            ]
        ]
    ]

    * Constructor with non-copyable types
    [table
        [[Issue][Solution]]
        [
            [
                ```
                                                                          .
                struct example {
                     // moveable types are supported
                    example(std::auto_ptr<int>, std::unique_ptr<int>);
                };
                ```
            ]
            [
                ```
                                                                                                             .
                struct any_type {
                    template<typename U> operator U();
                    template<typename U> operator aux::auto_ptr<U>&(); // for std::auto_ptr
                };
                ```
            ]
        ]
    ]

    * Constructor with types which have `conversion constructor`
    [table
        [[Issue][Solution]]
        [
            [
                ```
                                                                          .
                template<typename>
                struct example {
                    template<typename T>
                    example(T);
                };

                struct app {
                    app(example<int>);
                };
                ```
            ]
            [
                ```
                                                                                                             .
                use BOOST_DI_INJECT to explicitly point out the constructor parameters
                    struct app {
                        BOOST_DI_INJECT(app, example<int>);
                    };

                make example constructor explicit if possible
                    template<typename>
                    struct example {
                        template<typename T>
                        explicit example(T);
                    };

                if conversion constructor might be disabled, might be worth to do so
                boost::function has a conversion constructor from any type but integral types
                    template<>
                    struct is_integral<any_type>
                        : mpl::true_
                    { };
                ```
            ]
        ]
    ]

    * Inheriting constructors
    [table
        [[Issue][Solution]]
        [
            [
                ```
                                                                          .
                struct a {
                    a(int, double);
                    a(int, double, float);
                };

                struct b : a {
                    using a::a;
                };

                struct app {
                    app(b);
                };
                ```
            ]
            [
                ```
                                                                                                             .
                Support without any workarounds
                ```
            ]
        ]
    ]

    * `BOOST_DI_INJECT` and default parameters
    [table
        [[Issue][Solution]]
        [
            [
                ```
                                                                          .
                struct example {
                    BOOST_DI_INJECT(explicit example
                                  , int = 0
                                  , double = 0.0);
                };
                ```
            ]
            [
                ```
                                                                                                             .
                BOOST_DI_INJECT creates a function instead of direct traits
                    struct example {
                        static void boost_di_injector__(int = 0, double = 0.0);
                        explicit example(int = 0, double = 0.0);
                    };

                    paramter_types<decltype(&example::boost_di_injector__)>::type -> mpl::vector<int, double>
                ```
            ]
        ]
    ]

    * `BOOST_DI_INJECT` with inheritance
    [table
        [[Issue][Solution]]
        [
            [
                ```
                                                                          .
                struct a {
                    BOOST_DI_INJECT(a, int, double);
                };

                struct b : a { };

                std::make_unique<b>(); // error b doesn't have
                                       // constructor with 2 parameters
                ```
            ]
            [
                ```
                                                                                                             .
                use BOOST_DI_INJECT or BOOST_DI_INJECT_TRAITS to explicitly point that constructor is empty

                struct a {
                    BOOST_DI_INJECT(a, int, double);
                };

                struct b : a {
                    BOOST_DI_INJECT_TRAITS(); // or BOOST_DI_INJECT(b);
                };

                std::make_unique<b>();
                ```
            ]
        ]
    ]

    * Function parameters evaluation order with shared binding
    [table
        [[Issue][Solution]]
        [
            [
                ```
                                                                          .
                struct a { a(int); };
                struct b { b(aux::shared_ptr<a>); };

                // parameters evaluation order is not specified
                struct c { c(aux::shared_ptr<a>, aux::shared_ptr<b>); };

                di::make_injector(
                    bind<int>::when<call_stack<a>>::to(42)
                  , shared<a>
                );
                ```
            ]
            [
                ```
                                                                                                             .
                be aware and avoid binding which may be affected by parameters evaluation order
                ```
            ]
        ]
    ]

[table
    [[Tests: [@test/vt/compiler_support_vt.cpp]]]
]

[warning GCC/Clang/MSVC/Intel all compilers differ with they way template conversion operator is handled]

That's the main idea, obviously Boost.DI is more complex that that.
The latest design is shown below.

[@images/di.png [$images/di.png [width 75%] [height 75%] ]]
Generated with [@http://plantuml.sourceforge.net PlantUML].

During implementation of Boost.DI a lot of concepts were checked
and a many approaches were taken. To track different design's
please refer to commits history.

Boost.DI architecture might be split into few main parts

[table
    [ [Component] [Description] ]
    [ [Core] [Responsible for resolving requested types (implementation detail)] ]
    [ [Concepts] [DSL to create dependencies representation which will be used by core to resolve types] ]
    [ [Scopes] [Responsible for maintain objects life time] ]
    [ [Wrappers] [Responsible for conversion to required type] ]
    [ [Policies] [Compile time assertions for types] ]
]

[h5 Constructor Parameters Deduction]

# for type T
    # for N = 1 to `BOOST_DI_CFG_CTOR_LIMIT_SIZE`
    # if T has constructor with N parameters goto `a`
# generate list of `any_type` with N elements

[h5 Binding Resolution Algorithm]

# for type T
    # for all dependencies
    # if scope was set to `deduce` rebind it accordingly to type definition (using `scope traits - see deduce scope`)

[h5 Type Creation Algorithm]

# for type T
    # for all dependencies
    # if scope was set to `deduce` rebind it accordingly to type definition (using `scope traits`)

[endsect]

