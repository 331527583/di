[section Reference]

[section ...]

[section Header <boost/di.hpp>]
This header exists simply as a convenience to the user, including all of the headers in the boost/di directory.

    // inject
    #include "boost/di/inject.hpp"

    // concepts
    #include "boost/di/concepts.hpp"

    // scopes
    #include "boost/di/scopes/deduce.hpp"
    #include "boost/di/scopes/external.hpp"
    #include "boost/di/scopes/session.hpp"
    #include "boost/di/scopes/shared.hpp"
    #include "boost/di/scopes/unique.hpp"

    // injector
    #include "boost/di/injector.hpp"
    #include "boost/di/make_injector.hpp"

    // utilities
    #include "boost/di/named.hpp"
    #include "boost/di/provider.hpp"

    // policies
    #include "boost/di/policies/arguments_permission.hpp"
    #include "boost/di/policies/circular_dependencies.hpp"
    #include "boost/di/policies/creation_ownership.hpp"
    #include "boost/di/policies/scopes_permission.hpp"

[endsect]

[section Header <boost/di/inject.hpp>]
```
#define BOOST_DI_INJECT_TRAITS(...);
#define BOOST_DI_INJECT(type, ...);
```
[endsect]

[section Header <boost/di/injector.hpp>]
```
namespace boost {
namespace di {

template<typename... T>
class injector {
public:
    typedef TDependecies deps;

    template<typename... TArgs>
    explicit injector(TArg&&...);

    template<typename T, typename... TPolicies>
    T create(TPolicies&&...);

    template<typename T, typename Visitor>
    T visit(const Visitor&);

    template<typename TAction>
    void call(const TAction&);
};

} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/mt/injector_mt.cpp]]]
]
[endsect]

[section Header <boost/di/make_injector.hpp>]
```
namespace boost {
namespace di {

template<typename... TArgs>
injector<typename detail::concepts<mpl::vector<TArgs...>>::type>
inline make_injector(TArgs&&...);

} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/mt/make_injector_mt.cpp]]]
]
[endsect]

[section Header <boost/di/named.hpp>]
[endsect]

[section Header <boost/di/provider.hpp>]
```
namespace boost {
namespace di {

template<typename T>
class provider {
public:
    virtual ~provider() { }
    virtual T get() const = 0;
};

} // namespace di
} // namespace boost
```
[endsect]

[endsect]

[section Core]

[section Header <boost/di/core/binder.hpp>]
```
namespace boost {
namespace di {
namespace core {

template<
    typename TDependecies
  , typename TBuilder = builder
>
class binder {
public:
    explicit binder(const TBuilder& = TBuilder());

    template<
        typename T
      , typename TCallStack
      , typename TDefault =
            ::boost::di::concepts::dependency<
                typename type_traits::scope_traits<T>::type
              , typename type_traits::make_plain<T>::type
            >
    >
    struct resolve;

    template<
        typename T
      , typename TCtor
      , typename TCallStack
      , typename TDependency
      , typename TCreator
      , typename TDeps
      , typename TRefs
      , typename TVisitor
      , typename TPolicies
    >
    wrappers::universal<T> resolve_impl(TCreator&, TDeps&, TRefs&, const TVisitor&, const TPolicies&);
};

} // namespace core
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/core/binder_ut.cpp]]]
]
[endsect]

[section Header <boost/di/core/builder.hpp>]
```
namespace boost {
namespace di {
namespace core {

class builder {
public:
    explicit builder(const scopes_type& = scopes_type());

    template<
        typename T
      , typename TCtor
      , typename TCallStack
      , typename TDependency
      , typename TCreator
      , typename TDeps
      , typename TRefs
      , typename TVisitor
      , typename TPolicies
    >
    wrappers::universal<T> build(TCreator&, TDeps&, TRefs&, const TVisitor&, const TPolicies&);
};

} // namespace core
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/core/builder_ut.cpp]]]
]
[endsect]

[section Header <boost/di/core/creator.hpp>]
```
namespace boost {
namespace di {
namespace core {

template<
    typename TDependecies = mpl::vector0<>
  , template<
        typename
      , typename = ::boost::di::core::builder
    > class TBinder = binder
>
class creator {
    template<
        typename T
      , typename TCallStack
      , typename TDeps
      , typename TRefs
      , typename TVisitor
      , typename TPolicies
    >
    class eager_creator {
    public:
        eager_creator(creator&, TDeps&, TRefs&, const TVisitor&, const TPolicies&);

        template<
            typename U
          , typename = typename disable_if<
                type_traits::is_same_base_of<
                    typename type_traits::make_plain<U>::type
                  , typename type_traits::make_plain<T>::type
                >
            >::type
        >
        operator U();
    };

public:
    explicit creator(const TBinder<TDependecies>& = TBinder<TDependecies>());

    template<
        typename T
      , typename TParent // to ignore copy/move ctor
      , typename TCallStack
      , typename TDeps
      , typename TRefs
      , typename TVisitor
      , typename TPolicies
    >
    eager_creator<TParent, TCallStack, TDeps, TRefs, TVisitor, TPolicies>
    create(TDeps&, TRefs&, const TVisitor&, const TPolicies&, typename enable_if<is_same<T, detail::any_type> >::type* = 0);

    template<
        typename T
      , typename // TParent - not needed
      , typename TCallStack
      , typename TDeps
      , typename TRefs
      , typename TVisitor
      , typename TPolicies
    >
    wrappers::universal<T> create(TDeps&, TRefs&, const TVisitor& , const TPolicies&, typename disable_if<is_same<T, detail::any_type> >::type* = 0);
};

} // namespace core
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/core/creator_ut.cpp]]]
]
[endsect]

[section Header <boost/di/core/module.hpp>]
```
namespace boost {
namespace di {
namespace core {

template<
    typename TDependecies = mpl::vector0<>
  , template<
        typename
      , template<typename, typename> class = ::boost::di::core::binder
    > class TCreator = creator
  , template<
        typename = ::boost::mpl::vector0<>
      , typename = ::boost::di::core::never< ::boost::mpl::_1 >
      , typename = void
    > class TPool = pool
>
class module {
public:
    typedef TDependecies deps;

    template<typename... TArgs>
    explicit module(TArg&&...);

    template<typename T, typename... TPolicies>
    T create(TPolicies&&...);

    template<typename T, typename Visitor>
    T visit(const Visitor&);

    template<typename TAction>
    void call(const TAction&);
};

} // namespace core
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/mt/core/module_mt.cpp]]]
]
[endsect]

[section Header <boost/di/core/pool.hpp>]
```
namespace boost {
namespace di {
namespace core {

class init { };

template<typename>
struct never;

template<
    typename TSeq = mpl::vector0<>
  , typename TIgnore = never<mpl::_1>
>
class pool {
public:
    typedef TSeq types;

    template<typename... T>
    explicit pool(T&&...);

    template<typename T>
    explicit pool(const pool<T>&, const init&);

    template<typename T>
    const T& get() const;
};

} // namespace core
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/core/pool_ut.cpp]]]
]
[endsect]

[endsect]

[section Concepts]

[section Header <boost/di/concepts.hpp>]
```
namespace boost {
namespace di {

template<typename TExpected, typename TGiven = TExpected>
struct bind;

template<int N>
struct bind_int;

template<typename T>
struct bind_string;

template<typename TScope>
struct scope;

template<typename... T>
struct deduce;

template<typename... T>
struct unique

template<typename... T>
struct shared;

template<typename... T>
struct session;

template<typename... T>
struct call_stack;

template<typename... T>
struct any_of;

} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/concepts_ut.cpp]]]
]
[endsect]

[section Header <boost/di/concepts/bind.hpp>]
```
namespace boost {
namespace di {
namespace concepts {

template<
    typename TExpected
  , typename TGiven
  , template<
        typename
      , typename
      , typename
      , typename
    > class TDependency
>
struct bind {
    template<typename... T>
    struct when {
        template<typename TName>
        struct named;
    };

    template<typename TName>
    struct named {
        template<typename... T>
        struct when;
    };
};

} // namespace concepts
} // namespace di
} // namespace boost
```
[endsect]

[section Header <boost/di/concepts/call_stack.hpp>]
```
namespace boost {
namespace di {
namespace concepts {

template<typename... T>
class call_stack {
public:
    template<typename T>
    struct apply;
};

} // namespace concepts
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/concepts/call_stack_ut.cpp]]]
]
[endsect]

[section Header <boost/di/concepts/dependency.hpp>]
```
namespace boost {
namespace di {
namespace concepts {

template<
    typename TScope
  , typename TExpected
  , typename TGiven = TExpected
  , typename TBind =
        detail::requires_<
            concepts::type_traits::is_required_priority
          , concepts::type_traits::is_required_type<TExpected>
        >
>
class dependency {
    typedef scopes::external<wrappers::reference> ref_type;
    typedef scopes::external<wrappers::shared> shared_type;
    typedef scopes::external<wrappers::value> value_type;

public:
    typedef dependency type;
    typedef typename detail::scope_traits<TScope>::type scope;
    typedef TExpected expected;
    typedef TGiven given;
    typedef TBind bind;

    template<typename T>
    struct rebind {
        typedef dependency<
            typename mpl::if_<
                is_same<scope, scopes::deduce>
              , T
              , TScope
            >::type
          , TExpected
          , TGiven
          , TBind
        > other;
    };

    dependency();

    template<typename T>
    explicit dependency(const T&);

    template<typename T>
    static dependency<value_type, expected, T, TBind>
    to(const T&, typename disable_if<is_reference_wrapper<T> >::type* = 0
               , typename disable_if<di::type_traits::has_call_operator<T> >::type* = 0);

    template<typename T>
    static dependency<ref_type, typename unwrap_reference<T>::type, T, TBind>
    to(const T&, typename enable_if<is_reference_wrapper<T> >::type* = 0
               , typename disable_if<di::type_traits::has_call_operator<T> >::type* = 0);

    template<typename T>
    static dependency<typename get_wrapper<T>::type, expected, T, TBind>
    to(const T&, typename disable_if<is_reference_wrapper<T> >::type* = 0
               , typename enable_if<di::type_traits::has_call_operator<T> >::type* = 0);

    template<typename T>
    static dependency<shared_type, expected, T>
    to(const std::shared_ptr<T>&);
};

} // namespace concepts
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/concepts/dependency_ut.cpp]]]
]
[endsect]

[section Header <boost/di/concepts/scope.hpp>]
```
namespace boost {
namespace di {
namespace concepts {

template<
    typename TScope
  , template<
        typename
      , typename
      , typename
      , typename
    > class TDependency
>
class scope {
public:
    template<typename... T>
    struct bind;
};

} // namespace concepts
} // namespace di
} // namespace boost
```
[endsect]

[section Header <boost/di/concepts/detail/requires.hpp>]
```
namespace boost {
namespace di {
namespace concepts {
namespace detail {

template<typename... T
class requires_ {
public:
    template<
        typename T
      , typename TMultiplicationFactor = mpl::integral_c<long, 10>
    >
    struct apply;
};

} // namespace detail
} // namespace concepts
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/concepts/detail/requires_ut.cpp]]]
]
[endsect]

[section Header <boost/di/concepts/detail/when.hpp>]
```
namespace boost {
namespace di {
namespace concepts {
namespace detail {

template<typename TContext>
class when_ {
public:
    template<typename T>
    struct apply;
};

} // namespace detail
} // namespace concepts
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/concepts/detail/when_ut.cpp]]]
]
[endsect]

[section Header <boost/di/concepts/type_traits/is_required_name.hpp>]
```
namespace boost {
namespace di {
namespace concepts {
namespace type_traits {

template<typename TName>
class is_required_name {
public:
    template<typename T>
    struct apply;
};

} // namespace type_traits
} // namespace concepts
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/concepts/type_traits/is_required_name_ut.cpp]]]
]
[endsect]

[section Header <boost/di/concepts/type_traits/is_required_priority.hpp>]
```
namespace boost {
namespace di {
namespace concepts {
namespace type_traits {

struct is_required_priority {
    template<typename T>
    struct apply;
};

} // namespace type_traits
} // namespace concepts
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/concepts/type_traits/is_required_priority_ut.cpp]]]
]
[endsect]

[section Header <boost/di/concepts/type_traits/is_required_type.hpp>]
```
namespace boost {
namespace di {
namespace concepts {
namespace type_traits {

template<typename TValueType, typename = void>
struct is_required_type {
    template<typename T>
    struct apply;
};

template<typename TValueType>
struct is_required_type<TValueType, typename enable_if<mpl::is_sequence<TValueType> >::type> {
    template<typename T>
    struct apply;
};

} // namespace type_traits
} // namespace concepts
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/concepts/type_traits/is_required_type_ut.cpp]]]
]
[endsect]

[endsect]

[section Scopes]

[section Header <boost/di/scopes/deduce.hpp>]
```
namespace boost {
namespace di {
namespace scopes {

class deduce {
public:
    typedef mpl::int_<0> priority;

    template<typename, typename>
    struct scope {
        typedef none_t result_type;
    };
};

} // namespace scopes
} // namespace di
} // namespace boost
```
[endsect]

[section Header <boost/di/scopes/external.hpp>]
```
namespace boost {
namespace di {
namespace scopes {

template<template<typename> class TWrapper = wrappers::value>
class external {
public:
    typedef mpl::int_<1> priority;

    template<typename TExpected, typename = TExpected>
    class scope {
    public:
        typedef TWrapper<TExpected> result_type;

        template<typename T>
        explicit scope(const T&, typename enable_if_c<type_traits::has_call_operator<T>::value>::type* = 0);

        template<typename T>
        explicit scope(const T&, typename disable_if_c<type_traits::has_call_operator<T>::value>::type* = 0);

        template<typename.. TArgs>
        result_type create(TArgs&&...);
    };
};

} // namespace scopes
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/scopes/external_ut.cpp]]]
]
[endsect]

[section Header <boost/di/scopes/session.hpp>]
```
namespace boost {
namespace di {
namespace scopes {

class session_entry { };
class session_exit { };

template<template<typename> class TWrapper = wrappers::shared>
class session {
public:
    typedef mpl::int_<0> priority;

    template<typename TExpected, typename TGiven = TExpected>
    class scope {
    public:
        typedef TWrapper<TExpected> result_type;

        void call(const session_entry&);
        void call(const session_exit&);

        template<typename.. TArgs>
        result_type create(TArgs&&...);
    };
};

} // namespace scopes
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/scopes/session_ut.cpp]]]
]
[endsect]

[section Header <boost/di/scopes/shared.hpp>]
```
namespace boost {
namespace di {
namespace scopes {

template<template<typename> class TWrapper = wrappers::shared>
class shared {
public:
    typedef mpl::int_<0> priority;

    template<typename TExpected, typename TGiven = TExpected>
    class scope {
    public:
        typedef TWrapper<TExpected> result_type;

        template<typename.. TArgs>
        result_type create(TArgs&&...);
    };
};

} // namespace scopes
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/scopes/shared_ut.cpp]]]
]
[endsect]

[section Header <boost/di/scopes/unique.hpp>]
```
namespace boost {
namespace di {
namespace scopes {

template<template<typename> class TWrapper = wrappers::copy>
class unique {
public:
    typedef mpl::int_<0> priority;

    template<typename TExpected, typename TGiven = TExpected>
    class scope {
    public:
        typedef TWrapper<TExpected> result_type;

        template<typename.. TArgs>
        result_type create(TArgs&&...);
    };
};

} // namespace scopes
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/scopes/unique_ut.cpp]]]
]
[endsect]

[endsect]

[section Policies]

[section Header <boost/di/policies/arguments_permission.hpp>]
```
namespace boost {
namespace di {
namespace policies {

struct allow_smart_ptrs;
struct allow_refs;
struct allow_const_refs;
struct allow_rvalue_refs;
struct allow_ptrs;
struct allow_copies;

template<typename... T>
class arguments_permission {
public:
    template<typename TDependency>
    void assert_policy() const;
};

} // namespace policies
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/policies/arguments_permission_ut.cpp]]]
]
[endsect]

[section Header <boost/di/policies/circular_dependencies.hpp>]
```
namespace boost {
namespace di {
namespace policies {

class circular_dependencies {
public:
    template<typename TDependency>
    void assert_policy() const;
};

} // namespace policies
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/policies/circular_dependencies_ut.cpp]]]
]
[endsect]

[section Header <boost/di/policies/creation_ownership.hpp>]
```
namespace boost {
namespace di {
namespace policies {

class creation_ownership {
public:
    template<typename TDependency>
    typename disable_if<is_result_type_reference<TDependency> >::type
    assert_policy() const;

    template<typename TDependency>
    typename enable_if<is_result_type_reference<TDependency> >::type
    assert_policy() const;
};

} // namespace policies
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/policies/creation_ownership_ut.cpp]]]
]
[endsect]

[section Header <boost/di/policies/scopes_permission.hpp>]
```
namespace boost {
namespace di {
namespace policies {

template<typename TScope>
struct allow_scope;

template<typename... T>
class scopes_permission {
public:
    template<typename TDependency>
    void assert_policy() const;
};

} // namespace policies
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/policies/scopes_permission_ut.cpp]]]
]
[endsect]

[endsect]

[section Type Traits]

[section Header <boost/di/type_traits/create_traits.hpp>]
```
namespace boost {
namespace di {
namespace type_traits {

template<typename, typename = void>
struct is_mpl_string;

template<typename T>
struct is_explicit;

template<typename TExpected, typename TGiven>
typename disable_if<is_explicit<TGiven>, TExpected*>::type
create_traits();

template<typename TExpected, typename TGiven>
typename enable_if<has_value<TGiven>, TExpected*>::type
create_traits();

template<typename TExpected, typename TGiven>
typename enable_if<is_mpl_string<TGiven>, TExpected*>::type
create_traits();

template<typename TExpected, typename TGiven, typename TArgs...>
TExpected* create_traits(TArgs&&...);

} // namespace type_traits
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/type_traits/create_traits_ut.cpp]]]
]
[endsect]

[section Header <boost/di/type_traits/ctor_traits.hpp>]
```
namespace boost {
namespace di {

namespace detail {

struct any_type;

template<typename T>
struct get_value;

template<typename T>
struct get_longest_ctor;

} // namespace detail

namespace type_traits {

template<typename T, typename = void>
struct ctor_traits;

} // namespace type_traits
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/type_traits/ctor_traits_ut.cpp]]]
]
[endsect]

[section Header <boost/di/type_traits/has_call.hpp>]
```
namespace boost {
namespace di {
namespace type_traits {

namespace detail {

template<typename T>
class has_call_impl;

} // namespace detail

template<
    typename T
  , typename TAction
>
class has_call;

} // namespace type_traits
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/type_traits/has_call_ut.cpp]]]
]
[endsect]

[section Header <boost/di/type_traits/has_call_operator.hpp>]
```
namespace boost {
namespace di {
namespace type_traits {

template<typename T>
class has_call_operator;

} // namespace type_traits
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/type_traits/has_call_operator_ut.cpp]]]
]
[endsect]

[section Header <boost/di/type_traits/has_configure.hpp>]
```
namespace boost {
namespace di {
namespace type_traits {

template<typename T>
class has_configure;

} // namespace type_traits
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/type_traits/has_configure_ut.cpp]]]
]
[endsect]

[section Header <boost/di/type_traits/has_ctor.hpp>]
```
namespace boost {
namespace di {
namespace type_traits {

template<typename T, typename TArgumentsSize>
class has_ctor;

} // namespace type_traits
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/type_traits/has_ctor_ut.cpp]]]
]
[endsect]

[section Header <boost/di/type_traits/has_injector.hpp>]
```
namespace boost {
namespace di {
namespace type_traits {

template<typename T>
class BOOST_PP_CAT(has_, BOOST_DI_INJECTOR);

} // namespace type_traits
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/type_traits/has_injector_ut.cpp]]]
]
[endsect]

[section Header <boost/di/type_traits/has_value.hpp>]
```
namespace boost {
namespace di {
namespace type_traits {

template<typename T>
class has_value;

} // namespace type_traits
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/type_traits/has_value_ut.cpp]]]
]
[endsect]

[section Header <boost/di/type_traits/is_convertible_to_ref.hpp>]
```
namespace boost {
namespace di {
namespace type_traits {

namespace detail {

template<
    typename T
  , typename TSignature
>
class is_convertible;

} // namespace detail

template<
    typename TValueType
  , typename T
>
struct is_convertible_to_ref;

} // namespace type_traits
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/type_traits/is_convertible_to_ref_ut.cpp]]]
]
[endsect]

[section Header <boost/di/type_traits/is_same_base_of.hpp>]
```
namespace boost {
namespace di {
namespace type_traits {

template<typename T, typename U = mpl::_1>
struct is_same_base_of

} // namespace type_traits
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/type_traits/is_same_base_of_ut.cpp]]]
]
[endsect]

[section Header <boost/di/type_traits/make_plain.hpp>]
```
namespace boost {
namespace di {
namespace type_traits {

template<typename T>
struct make_plain;

} // namespace type_traits
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/type_traits/make_plain_ut.cpp]]]
]
[endsect]

[section Header <boost/di/type_traits/parameter_types.hpp>]
```
namespace boost {
namespace di {
namespace type_traits {

template<typename R, TArgs...>
struct parameter_types<R(*)(TArgs...)>;

template<typename R, typename T, TArgs...>
struct parameter_types<R(T::*)(TArgs...)>;

template<typename R, typename T, TArgs...>
struct parameter_types<R(T::*)(TArgs...) const>;

} // namespace type_traits
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/type_traits/parameter_types_ut.cpp]]]
]
[endsect]

[section Header <boost/di/type_traits/remove_accessors.hpp>]
```
namespace boost {
namespace di {
namespace type_traits {

template<typename T>
struct remove_accessors;

} // namespace type_traits
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/type_traits/remove_accessors_ut.cpp]]]
]
[endsect]

[section Header <boost/di/type_traits/scope_traits.hpp>]
```
namespace boost {
namespace di {
namespace type_traits {

template<typename>
struct scope_traits;

} // namespace type_traits
} // namespace di
} // namespace boost
```[table
    [[Tests: [@test/ut/type_traits/scope_traits_ut.cpp]]]
]
[endsect]

[endsect]

[section Wrappers]

[section Header <boost/di/wrappers/copy.hpp>]
```
namespace boost {
namespace di {
namespace wrappers {

template<typename T>
class copy {
public:
    template<typename TValueType>
    copy(const TValueType&); // non explicit

    template<typename I>
    I operator()(const type<I>&, typename disable_if<is_polymorphic<I> >::type* = 0) const;

    template<typename I>
    I* operator()(const type<I*>&) const;

    template<typename I>
    const I* operator()(const type<const I*>&) const;

    template<typename I>
    std::shared_ptr<I> operator()(const type<std::shared_ptr<I> >&) const;

    template<typename I>
    shared_ptr<I> operator()(const type<shared_ptr<I> >&) const;

    template<typename I>
    std::auto_ptr<I> operator()(const type<std::auto_ptr<I> >&) const;

    template<typename I>
    std::unique_ptr<I> operator()(const type<std::unique_ptr<I> >&) const;
};

} // namespace wrappers
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/wrappers/copy_ut.cpp]]]
]
[endsect]

[section Header <boost/di/wrappers/reference.hpp>]
```
namespace boost {
namespace di {
namespace wrappers {

template<typename T>
class reference {
public:
    reference(const reference_wrapper<T>&); // non explicit

    T& operator()(const type<T&>&) const;
};
} // namespace wrappers
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/reference_ut.cpp]]]
]
[endsect]

[section Header <boost/di/wrappers/shared.hpp>]
```
namespace boost {
namespace di {
namespace wrappers {

template<typename T>
class shared {
public:
    shared() { }
    shared(const std::shared_ptr<T>&); // non explicit

    bool operator!() const;
    void reset(T* = 0);

    template<typename I>
    std::shared_ptr<I> operator()(const type<std::shared_ptr<I> >&) const;

    template<typename I>
    shared_ptr<I> operator()(const type<shared_ptr<I> >&) const;

    template<typename I>
    std::weak_ptr<I> operator()(const type<std::weak_ptr<I> >&) const;
};

} // namespace wrappers
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/wrappers/shared_ut.cpp]]]
]
[endsect]

[section Header <boost/di/wrappers/universal.hpp>]
```
namespace boost {
namespace di {
namespace wrappers {

namespace detail {

template<typename T>
class universal_impl {
public:
    template<typename TValueType>
    universal(std::vector<std::shared_ptr<void> >&, const TValueType&);

    operator T() const;
};

template<typename T>
class universal_impl<std::auto_ptr<T> > {
public:
    template<typename TValueType>
    universal_impl(std::vector<std::shared_ptr<void> >&, const TValueType&);

    operator std::auto_ptr<T>&();
};

template<typename T>
class universal_impl<const T&> {
public:
    template<typename TValueType>
    universal(std::vector<std::shared_ptr<void> >&, const TValueType&);

    operator const T&() const;
};

template<typename T, typename TName>
class universal_impl<named<T, TName> > {
public:
    template<typename TValueType>
    universal(std::vector<std::shared_ptr<void> >&, const TValueType&);

    operator T() const;
    operator named<T, TName>() const;
};

template<typename T, typename TName>
class universal_impl<named<const T&, TName> > {
public:
    template<typename TValueType>
    universal(std::vector<std::shared_ptr<void> >&, const TValueType&);

    operator named<const T&, TName>() const;
};

template<typename T, typename TName>
class universal_impl<const named<T, TName>&> {
public:
    template<typename TValueType>
    universal(std::vector<std::shared_ptr<void> >&, const TValueType&);

    operator const named<T, TName>&() const;
};

template<typename T, typename TName>
class universal_impl<const named<const T&, TName>&> {
public:
    template<typename TValueType>
    universal(std::vector<std::shared_ptr<void> >&, const TValueType&);

    operator const named<const T&, TName>&() const;
};

} // namespace detail

template<typename T>
class universal : public detail::universal_impl<T> {
public:
    typedef universal type;
    typedef T element_type;

    template<typename TValueType>
    universal(std::vector<std::shared_ptr<void> >&, const TValueType&);
};

} // namespace wrappers
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/wrappers/universal_ut.cpp]]]
]
[endsect]

[section Header <boost/di/wrappers/value.hpp>]
```
namespace boost {
namespace di {
namespace wrappers {

template<typename T>
class value {
public:
    value(const T& value); // non explicit

    T operator()(const type<T>&) const;
    T&& operator()(const type<T&&>&);

    T* operator()(const type<T*>&) const;
    const T* operator()(const type<const T*>&) const;

    template<typename I>
    std::shared_ptr<I> operator()(const type<std::shared_ptr<I> >&) const;

    template<typename I>
    shared_ptr<I> operator()(const type<shared_ptr<I> >&) const;

    template<typename I>
    std::auto_ptr<I> operator()(const type<std::auto_ptr<I> >&) const;

    template<typename I>
    std::unique_ptr<I> operator()(const type<std::unique_ptr<I> >&) const;
};

} // namespace wrappers
} // namespace di
} // namespace boost

```
[table
    [[Tests: [@test/ut/wrappers/value_ut.cpp]]]
]

[endsect]

[endsect]

[endsect]

