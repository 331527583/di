[/
 /
 / Copyright (c) 2014 Krzysztof Jusiak (krzysztof at jusiak dot net)
 /
 / Distributed under the Boost Software License, Version 1.0.
 / (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /
 /]

[section Reference]

[heading:di_hpp Header <boost/di.hpp>]
This header exists simply as a convenience to the user, including all of the headers in the `boost/di` directory.
In case when [link di.overview.configuration BOOST_DI_CFG_NO_PREPROCESSED_HEADERS] is defined appropriate preprocessed file will be used instead.

    // inject
    #include "boost/di/inject.hpp"

    // concepts
    #include "boost/di/concepts.hpp"

    // scopes
    #include "boost/di/scopes/deduce.hpp"
    #include "boost/di/scopes/external.hpp"
    #include "boost/di/scopes/session.hpp"
    #include "boost/di/scopes/shared.hpp"
    #include "boost/di/scopes/unique.hpp"

    // injector
    #include "boost/di/injector.hpp"
    #include "boost/di/make_injector.hpp"

    // utilities
    #include "boost/di/named.hpp"
    #include "boost/di/provider.hpp"

    // policies
    #include "boost/di/policies/parameters_permission.hpp"
    #include "boost/di/policies/circular_dependencies.hpp"
    #include "boost/di/policies/creation_ownership.hpp"
    #include "boost/di/policies/scopes_permission.hpp"

[heading Header <boost/di/inject.hpp>]
```
#define __injections_boost_di_inject_traits__(...)
#define __injections_boost_di_inject__(type, ...)
```
[table
    [[Tests: [@test/ut/inject_va_args_ut.cpp] | [@test/ut/inject_bracket_ut.cpp]]]
]

[heading Header <boost/di/injector.hpp>]
```
namespace boost {
namespace di {

template<typename... T>
class injector {
public:
    typedef TDependecies deps;

    template<typename... TArgs>
    explicit injector(const TArgs&...);

    template<typename T, typename... TPolicies>
    T create(const TPolicies&...);

    template<typename T, typename TAllocator, typename... TPolicies>
    T allocate(const TAllocator&, const TPolicies&...) {

    template<typename T, typename TVisitor>
    T visit(const TVisitor&);

    template<typename TAction>
    void call(const TAction&);
};

} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/injector_ut.cpp] | [@test/mt/injector_mt.cpp]]]
]

[heading Header <boost/di/__injectors_make_injector__.hpp>]
```
namespace boost {
namespace di {

template<typename... TArgs>
injector<typename detail::concepts<mpl::vector<TArgs...>>::type>
inline __injectors_make_injector__(const TArgs&...);

} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/mt/make_injector_mt.cpp]]]
]

[heading Header <boost/di/named.hpp>]
```
namespace boost {
namespace di {

struct no_name { };

template<
    typename T
  , typename TName = no_name
>
class named {
    named& operator=(const named&);

public:
    typedef T named_type;
    typedef TName name;

    named(T); // non explicit
    named(const named&);

    operator T() const;
};

template<
    typename T
  , typename TName
>
class named<const T&, TName> {
    named& operator=(const named&);

public:
    typedef const T& named_type;
    typedef TName name;

    named(const T&); // non explicit
    named(const named&);

    operator const T&() const;
};

template<
    typename T
  , typename TName
>
class named<T&, TName> {
    named& operator=(const named&);

public:
    typedef T& named_type;
    typedef TName name;

    named(T&); // non explicit
    named(const named&);

    operator T&();
};

template<
    typename T
  , typename TName
>
class named<T&&, TName> {
    named& operator=(const named&);

public:
    typedef T&& named_type;
    typedef TName name;

    named(T&&); // non explicit
    named(const named&);

    operator T&&();
};

template<
    typename T
  , typename TName
>
class named<aux::unique_ptr<T>, TName>
{
    named& operator=(const named&);

public:
    typedef aux::unique_ptr<T> named_type;
    typedef TName name;

    named(aux::unique_ptr<T>); // non explicit
    named(const named&);

    operator aux::unique_ptr<T>();
};

template<
    typename T
  , typename TName
>
class named<
    T
  , TName
  , typename enable_if<is_polymorphic<typename type_traits::remove_accessors<T>::type>>::type
> {
public:
    typedef T named_type;
    typedef TName name;
};

} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/named_ut.cpp]]]
]

[heading Header <boost/di/provider.hpp>]
```
namespace boost {
namespace di {

template<typename T>
class provider {
public:
    virtual ~provider() { }
    virtual T get() const = 0;
};

} // namespace di
} // namespace boost
```

[heading Header <boost/di/aux_/config.hpp>]
```
#define BOOST_DI_INJECTOR // boost_di_injector__
#define BOOST_DI_CFG_CTOR_LIMIT_SIZE // 10

#define BOOST_DI_CFG_STD // cpp_11 or cpp_03

#include "boost/di/aux_/config/BOOST_DI_CFG_STD.hpp"

#define BOOST_DI_FEATURE(feature)
#define BOOST_DI_FEATURE_RVALUE_REFERENCES(...)
#define BOOST_DI_FEATURE_NO_RVALUE_REFERENCES(...)
#define BOOST_DI_FEATURE_NO_FUNCTION_TEMPLATE_DEFAULT_ARGS(...)
#define BOOST_DI_FEATURE_FUNCTION_TEMPLATE_DEFAULT_ARGS(...)
#define BOOST_DI_FEATURE_DECLTYPE(...)
#define BOOST_DI_FEATURE_CPP_11_TYPE_TRAITS(...)
#define BOOST_DI_FEATURE_CPP_11_FUNCTIONAL(...)
#define BOOST_DI_FEATURE_EXAMINE_CALL_STACK(...)
#define BOOST_DI_FEATURE_NO_EXAMINE_CALL_STACK(...)

#define BOOST_DI_WKND(wknd)
#define BOOST_DI_WKND_MSVC(...)
#define BOOST_DI_WKND_NO_MSVC(...)

#define BOOST_DI_ASSERT_MSG(c, msg, type)
```

[heading Header <boost/di/aux_/memory.hpp>]
```
namespace boost {
namespace di {
namespace aux {

using ::std::auto_ptr;
using ::std::unique_ptr;
using ::std::shared_ptr;
using ::std::weak_ptr;

} // namespace aux

namespace aux_ {
using ::boost::shared_ptr;
} // namespace aux_

} // namespace boost
} // namespace di
```

[heading Header <boost/di/aux_/config/cpp_03.hpp>]
This header contains configuration when `c++ 03` standard will be used.

```
#define BOOST_DI_CTOR_LIMIT_FROM(begin)
#define BOOST_DI_CTOR_LIMIT_FROM_FORCE(begin)
#define BOOST_DI_TYPES(T)
#define BOOST_DI_TYPES_PASS(T)
#define BOOST_DI_MPL_VECTOR_TYPES_PASS(T)
#define BOOST_DI_ARGS(T, arg)
#define BOOST_DI_ARGS_PASS(arg)
#define BOOST_DI_ARGS_CALL(arg, f)
#define BOOST_DI_FORWARD_ARGS(T, arg)
#define BOOST_DI_ARGS_FORWARD(arg)
#define BOOST_DI_TYPES_MPL_LIMIT_FROM(begin)
#define BOOST_DI_TYPES_MPL_LIMIT_FROM_FORCE(begin)
#define BOOST_DI_TYPES_DEFAULT_MPL(T)
#define BOOST_DI_TYPES_MPL(T)
#define BOOST_DI_TYPES_PASS_MPL(T)
#define BOOST_DI_MPL_VECTOR_TYPES_PASS_MPL(T)
```

[heading Header <boost/di/aux_/config/cpp_11.hpp>]
This header contains configuration when `c++ 11` standard will be used.

```
#define BOOST_DI_CTOR_LIMIT_FROM(begin)
#define BOOST_DI_CTOR_LIMIT_FROM_FORCE(begin)
#define BOOST_DI_TYPES(T)
#define BOOST_DI_TYPES_PASS(T)
#define BOOST_DI_MPL_VECTOR_TYPES_PASS(T)
#define BOOST_DI_ARGS(T, arg)
#define BOOST_DI_ARGS_PASS(arg)
#define BOOST_DI_ARGS_CALL(arg, f)
#define BOOST_DI_FORWARD_ARGS(T, arg)
#define BOOST_DI_ARGS_FORWARD(arg)
#define BOOST_DI_TYPES_MPL_LIMIT_FROM(begin)
#define BOOST_DI_TYPES_MPL_LIMIT_FROM_FORCE(begin)
#define BOOST_DI_TYPES_DEFAULT_MPL(T)
#define BOOST_DI_TYPES_MPL(T)
#define BOOST_DI_TYPES_PASS_MPL(T)
#define BOOST_DI_MPL_VECTOR_TYPES_PASS_MPL(T)
```

[heading Header <boost/di/core/allocator.hpp>]
```
namespace boost {
namespace di {
namespace core {

template<typename>
struct is_mpl_string;

template<typename T>
struct is_explicit;

class allocator {
public:
    template<typename TExpected, typename TGiven>
    typename disable_if<is_explicit<TGiven>, TExpected*>::type
    allocate() const;

    template<typename TExpected, typename TGiven>
    typename enable_if<type_traits::has_value<TGiven>, TExpected*>::type
    allocate() const;

    template<typename TExpected, typename TGiven>
    typename enable_if<is_mpl_string<TGiven>, TExpected*>::type
    allocate() const;

    template<typename TExpected, typename TGiven, typename... TArgs>
    TExpected* allocate(TArgs&&...) const;
};

} // namespace core
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/core/allocator_ut.cpp]]]
]

[heading Header <boost/di/core/any_type.hpp>]
```
namespace boost {
namespace di {
namespace core {

template<
    typename T = none_t
  , typename TCallStack = none_t
  , typename TCreator = none_t
  , typename TAllocator = none_t
  , typename TDeps = none_t
  , typename TRefs = none_t
  , typename TVisitor = none_t
  , typename TPolicies = none_t
>
class any_type {
public:
    any_type() { }

    any_type(TCreator&
           , const TAllocator&
           , TDeps&
           , TRefs&
           , const TVisitor&
           , const TPolicies&);

    any_type(const any_type&);

    template<
        typename U
      , typename = typename disable_if<
            type_traits::is_same_base_of<
                typename type_traits::make_plain<U>::type
              , typename type_traits::make_plain<T>::type
            >
        >::type
    >
    operator const U&() const;

    template<
        typename U
      , typename = typename disable_if<
            type_traits::is_same_base_of<
                typename type_traits::make_plain<U>::type
              , typename type_traits::make_plain<T>::type
            >
        >::type
    >
    operator U&() const;

    template<typename U>
    operator aux::auto_ptr<U>&();

    template<
        typename U
      , typename = typename disable_if<
            type_traits::is_same_base_of<
                typename type_traits::make_plain<U>::type
              , typename type_traits::make_plain<T>::type
            >
        >::type
    >
    operator U();
};

} // namespace core
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/core/any_type_ut.cpp]]]
]

[heading Header <boost/di/core/binder.hpp>]
```
namespace boost {
namespace di {
namespace core {

template<typename TDependecies>
class binder {
public:
    template<
        typename T
      , typename TCallStack
      , typename TDefault =
            ::boost::di::concepts::dependency<
                scopes::deduce
              , typename type_traits::make_plain<T>::type
            >
    >
    struct resolve;
};

} // namespace core
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/core/binder_ut.cpp]]]
]

[heading Header <boost/di/core/creator.hpp>]
```
namespace boost {
namespace di {
namespace core {

template<
    typename TDependecies = mpl::vector0<>
  , template<typename> class TBinder = binder
  , template<
        typename = ::boost::none_t
      , typename = ::boost::none_t
      , typename = ::boost::none_t
      , typename = ::boost::none_t
      , typename = ::boost::none_t
      , typename = ::boost::none_t
      , typename = ::boost::none_t
      , typename = ::boost::none_t
    >
    class TAnyType = ::boost::di::core::any_type
>
class creator {
public:
    explicit creator(const TBinder<TDependecies>& binder = TBinder<TDependecies>());

    template<
        typename T
      , typename TParent // ignore copy/move ctor
      , typename TCallStack
      , typename TAllocator
      , typename TDeps
      , typename TRefs
      , typename TVisitor
      , typename TPolicies
    >
    typename enable_if<
        is_same<T, TAnyType<> >
      , TAnyType<
            TParent
          , TCallStack
          , creator
          , TAllocator
          , TDeps
          , TRefs
          , TVisitor
          , TPolicies
        >
    >::type
    create(const TAllocator&
         , TDeps&
         , TRefs&
         , const TVisitor&
         , const TPolicies&);

    template<
        typename T
      , typename // TParent - not used
      , typename TCallStack
      , typename TAllocator
      , typename TDeps
      , typename TRefs
      , typename TVisitor
      , typename TPolicies
    >
    typename disable_if<is_same<T, TAnyType<> >, wrappers::universal<T> >::type
    create(const TAllocator
         , TDeps&
         , TRefs&
         , const TVisitor&
         , const TPolicies&);
};

} // namespace core
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/core/creator_ut.cpp]]]
]

[heading Header <boost/di/core/module.hpp>]
```
namespace boost {
namespace di {
namespace core {

template<
    typename TDependecies = mpl::vector0<>
  , template<
        typename
      , template<typename> class = ::boost::di::core::binder
      , template<
            typename
          , typename
          , typename
          , typename
          , typename
          , typename
          , typename
          , typename
        >
        class = ::boost::di::core::any_type
    > class TCreator = creator
  , template<
        typename = ::boost::mpl::vector0<>
      , typename = ::boost::di::core::never< ::boost::mpl::_1 >
      , typename = void
    > class TPool = pool
  , typename TDefaultAllocator = allocator
>
class module {
public:
    typedef TDependecies deps;

    template<typename... TArgs>
    explicit module(const TArg&...);

    template<typename T, typename... TPolicies>
    T create(const TPolicies&...);

    template<typename T, typename TAllocator, typename... TPolicies>
    T allocate(const TAllocator&, const TPolicies&...) {

    template<typename T, typename Visitor>
    T visit(const Visitor&);

    template<typename TAction>
    void call(const TAction&);
};

} // namespace core
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/mt/core/module_mt.cpp]]]
]

[heading Header <boost/di/core/pool.hpp>]
```
namespace boost {
namespace di {
namespace core {

class init { };

template<typename>
struct never;

template<
    typename TSeq = mpl::vector0<>
  , typename TIgnore = never<mpl::_1>
>
class pool {
public:
    typedef TSeq types;

    template<typename... T>
    explicit pool(const T&...);

    template<typename T>
    explicit pool(const pool<T>&, const init&);

    template<typename T>
    const T& get() const;
};

} // namespace core
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/core/pool_ut.cpp]]]
]


[heading Header <boost/di/concepts.hpp>]
```
namespace boost {
namespace di {

template<typename TExpected, typename TGiven = TExpected>
struct bind;

template<int N>
struct bind_int;

template<typename T>
struct bind_string;

template<typename TScope>
struct scope;

template<typename... T>
struct deduce;

template<typename... T>
struct unique

template<typename... T>
struct shared;

template<typename... T>
struct session;

template<typename... T>
struct call_stack;

template<typename... T>
struct any_of;

} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/concepts_ut.cpp]]]
]

[heading Header <boost/di/concepts/bind.hpp>]
```
namespace boost {
namespace di {
namespace concepts {

template<
    typename TExpected
  , typename TGiven
  , template<
        typename
      , typename
      , typename
      , typename
    > class TDependency
>
struct bind {
    template<typename... T>
    struct when {
        template<typename TName>
        struct named;
    };

    template<typename TName>
    struct named {
        template<typename... T>
        struct when;
    };
};

} // namespace concepts
} // namespace di
} // namespace boost
```

[heading Header <boost/di/concepts/call_stack.hpp>]
```
namespace boost {
namespace di {
namespace concepts {

template<typename... T>
class call_stack {
public:
    template<typename T>
    struct apply;
};

} // namespace concepts
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/concepts/call_stack_ut.cpp]]]
]

[heading Header <boost/di/concepts/dependency.hpp>]
```
namespace boost {
namespace di {
namespace concepts {

template<
    typename TScope
  , typename TExpected
  , typename TGiven = TExpected
  , typename TBind =
        detail::requires_<
            concepts::type_traits::is_required_priority
          , concepts::type_traits::is_required_type<TExpected>
        >
>
class dependency {
    typedef scopes::external<wrappers::reference> ref_type;
    typedef scopes::external<wrappers::shared> shared_type;
    typedef scopes::external<wrappers::value> value_type;

public:
    typedef dependency type;
    typedef TScope scope;
    typedef TExpected expected;
    typedef TGiven given;
    typedef TBind bind;

    template<typename T>
    struct rebind;

    dependency();

    template<typename T>
    explicit dependency(const T&);

    template<typename T>
    static dependency<value_type, expected, T, TBind>
    to(const T&, typename disable_if<is_reference_wrapper<T> >::type* = 0
               , typename disable_if<di::type_traits::has_call_operator<T> >::type* = 0);

    template<typename T>
    static dependency<ref_type, typename unwrap_reference<T>::type, T, TBind>
    to(const T&, typename enable_if<is_reference_wrapper<T> >::type* = 0);

    template<typename T>
    static dependency<typename get_wrapper<T>::type, expected, T, TBind>
    to(const T&, typename disable_if<is_reference_wrapper<T> >::type* = 0
               , typename enable_if<di::type_traits::has_call_operator<T> >::type* = 0);

    template<typename T>
    static dependency<shared_type, expected, T>
    to(const aux::shared_ptr<T>&);
};

} // namespace concepts
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/concepts/dependency_ut.cpp]]]
]

[heading Header <boost/di/concepts/scope.hpp>]
```
namespace boost {
namespace di {
namespace concepts {

template<
    typename TScope
  , template<
        typename
      , typename
      , typename
      , typename
    > class TDependency
>
class scope {
public:
    template<typename... T>
    struct bind;
};

} // namespace concepts
} // namespace di
} // namespace boost
```

[heading Header <boost/di/concepts/detail/requires.hpp>]
```
namespace boost {
namespace di {
namespace concepts {
namespace detail {

template<typename... T
class requires_ {
public:
    template<
        typename T
      , typename TMultiplicationFactor = mpl::integral_c<long, 10>
    >
    struct apply;
};

} // namespace detail
} // namespace concepts
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/concepts/detail/requires_ut.cpp]]]
]

[heading Header <boost/di/concepts/detail/when.hpp>]
```
namespace boost {
namespace di {
namespace concepts {
namespace detail {

template<typename TContext>
class when_ {
public:
    template<typename T>
    struct apply;
};

} // namespace detail
} // namespace concepts
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/concepts/detail/when_ut.cpp]]]
]

[heading Header <boost/di/concepts/type_traits/is_required_name.hpp>]
```
namespace boost {
namespace di {
namespace concepts {
namespace type_traits {

template<typename TName>
class is_required_name {
public:
    template<typename T>
    struct apply;
};

} // namespace type_traits
} // namespace concepts
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/concepts/type_traits/is_required_name_ut.cpp]]]
]

[heading Header <boost/di/concepts/type_traits/is_required_priority.hpp>]
```
namespace boost {
namespace di {
namespace concepts {
namespace type_traits {

struct is_required_priority {
    template<typename T>
    struct apply;
};

} // namespace type_traits
} // namespace concepts
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/concepts/type_traits/is_required_priority_ut.cpp]]]
]

[heading Header <boost/di/concepts/type_traits/is_required_type.hpp>]
```
namespace boost {
namespace di {
namespace concepts {
namespace type_traits {

template<typename TValueType, typename = void>
struct is_required_type {
    template<typename T>
    struct apply;
};

template<typename TValueType>
struct is_required_type<TValueType, typename enable_if<mpl::is_sequence<TValueType> >::type> {
    template<typename T>
    struct apply;
};

} // namespace type_traits
} // namespace concepts
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/concepts/type_traits/is_required_type_ut.cpp]]]
]

[heading Header <boost/di/scopes/deduce.hpp>]
```
namespace boost {
namespace di {
namespace scopes {

class deduce {
public:
    typedef mpl::int_<0> priority;

    template<typename, typename>
    struct scope;

    template<typename T>
    struct rebind;
};

} // namespace scopes
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/scopes/deduce_ut.cpp]]]
]

[heading Header <boost/di/scopes/external.hpp>]
```
namespace boost {
namespace di {
namespace scopes {

template<template<typename> class TWrapper = wrappers::value>
class external {
public:
    typedef mpl::int_<1> priority;

    template<typename TExpected>
    class scope {
    public:
        typedef TWrapper<T> result_type;

        template<typename T>
        explicit scope(const T&
                     , typename enable_if_c<
                           type_traits::has_call_operator<T>::value &&
                           !is_reference_wrapper<T>::value
                       >::type* = 0);

        template<typename T>
        explicit scope(const T&
                     , typename disable_if_c<
                           type_traits::has_call_operator<T>::value &&
                           !is_reference_wrapper<T>::value
                       >::type* = 0);

        result_type create();
    };
};

} // namespace scopes
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/scopes/external_ut.cpp]]]
]

[heading Header <boost/di/scopes/session.hpp>]
```
namespace boost {
namespace di {
namespace scopes {

class session_entry { };
class session_exit { };

template<template<typename> class TWrapper = wrappers::shared>
class session {
public:
    typedef mpl::int_<0> priority;

    template<typename TExpected>
    class scope {
    public:
        typedef TWrapper<TExpected> result_type;

        void call(const session_entry&);
        void call(const session_exit&);

        result_type create(const function<TExpected*()>&);
    };
};

} // namespace scopes
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/scopes/session_ut.cpp]]]
]

[heading Header <boost/di/scopes/shared.hpp>]
```
namespace boost {
namespace di {
namespace scopes {

template<template<typename> class TWrapper = wrappers::shared>
class shared {
public:
    typedef mpl::int_<0> priority;

    template<typename TExpected>
    class scope {
    public:
        typedef TWrapper<TExpected> result_type;

        result_type create(const function<TExpected*()>&);
    };
};

} // namespace scopes
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/scopes/shared_ut.cpp]]]
]

[heading Header <boost/di/scopes/unique.hpp>]
```
namespace boost {
namespace di {
namespace scopes {

template<template<typename> class TWrapper = wrappers::copy>
class unique {
public:
    typedef mpl::int_<0> priority;

    template<typename TExpected>
    class scope {
    public:
        typedef TWrapper<TExpected> result_type;

        result_type create(const function<TExpected*()>&);
    };
};

} // namespace scopes
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/scopes/unique_ut.cpp]]]
]

[heading Header <boost/di/policies/circular_dependencies.hpp>]
```
namespace boost {
namespace di {
namespace policies {

class circular_dependencies {
public:
    template<typename TDependency>
    void assert_policy() const;
};

} // namespace policies
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/policies/circular_dependencies_ut.cpp]]]
]

[heading Header <boost/di/policies/creation_ownership.hpp>]
```
namespace boost {
namespace di {
namespace policies {

class creation_ownership {
public:
    template<typename TDependency>
    typename disable_if<is_result_type_reference<TDependency> >::type
    assert_policy() const;

    template<typename TDependency>
    typename enable_if<is_result_type_reference<TDependency> >::type
    assert_policy() const;
};

} // namespace policies
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/policies/creation_ownership_ut.cpp]]]
]

[heading Header <boost/di/policies/parameters_permission.hpp>]
```
namespace boost {
namespace di {
namespace policies {

struct allow_smart_ptrs;
struct allow_refs;
struct allow_const_refs;
struct allow_rvalue_refs;
struct allow_ptrs;
struct allow_copies;

template<typename... T>
class parameters_permission {
public:
    template<typename TDependency>
    void assert_policy() const;
};

} // namespace policies
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/policies/parameters_permission_ut.cpp]]]
]

[heading Header <boost/di/policies/scopes_permission.hpp>]
```
namespace boost {
namespace di {
namespace policies {

template<typename TScope>
struct allow_scope;

template<>
struct allow_scope<scopes::deduce>; // disabled

template<typename... T>
class scopes_permission {
public:
    template<typename TDependency>
    void assert_policy() const;
};

} // namespace policies
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/policies/scopes_permission_ut.cpp]]]
]

[heading Header <boost/di/wrappers/copy.hpp>]
```
namespace boost {
namespace di {
namespace wrappers {

template<typename T>
class copy {
public:
    template<typename TValueType>
    copy(const TValueType&); // non explicit

    template<typename I>
    I operator()(const type<I>&, typename disable_if<is_polymorphic<I> >::type* = 0) const;

    template<typename I>
    I* operator()(const type<I*>&) const;

    template<typename I>
    const I* operator()(const type<const I*>&) const;

    template<typename I>
    std::shared_ptr<I> operator()(const type<std::shared_ptr<I> >&) const;

    template<typename I>
    shared_ptr<I> operator()(const type<shared_ptr<I> >&) const;

    template<typename I>
    std::auto_ptr<I> operator()(const type<std::auto_ptr<I> >&) const;

    template<typename I>
    std::unique_ptr<I> operator()(const type<std::unique_ptr<I> >&) const;
};

} // namespace wrappers
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/wrappers/copy_ut.cpp]]]
]

[heading Header <boost/di/wrappers/reference.hpp>]
```
namespace boost {
namespace di {
namespace wrappers {

template<typename T>
class reference {
public:
    reference(const reference_wrapper<T>&); // non explicit

    T& operator()(const type<T&>&) const;
};
} // namespace wrappers
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/reference_ut.cpp]]]
]

[heading Header <boost/di/wrappers/shared.hpp>]
```
namespace boost {
namespace di {
namespace wrappers {

template<typename T>
class shared {
public:
    shared() { }
    shared(const std::shared_ptr<T>&); // non explicit

    bool operator!() const;
    void reset(T* = 0);

    template<typename I>
    std::shared_ptr<I> operator()(const type<std::shared_ptr<I> >&) const;

    template<typename I>
    shared_ptr<I> operator()(const type<shared_ptr<I> >&) const;

    template<typename I>
    std::weak_ptr<I> operator()(const type<std::weak_ptr<I> >&) const;
};

} // namespace wrappers
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/wrappers/shared_ut.cpp]]]
]

[heading Header <boost/di/wrappers/universal.hpp>]
```
namespace boost {
namespace di {
namespace wrappers {

namespace detail {

template<typename T>
class universal_impl {
public:
    template<typename TValueType>
    universal(std::vector<std::shared_ptr<void> >&, const TValueType&);

    operator T() const;
};

template<typename T>
class universal_impl<std::auto_ptr<T> > {
public:
    template<typename TValueType>
    universal_impl(std::vector<std::shared_ptr<void> >&, const TValueType&);

    operator std::auto_ptr<T>&();
};

template<typename T>
class universal_impl<const T&> {
public:
    template<typename TValueType>
    universal(std::vector<std::shared_ptr<void> >&, const TValueType&);

    operator const T&() const;
};

template<typename T, typename TName>
class universal_impl<named<T, TName> > {
public:
    template<typename TValueType>
    universal(std::vector<std::shared_ptr<void> >&, const TValueType&);

    operator T() const;
    operator named<T, TName>() const;
};

template<typename T, typename TName>
class universal_impl<named<const T&, TName> > {
public:
    template<typename TValueType>
    universal(std::vector<std::shared_ptr<void> >&, const TValueType&);

    operator named<const T&, TName>() const;
};

template<typename T, typename TName>
class universal_impl<const named<T, TName>&> {
public:
    template<typename TValueType>
    universal(std::vector<std::shared_ptr<void> >&, const TValueType&);

    operator const named<T, TName>&() const;
};

template<typename T, typename TName>
class universal_impl<const named<const T&, TName>&> {
public:
    template<typename TValueType>
    universal(std::vector<std::shared_ptr<void> >&, const TValueType&);

    operator const named<const T&, TName>&() const;
};

} // namespace detail

template<typename T>
class universal : public detail::universal_impl<T> {
public:
    typedef universal type;
    typedef T element_type;

    template<typename TValueType>
    universal(std::vector<std::shared_ptr<void> >&, const TValueType&);
};

} // namespace wrappers
} // namespace di
} // namespace boost
```
[table
    [[Tests: [@test/ut/wrappers/universal_ut.cpp]]]
]

[heading Header <boost/di/wrappers/value.hpp>]
```
namespace boost {
namespace di {
namespace wrappers {

template<typename T>
class value {
public:
    value(const T& value); // non explicit

    T operator()(const type<T>&) const;
    T&& operator()(const type<T&&>&);

    T* operator()(const type<T*>&) const;
    const T* operator()(const type<const T*>&) const;

    template<typename I>
    std::shared_ptr<I> operator()(const type<std::shared_ptr<I> >&) const;

    template<typename I>
    shared_ptr<I> operator()(const type<shared_ptr<I> >&) const;

    template<typename I>
    std::auto_ptr<I> operator()(const type<std::auto_ptr<I> >&) const;

    template<typename I>
    std::unique_ptr<I> operator()(const type<std::unique_ptr<I> >&) const;
};

} // namespace wrappers
} // namespace di
} // namespace boost

```
[table
    [[Tests: [@test/ut/wrappers/value_ut.cpp]]]
]

[endsect]

