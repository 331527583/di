[def __BOOST_DI_INJECT [link di.reference.ctor `BOOST_DI_INJECT `]]

[section Concepts]

[section Constructor Injection]

Constructor injection is the most powerful of the available injections. It guarantee initialized state of data members.
Within DI, by default, is achieved without any additional work from the user than defining the constructor.
Library will go through the constructors and choose the longest one to pass the dependencies.

```
class example
{
public:
    example(int);
    example(int, double);
    example(int, double, float); // will be deduced by DI
};
```

If the default behavior should be changed there is a way of explicitly saying which constructor should be deduced by adding
BOOST_DI_INJECT to the constructor definition.

[note DI is not able to distinguish between ambiguous constructors with the same (longest) amount of parameters, then BOOST_DI_INJECT has to be used to point which constructor should be dedced]

[h5 BOOST_DI_INJECT]

```
class example
{
public:
    example(int);
    BOOST_DI_INJECT(example, int, double); // will be deduced by DI
    example(int, double, float);
};
```

[note In C++03 additional brackets are needed: `BOOST_DI_INJECT(example, (int, double))`]
[tip Requirement of brackets in BOOST_DI_INJECT might be switched with `BOOST_DI_CFG_INJECT_VA_ARGS` and `BOOST_DI_CFG_INJECT_BRACKET` ]

Sometimes we can't, in case of third party libraries, or just don't want to be so intrusive, then we can use constructor traits to define
which constructor should be deduced by DI.

[h5 BOOST_DI_INJECT_TRAITS]

```
template<>
struct ctor_traits<example>
{
    BOOST_DI_INJECT_TRAITS(int, double, float);
};

```

[note BOOST_DI_INJECT_TRAITS might be also defined within the class, useful in case of named parameters]

[endsect]

[section Binding]

Binding in DI is done using provided DSL. The main purpose of binding DSL is to make easy things as easy
as possible whilst giving possibility to accomplish more complicated problems.
The glue between binding DSL and the core is dependency, so if you would like to write your own front end
the only thing which you have to have in mind is to return list of dependencies.

```
template<
    typename TScope
  , typename TExpected
  , typename TGiven
  , typename TBind
>
class dependency;
```

```
template<typename If, typename Impl>
struct bind
    : concepts::dependency<scopes::deduce, If, Impl>
{ };
```

DSL released with the library allows you to bind:

```
bind_int<42>();

bind<int>::to(42);
bind<std::string>::to("text");

bind<example>::to(make_shared<example>());
bind<example>::to(cref(example_));
bind<example>::to(ref(example_));

bind<interface, implementation>();
```
[endsect]

[section Injector]
[endsect]

[section Named Parameters]
[endsect]

[section Provider]
[endsect]

[endsect]

