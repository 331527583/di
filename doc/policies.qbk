[/
 /
 / Copyright (c) 2014 Krzysztof Jusiak (krzysztof at jusiak dot net)
 /
 / Distributed under the Boost Software License, Version 1.0.
 / (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /
 /]

[section Policies]

Policies are compile time components operates on dependencies in order to limit allowed behaviour.
Policy has to have `assert_policy` method defined.

```
class policy {
public:
    template<typename TDependency>
    void assert_policy() const;
};
```

In order for `injector` to verify policies they have to be passed to `create`, `allocate` call.
```
    di::make_injector().create<int>(policy1(), policy2(), ..., policyN());
```

```
    di::make_injector().allocate<int>(allocator(), policy1(), policy2(), ..., policyN());
```

[table
    [[Example policy: [@example/cpp_11/custom_policy.cpp]]]
]

`Boost.DI` is released with following policies

* `Circular Dependencies` - verify circular dependencies occurrence
* `Creation Ownership`  - verify objection creation permission
* `Parameters Permission` - verify constructor parameters permission
* `Scopes Permission` - verify scopes configuration permission

[note By Default `Boost.DI` has no policies enabled.]

[section circular_dependencies]

[h5 Synopsis]
```
class circular_dependencies {
public:
    template<typename TDependency>
    void assert_policy() const;
};
```

[h5 Description]
`Circular Dependencies` policy verifies constructor parameters overlapping.

[h5 Example]
```
    di::make_injector().create<int>(di::policies::circular_dependencies()); // compile ok
```

```
    struct cd2;
    struct cd1 { cd1(cd2*); };
    struct cd2 { cd2(cd1*); };

    di::make_injector().create<cd1>(di::policies::circular_dependencies()); // compile error
```
[note Requires `BOOST_DI_CFG_EXAMINE_CALL_STACK` to be defined.]

[h5 Usage]

[table
    [[Tests: [@test/ut/policies/circular_dependencies_ut.cpp]]]
]

[endsect]

[section creation_ownership]

[h5 Synopsis]
```
class creation_ownership {
public:
    template<typename TDependency>
    void assert_policy() const;
};
```

[h5 Description]
`Creation Ownership` policy limits creation types to copies/pointers/smart pointers and disallow references.

[h5 Example]
```
    di::make_injector().create<int>(di::policies::creation_ownership()); // compile ok
```

```
    di::make_injector().create<const int&>(di::policies::creation_ownership()); // compile error
```

```
    di::make_injector().create<int&>(di::policies::creation_ownership()); // compile error
```
[note Requires `BOOST_DI_CFG_EXAMINE_CALL_STACK` to be defined.]

[h5 Usage]

[table
    [[Tests: [@test/ut/policies/creation_ownership_ut.cpp]]]
]

[endsect]

[section parameters_permission]

[h5 Synopsis]
```
    struct allow_smart_ptrs;
    struct allow_refs;
    struct allow_const_refs;
    struct allow_rvalue_refs;
    struct allow_ptrs;
    struct allow_copies;

    template<typename... T>
    class parameters_permission {
    public:
        template<typename TDependency>
        void assert_policy() const;
    };
```

[h5 Description]
`Parameters Permission` policy limits allowed constructor parameters. By default, if used, all parameters are disallowed.

[h5 Example]
```
    using namespace di::policies;
```

```
    di::make_injector().create<int>(parameters_permission<>()); // compile error, no parameters are allowed
```

```
    di::make_injector().create<int>(parameters_permission<allow_copies>()); // compile ok
```

```
    struct example {
        example(std::vector<int*>, std::shared_ptr<int>, const int&);
    };

    Parameters
        * std::vector<int*> -> allow_copies
            * int* -> allow_ptrs
        * std::shared_ptr<int> -> allow_smart_ptrs
        * const int& -> allow_const_refs

    di::make_injector().create<example>(
        parameters_permission<allow_copies, allow_ptrs, allow_smart_ptrs, allow_const_refs>()
    ); // compile ok
```
[warning `Parameters Permission` policy is not supported by Microsoft Visual Studio.]

[h5 Usage]

[table
    [[Tests: [@test/ut/policies/parameters_permission_ut.cpp]]]
]

[endsect]

[section scopes_permission]
`Scopes Permission` policy limits allowed scopes to be used whilst binding.  By default, if used, all scopes are disallowed.

[h5 Synopsis]
```
    template<typename TScope>
    struct allow_scope;

    template<>
    struct allow_scope<scopes::deduce>; // disabled

    template<typename... T>
    class scopes_permission {
    public:
        template<typename TDependency>
        void assert_policy() const;
    };
```

[h5 Allowed Scopes]
```
    allow_scope<scopes::unique<>>
    allow_scope<scopes::shared<>>
    allow_scope<scopes::session<>>
    allow_scope<scopes::external<>>
```

[note `allow_scope<scopes::deduce>` is not allowed.]

[h5 Example]

```
    using namespace di::policies;
```

```
    di::make_injector().create<int>(scopes_permission<>()); // compile error, no scopes are allowed
```

```
    di::make_injector(
        di::unique<int>()
    ).create<int>(scopes_permission<allow_scope<di::scopes::unique<>>>()); // compile ok
```

```
    di::make_injector(
        di::shared<int>()
    ).create<int>(scopes_permission<allow_scope<di::scopes::unique<>>>()); // compile error
```

```
    struct example {
        example(std::shared_ptr<int>);
    };

    di::make_injector(
        di::deduce<int>()
    ).create<example>(scopes_permission<allow_scope<di::scopes::unique<>>>()); // compile error
```

```
    struct example {
        example(int);
    };

    di::make_injector(
        di::deduce<int>()
    ).create<example>(scopes_permission<allow_scope<di::scopes::unique<>>>()); // compile ok
```

To understand `scope deduction` mapping see `Deduce Scope`.

[h5 Usage]

[table
    [[Tests: [@test/ut/policies/scopes_permission_ut.cpp]]]
]

[endsect]

[endsect]

