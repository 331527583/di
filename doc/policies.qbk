[/
 /
 / Copyright (c) 2014 Krzysztof Jusiak (krzysztof at jusiak dot net)
 /
 / Distributed under the Boost Software License, Version 1.0.
 / (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /
 /]

[section Policies]

[heading Description]
Policies are compile time components operates on dependencies in order to limit allowed behaviour or visit created types during run-time.
Policy has to be callable with at least one given type.
In order for __injectors_injector__ to verify policies they have to be passed using __di_config__ to __injectors_injector__ (per injector) or defined globally 
`Boost.DI` is released with following policies.

* __policies_allow_ctor_types__ - limit constructor parameters

[note By Default `Boost.DI` has no policies enabled.]

[heading Synopsis]
    class policy {
    public:
        template<class T> void operator()(T)
        const noexcept;

        template<class T, class TDependency, class... TCtor>
        void operator()(T, TDependency, TCtor...) const noexcept;
    };

[table Parameters
    [[Parameter][Requirement][Description][Throw]]
    [[`T`][None][Constructor parameter type]]
    [[`TDependency`][__dependency_model__][Dependency used to resolve object]]
    [[`TCtor...`][None][Constructor parameters]]
    [[`operator()`][None][Verify policy requirements][Does not throw]]
]

[heading Namespace]
    boost::di::policies

[heading Examples]
    class print_types_policy : public __di_config__ {
    public:
        auto policies() const noexcept {
            return __di_make_policies__(
                [](auto type){
                    using T = decltype(type);
                    using arg = typename T::type;
                    cout << typeid(arg).name() << endl;
                }
            );
        }
    };

    // per injector policy
    auto injector = __di_make_injector__<print_types_policy>();
    injector.__di_injector_create__<int>(); // output: int

    // global policy
    #define BOOST_DI_CFG my_policy
    auto injector = __di_make_injector__();
    injector.__di_injector_create__<int>(); // output: int

[heading More Examples]
    ``__examples_custom_policy__``

[heading See Also]

* __policies_allow_ctor_types__

[section allow_ctor_types]

[heading Description]
Limits default constructible types not be created unless they are explicitly bound or allowed.

[heading Allow Type Model]
    template<class TValueType>
    class allow_type_model {
    public:
        template<class T>
        struct allow; // returns boolean expression
    };

[table Parameters
    [[Parameter][Requirement][Description]]
    [[`TValueType`][None][Type to be allowed]]
    [[`T`][None][__data_model__ parameter type]]
]

[heading Synopsis]
    template<class>
    struct allow_type;

    template<class>
    struct allow_type_expr;

    template<class... TArgs>
    class creation_permission {
    public:
        template<class T>
        void assert_policy() const;
    };

[table Parameters
    [[Parameter][Requirement][Description][Throw]]
    [[`TArgs...`][__allow_type_model__ type][Type to be allowed]]
    [[`T`][__data_model__ type][Data to be verified]]
    [[`assert_policy()`][None][Verify policy requirements][Does not throw]]
]

[heading Expression Semantics]
    using namespace di::policies;
    di::policies::creation_permission<TArgs...>() // TArgs will be verified using `or` semantic

[*Result]: static assert with `TYPE_HAS_TO_BE_EXPLICITLY_BINDED` message or clean compilation.

[heading Header]
    #include <__di_hpp__>

[heading Namespace]
    boost::di::policies

[heading Examples]
    using namespace di::policies;

    __di_make_injector__().__di_injector_create__<int>(creation_permission<>()); // compile error
    __di_make_injector__(__di_bind_int__<42>()).__di_injector_create__<int>(creation_permission<>()); // compile ok
    __di_make_injector__().__di_injector_create__<int>(creation_permission<allow_type<int>>()); // compile ok
    __di_make_injector__().__di_injector_create__<int>(creation_permission<allow_type_expr<is_pod<mpl::_>>>()); // compile ok

[heading Tests]
    ``[@test/ut/policies/creation_permission_ut.cpp]``

[heading See Also]

* __policies__
* __policies_circular_dependencies__
* __policies_parameters_permission__
* __policies_scopes_permission__

[heading Description]
Limits allowed constructor parameters. By default, if used, all parameters are disallowed.

[heading Allow Parameter Model]
    template<class TParameter>
    class allow_parameter_model {
    public:
        template<class T>
        struct allow; // returns boolean expression
    };

[table Parameters
    [[Parameter][Requirement][Description]]
    [[`TParameter`][None][Parameter to be allowed]]
    [[`T`][None][__data_model__ type]]
]

[heading Synopsis]
    struct allow_smart_ptrs;
    struct allow_refs;
    struct allow_const_refs;
    struct allow_rvalue_refs;
    struct allow_ptrs;
    struct allow_copies;

    template<class... TArgs>
    class parameters_permission {
    public:
        template<class TDependency>
        void assert_policy();
    };

[table Parameters
    [[Parameter][Requirement][Description][Throw]]
    [[`TArgs...`][__allow_parameter_model__ type][Parameters to be allowed]]
    [[`T`][__data_model__ type][Data to be verified]]
    [[`assert_policy()`][None][Verify policy requirements][Does not throw]]
]

[heading Expression Semantics]
    using namespace di::policies;
    parameters_permission<allow_refs, allow_smart_ptrs, ..., allow_copies>() // TArgs will be verified using `or` semantic

[*Result]: static assert with `PARAMETER_NOT_PERMITTED` message or clean compilation.

[heading Header]
    #include <__di_hpp__>

[heading Namespace]
    boost::di::policies

[heading Examples]
    using namespace di::policies;

    __di_make_injector__().__di_injector_create__<int>(parameters_permission<>()); // compile error, no parameters are allowed
    __di_make_injector__().__di_injector_create__<int>(parameters_permission<allow_copies>()); // compile ok

    struct example {
        example(std::vector<int*>, std::shared_ptr<int>, const int&);
    };

    // Parameters
    //    * std::vector<int*> -> allow_copies
    //        * int* -> allow_ptrs
    //    * std::shared_ptr<int> -> allow_smart_ptrs
    //    * const int& -> allow_const_refs

    __di_make_injector__().__di_injector_create__<example>(
        parameters_permission<allow_copies, allow_ptrs, allow_smart_ptrs, allow_const_refs>()
    ); // compile ok

[warning `Parameters Permission` policy is not supported by Microsoft Visual Studio.]

[heading Tests]
    ``[@test/ut/policies/parameters_permission_ut.cpp]``

[heading See Also]

* __policies__
* __policies_circular_dependencies__
* __policies_creation_permission__
* __policies_scopes_permission__

[heading Description]
Limits allowed scopes to be used whilst binding. By default, if used, all scopes are disallowed.

[heading Allow Scope Model]
    template<class TScope>
    class allow_scope_model {
    public:
        template<class T>
        struct allow; // returns boolean expression
    };

[table Parameters
    [[Parameter][Requirement][Description][Throw]]
    [[`TScope`][__scope_model__][Scope to be allowed]]
    [[`T`][None][__data_model__ type]]
    [[`assert_policy()`][None][Verify policy requirements][Does not throw]]
]

[heading Synopsis]
    template<class TScope>
    struct allow_scope;

    template<>
    struct allow_scope<scopes::deduce>; // disabled

    template<class... TArgs>
    class scopes_permission {
    public:
        template<class TDependency>
        void assert_policy() const;
    };

[table Parameters
    [[Parameter][Requirement][Description][Throw]]
    [[`TScope`][__scope_model__ type][Scope to be allowed]]
    [[`TArgs...`][__allow_scope_model__ type][Scopes to be allowed]]
    [[`T`][__data_model__ type][Data to be verified]]
    [[`assert_policy()`][None][Verify policy requirements][Does not throw]]
]

[heading Expression Semantics]
    using namespace di::policies;
    scopes_permission<
        allow_scope<__di_scopes_unique__<>>
      , allow_scope<__di_scopes_shared__<>>
      , allow_scope<__di_scopes_session__<>>
      , allow_scope<__di_scopes_external__<>>
    >() // TArgs will be verified using `or` semantic

[note `allow_scope<scopes::__scopes_deduce__>` is not allowed.]

[*Result]: static assert with `SCOPE_NOT_PERMITTED` message or clean compilation.

[heading Header]
    #include <__di_hpp__>

[heading Namespace]
    boost::di::policies

[heading Examples]
    using namespace di::policies;

    __di_make_injector__().__di_injector_create__<int>(scopes_permission<>()); // compile error, no scopes are allowed

    __di_make_injector__(
        __di_bind_unique__<int>()
    ).__di_injector_create__<int>(scopes_permission<allow_scope<__di_scopes_unique__<>>>()); // compile ok

    __di_make_injector__(
        __di_bind_shared__<int>()
    ).__di_injector_create__<int>(scopes_permission<allow_scope<__di_scopes_unique__<>>>()); // compile error

    struct example {
        example(std::shared_ptr<int>);
    };

    __di_make_injector__(
        __di_bind_deduce__<int>()
    ).__di_injector_create__<example>(scopes_permission<allow_scope<__di_scopes_unique__<>>>()); // compile error

    struct example {
        example(int);
    };

    __di_make_injector__(
        __di_bind_deduce__<int>()
    ).__di_injector_create__<example>(scopes_permission<allow_scope<__di_scopes_unique__<>>>()); // compile ok

[note To read more about `scope deduction` mapping see __scopes_deduce__.]

[heading Tests]
    ``[@test/ut/policies/scopes_permission_ut.cpp]``

[heading See Also]

* __policies__

[endsect]

[endsect]

