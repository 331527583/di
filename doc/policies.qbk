[/
 /
 / Copyright (c) 2014 Krzysztof Jusiak (krzysztof at jusiak dot net)
 /
 / Distributed under the Boost Software License, Version 1.0.
 / (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /
 /]

[section Policies]

[heading Description]
Policies are compile time components operates on dependencies in order to limit allowed behaviour.
Policy has to have `assert_policy` method defined.
In order for `injector` to verify policies they have to be passed to `create`, `allocate` call.
`Boost.DI` is released with following policies

* __policies_circular_dependencies__ - verify circular dependencies occurrence
* __policies_creation_ownership__  - verify objection creation permission
* __policies_parameters_permission__ - verify constructor parameters permission
* __policies_scopes_permission__ - verify scopes configuration permission

[note By Default `Boost.DI` has no policies enabled.]

[heading Synopsis]
    class policy {
    public:
        template<typename TDependency>
        void assert_policy() const;
    };

[table Parameters
    [[Parameter][Requirement][Description]]
    [[`TDependency`][__dependency_model__ type][dependency to be verified]]
]

[heading Namespace]
    boost::di::policies

[heading Examples]
    di::__injectors_make_injector__().create<int>(policy1(), policy2(), ..., policyN());
    di::__injectors_make_injector__().allocate<int>(allocator(), policy1(), policy2(), ..., policyN());


[heading More Examples]
    ``__examples_custom_policy__``

[section circular_dependencies]

[heading Description]
Verifies constructor parameters overlapping.

[heading Synopsis]
    class circular_dependencies {
    public:
        template<typename TDependency>
        void assert_policy() const;
    };

[table Parameters
    [[Parameter][Requirement][Description]]
    [[`TDependency`][__dependency_model__ type][dependency to be verified]]
]

[heading Expression Semantics]
    di::policies::circular_dependencies()

[*Result]: `static assert with CIRCULAR_DEPENDENCIES_ARE_NOT_ALLOWED messge or clean compilation`

[heading Header]
    #include <boost/di.hpp>

[heading Namespace]
    boost::di::policies

[heading Examples]
    di::__injectors_make_injector__().create<int>(di::policies::circular_dependencies()); // compile ok

    struct cd2;
    struct cd1 { cd1(cd2*); };
    struct cd2 { cd2(cd1*); };

    di::__injectors_make_injector__().create<cd1>(di::policies::circular_dependencies()); // compile error

[note Requires `BOOST_DI_CFG_EXAMINE_CALL_STACK` to be defined.]

[heading Tests]
    ``[@test/ut/policies/circular_dependencies_ut.cpp]``

[heading See Also]

* __policies__
* __policies_creation_ownership__
* __policies_parameters_permission__
* __policies_scopes_permission__

[endsect]

[section creation_ownership]

[heading Description]
Limits creation types to copies/pointers/smart pointers and disallow references.

[heading Synopsis]
    class creation_ownership {
    public:
        template<typename TDependency>
        void assert_policy() const;
    };

[table Parameters
    [[Parameter][Requirement][Description]]
    [[`TDependency`][__dependency_model__ type][dependency to be verified]]
]

[heading Expression Semantics]
    di::policies::creation_ownership()

[*Result]: `static assert with CREATION_OWNERSHIP_IS_NOT_CLEAR message or clean compilation`

[heading Header]
    #include <boost/di.hpp>

[heading Namespace]
    boost::di::policies

[heading Examples]
    di::__injectors_make_injector__().create<int>(di::policies::creation_ownership()); // compile ok
    di::__injectors_make_injector__().create<const int&>(di::policies::creation_ownership()); // compile error
    di::__injectors_make_injector__().create<int&>(di::policies::creation_ownership()); // compile error

[note Requires `BOOST_DI_CFG_EXAMINE_CALL_STACK` to be defined.]

[heading Tests]
    ``[@test/ut/policies/creation_ownership_ut.cpp]``

[heading See Also]

* __policies__
* __policies_circular_dependencies__
* __policies_parameters_permission__
* __policies_scopes_permission__

[endsect]

[section parameters_permission]

[heading Description]
Limits allowed constructor parameters. By default, if used, all parameters are disallowed.

[heading Allow Parameter Model]
    template<typename TParameter>
    class allow_parameter_model {
    public:
        template<typename T>
        struct allow; // returns Boolean expression
    };

[table Parameters
    [[Parameter][Requirement][Description]]
    [[`TParameter`][None][Parameter to be allowed]]
    [[`T`][None][Dependency parameter type]]
]

[heading Synopsis]
    struct allow_smart_ptrs;
    struct allow_refs;
    struct allow_const_refs;
    struct allow_rvalue_refs;
    struct allow_ptrs;
    struct allow_copies;

    template<typename... TArgs>
    class parameters_permission {
    public:
        template<typename TDependency>
        void assert_policy() const;
    };

[table Parameters
    [[Parameter][Requirement][Description]]
    [[`TArgs...`][__allow_parameter_model__ type][Parameters to be allowed]]
    [[`TDependency`][__dependency_model__ type][dependency to be verified]]
]

[heading Expression Semantics]
    using namespace di::policies;
    parameters_permission<allow_refs, allow_smart_ptrs, ..., allow_copies>()

[*Result]: `static assert with PARAMETER_NOT_PERMITTED message or clean compilation`

[heading Header]
    #include <boost/di.hpp>

[heading Namespace]
    boost::di::policies

[heading Examples]
    using namespace di::policies;

    di::__injectors_make_injector__().create<int>(parameters_permission<>()); // compile error, no parameters are allowed
    di::__injectors_make_injector__().create<int>(parameters_permission<allow_copies>()); // compile ok

    struct example {
        example(std::vector<int*>, std::shared_ptr<int>, const int&);
    };

    // Parameters
    //    * std::vector<int*> -> allow_copies
    //        * int* -> allow_ptrs
    //    * std::shared_ptr<int> -> allow_smart_ptrs
    //    * const int& -> allow_const_refs

    di::__injectors_make_injector__().create<example>(
        parameters_permission<allow_copies, allow_ptrs, allow_smart_ptrs, allow_const_refs>()
    ); // compile ok

[warning `Parameters Permission` policy is not supported by Microsoft Visual Studio.]

[heading Tests]
    ``[@test/ut/policies/parameters_permission_ut.cpp]``

[heading See Also]

* __policies__
* __policies_circular_dependencies__
* __policies_creation_ownership__
* __policies_scopes_permission__

[endsect]

[section scopes_permission]

[heading Description]
Limits allowed scopes to be used whilst binding.  By default, if used, all scopes are disallowed.

[heading Allow Scope Model]
    template<typename TScope>
    class allow_scope_model {
    public:
        template<typename T>
        struct allow; // returns Boolean expression
    };

[table Parameters
    [[Parameter][Requirement][Description]]
    [[`TScope`][__scope_model__][Scope to be allowed]]
    [[`T`][None][Dependency scope]]
]

[heading Synopsis]
    template<typename TScope>
    struct allow_scope;

    template<>
    struct allow_scope<scopes::deduce>; // disabled

    template<typename... TArgs>
    class scopes_permission {
    public:
        template<typename TDependency>
        void assert_policy() const;
    };

[table Parameters
    [[Parameter][Requirement][Description]]
    [[`TScope`][__scope_model__ type][scope to be allowed]]
    [[`TArgs...`][__allow_scope_model__ type][Scopes to be allowed]]
    [[`TDependency`][__dependency_model__ type][dependency to be verified]]
]

[heading Expression Semantics]
    using namespace di::policies;
    scopes_permission<
        allow_scope<scopes::__scopes_unique_scope__<>>
      , allow_scope<scopes::__scopes_shared_scope__<>>
      , allow_scope<scopes::__scopes_session_scope__<>>
      , allow_scope<scopes::__scopes_external_scope__<>>
    >()

[note `allow_scope<scopes::__scopes_deduce__>` is not allowed.]

[*Result]: `static assert with SCOPE_NOT_PERMITTED message or clean compilation`

[heading Header]
    #include <boost/di.hpp>

[heading Namespace]
    boost::di::policies

[heading Examples]
    using namespace di::policies;

    di::__injectors_make_injector__().create<int>(scopes_permission<>()); // compile error, no scopes are allowed

    di::__injectors_make_injector__(
        di::__bindings_scope_unique__<int>()
    ).create<int>(scopes_permission<allow_scope<di::scopes::__scopes_unique_scope__<>>>()); // compile ok

    di::__injectors_make_injector__(
        di::__bindings_scope_shared__<int>()
    ).create<int>(scopes_permission<allow_scope<di::scopes::__scopes_unique_scope__<>>>()); // compile error

    struct example {
        example(std::shared_ptr<int>);
    };

    di::__injectors_make_injector__(
        di::__bindings_deduce__<int>()
    ).create<example>(scopes_permission<allow_scope<di::scopes::__scopes_unique_scope__<>>>()); // compile error

    struct example {
        example(int);
    };

    di::__injectors_make_injector__(
        di::__bindings_deduce__<int>()
    ).create<example>(scopes_permission<allow_scope<di::scopes::__scopes_unique_scope__<>>>()); // compile ok

[note To read more about `scope deduction` mapping see __scopes_deduce__.]

[heading Tests]
    ``[@test/ut/policies/scopes_permission_ut.cpp]``

[heading See Also]

* __policies__
* __policies_circular_dependencies__
* __policies_creation_ownership__
* __policies_parameters_permission__

[endsect]

[endsect]

