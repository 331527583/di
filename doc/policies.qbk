[/
 /
 / Copyright (c) 2014 Krzysztof Jusiak (krzysztof at jusiak dot net)
 /
 / Distributed under the Boost Software License, Version 1.0.
 / (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /
 /]

[section Policies]

[heading Description]
Policies are compile time components operates on dependencies in order to limit allowed behaviour or visit created types during run-time.
Policy has to be callable with at least one given type.

`Boost.DI` is released with following policies
* __policies_allow_ctor_types__ - limit constructor parameters

[note By Default `Boost.DI` has no policies enabled.]

[heading Synopsis]
    class policy_simple {
    public:
        template<class T>
        void operator()(T) const noexcept;
    };

    class policy_extended {
    public:
        template<class T, class TDependency, class... TCtor>
        void operator()(T, TDependency, TCtor...) const noexcept;
    };

[table Parameters
    [[Parameter][Requirement][Description][Throw]]
    [[`T`][None][Constructor parameter type]]
    [[`TDependency`][__dependency_model__][Dependency used to resolve object]]
    [[`TCtor...`][None][Constructor parameters]]
    [[`operator()`][None][Verify policy requirements][Does not throw]]
]

[note In order for __injectors_injector__ to verify policies they have to be passed using __di_config__ into __injectors_injector__ (per injector) or defined globally.]

[heading Namespace]
    boost::di::policies

[heading Examples]
[table
[[Define policies configuration (dump types)][]]
    [
        [
            ```
            class print_types_policy : public __di_config__ {
            public:
                auto policies() const noexcept {
                    return __di_make_policies__(
                        [](auto type){
                            using T = decltype(type);
                            using arg = typename T::type;
                            cout << typeid(arg).name() << endl;
                        }
                    );
                }
            };
                                                                                               .
            ```
        ]
        [
            ```
            // per injector policy
            auto injector = __di_make_injector__<print_types_policy>();
            injector.__di_injector_create__<int>(); // output: int

            // global policy
            #define BOOST_DI_CFG my_policy
            auto injector = __di_make_injector__();
            injector.__di_injector_create__<int>(); // output: int
                                                                                                                       .
            ```
        ]
    ]
]

[table
[[Define policies configuration (dump types extended)][]]
    [
        [
            ```
            class print_types_info_policy : public __di_config__ {
            public:
                auto policies() const noexcept {
                    return __di_make_policies__(
                        [](auto type, auto dep, auto... ctor) {
                            using T = decltype(type);
                            using arg = typename T::type;
                            using arg_name = typename T::name;
                            using D = decltype(dep);
                            using scope = typename D::scope;
                            using expected = typename D::expected;
                            using given = typename D::given;
                            using name = typename D::name;
                            auto ctor_s = sizeof...(ctor);

                            cout << ctor_s << endl
                                << typeid(arg).name() << endl
                                << typeid(arg_name).name() << endl
                                << typeid(scope).name() << endl
                                << typeid(expected).name() << endl
                                << typeid(given).name() << endl
                                << typeid(name).name() << endl;
                        }
                    )
                }
            };
                                                                                               .
            ```
        ]
        [
            ```
            // per injector policy
            auto injector = __di_make_injector__<print_types_info_policy>(
                __di_bind__<i1, impl1>
            );

            injector.__di_injector_create__<unique_ptr<i1>>();
                // output:
                0 // ctor_size of impl1
                unique_ptr<i1> // ctor arg
                di::no_name // ctor arg name
                __di_scopes_deduce__ // scope
                i1 // expected
                impl1 // given
                no_name // dependency

            // global policy
            #define BOOST_DI_CFG my_policy
            auto injector = __di_make_injector__(
                __di_bind__<i1, impl1>
            );

            injector.__di_injector_create__<unique_ptr<i1>>();
                // output:
                0 // ctor_size of impl1
                unique_ptr<i1> // cotr arg
                di::no_name // ctor arg name
                __di_scopes_deduce__ // scope
                i1 // expected
                impl1 // given
                no_name // dependency
                                                                                                                       .
            ```
        ]
    ]
]

[heading More Examples]
    ``__examples_custom_policy__``

[heading See Also]

* __policies_allow_ctor_types__

[section allow_ctor_types]

[heading Description]
Limits constructor parameters to explicitly allowed. 
[note By default `allow_ctor_types` policy disables creation of any constructor parameters.]

[heading Synopsis]
    template<class T>
    inline auto allow_ctor_types(const T&);

    struct _ { }; // placeholder

    template<class T, class TName = no_name>
    struct is_bound; // is type explicitly bound using __bindings__

    struct is_root; // is type a request type (create<c>() -> is_root<c>{} = true)

    template<class X>
    inline auto operator!(const X&)

    template<class X, class Y>
    inline auto operator&&(const X&, const Y&);

    template<class X, class Y>
    inline auto operator||(const X&, const Y&);

[table Parameters
    [[Parameter][Requirement][Description]]
    [[`TArgs...`][__allow_type_model__ type][Type to be allowed]]
    [[`T`][Type is convertible to bool][Policy configuration, might be combined using provided logic operators (!, &&, ||)]]
    [[`TName`][None][Type name]]
    [[`X, Y`][Type is convertible to bool][Input types for operators]]
]

[heading Expression Semantics]
    allow_ctor_types(T)
    is_bound<_>{} | is_bound<int, name>{} | is_root{}

[*Result]: static assert with "`Type T is not allowed`" message or clean compilation.

[heading Header]
    #include <__di_hpp__>

[heading Namespace]
    boost::di::policies
    boost::di::policies::operators // for logic operators to be supported

[warning Logic operators will works only when `using boost::di::policies::operators` will be defined.]

[heading Examples]
[table
[[Allow ctor types policy][]]
    [
        [
            ```
            #include <boost/di/policies/allow_ctor_types.hpp>

            class all_must_be_bound_unless_int : public __di_config__ {
            public:
                auto policies() const noexcept {
                    using namespace di::policies;
                    using namespace di::policies::operators; // to support logic operators

                    return __di_make_policies__(
                        allow_ctor_types(is_same<_, int>{} || is_bound<_>{})
                    );
                }
            };
                                                                                               .
            ```
        ]
        [
            ```
            // global policy
            #define BOOST_DI_CFG all_must_be_bound_unless_int
            assert(0 == injector.__di_injector_create__<int>());
            injector.__di_injector_create__<double>(); // compile error
            assert(42.0, 
                make_injector(
                    __di_bind__<double>.to(42.0)
                ).__di_injector_create__<double>()
            );
                                                                                                                       .
            ```
        ]
    ]
]

[tip STL type traits are supported and might be combined with `Boost.DI` traits in order to limit constructor types ex. `std::is_same<_, int>{} || std::is_constructible<_, int, int>{} || std::is_base_of<int, _>{}`, etc...]

[heading See Also]

* __policies__

[endsect]

[endsect]

