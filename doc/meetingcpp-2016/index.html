<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>TDD/BDD and Dependency Injection</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/league.css" id="theme">

		<!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>

	<body>

		<div class="reveal">
			<div class="slides">
          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$"
                   data-notes="^Note:">
					<script type="text/template">

Meeting C++ 2016

#TDD/BDD and Dependency Injection

Kris Jusiak

---

[kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)

==============================================================================

##Testing

> "If you liked it then you should have put a test on it", Beyonce rule

-----

##TDD - Test Driven Development (the when)

> Unit Tests (the what)

----

##TDD Mantra - Red-Green-Refactor

<img src="images/tdd.gif" width="40%" />

> Refactor => remove duplicates!

----

##BDD - Behaviour Driven Development

> Unit/Integration/Functional Tests (the how)

==============================================================================

##Dependency Injection

> "Don't call us, we'll call you", Hollywood principle

----

## It's all about the construction!

####No DI
```cpp
coffee_maker()                          
  : heater(make_shared<electric_heater>()) // construct dependencies
  , pump(make_unique<heat_pump>(heater))  
{ }                                     
```

####DI
```cpp
coffee_maker(shared_ptr<iheater> heater // inject dependencies
           , unique_ptr<ipump> pump)
  : heater(heater)
  , pump(move(pump))
{ }
```

==============================================================================

##TDD By Example

----

##0. Use Case

> Let's make some coffee!

![coffee_maker](images/coffee_maker.png)

----

##Usual approach

----

##1. Make a brew (test)

```cpp
"when brew then heat and pump coffee"_test = [] {
  StrictMock<heater_mock> heater;
  StrictMock<pump_mock> pump;
  coffee_maker cm{heater, pump};

  EXPECT_CALL(heater, on());
  EXPECT_CALL(pump, pump());
  EXPECT_CALL(heater, off());

  cm.brew();
};
```

----

##2. Create coffee_maker stub

```cpp
class coffee_maker {
public:
  coffee_maker(iheater&, ipump&);
  void brew();
};
```

----

##3. Create `iheater` interface

```cpp
struct iheater {
  virtual ~iheater() noexcept = default;
  virtual void on() = 0;
  virtual void off() = 0;
};
```

----

##4. Create `iheater` mock (gmock)

```cpp
struct heater_mock : iheater {
  MOCK_METHOD0(on, void());
  MOCK_METHOD0(off, void());
};
```

----

##5. Create `ipump` interface

```cpp
struct ipump {
    virtual ~ipump() noexcept = default;
    virtual void pump() = 0;
};
```

----

##6. Create `ipump` mock

```cpp
struct pump_mock : imock {
  MOCK_METHOD0(pump, void());
};
```

----

##Test is compiling but not passing... (Red)

----

##7. Write the simplest implementation

```cpp
void coffee_maker::brew() {
  heater.on();
  pump.pump();
  heater.off();
}
```

----

##Test is passing... (Green)

###7 steps

----

##Refactor

> No duplicates yet

----

##DI + mocks injector approach

----

##1. Make a brew (test)

```cpp
"when brew then heat and pump coffee"_test = [] {
  auto cm = di::make_injector().create<coffee_maker>();

  Verify(Method(mock<iheater>, on));
  Verify(Method(mock<ipump>, pump));
  Verify(Method(mock<iheater>, off));

  cm.brew();
};
```

----

##2. Create coffee_maker stub

###As before...

```cpp
class coffee_maker {
public:
  coffee_maker(iheater&, ipump&);
  void brew();
};
```

----

##3. Create `iheater` interface

###As before...

```cpp
struct iheater {
  virtual ~iheater() noexcept = default;
  virtual void on() = 0;
  virtual void off() = 0;
};
```

----

##4. Create `ipump` interface

###As before...

```cpp
struct ipump {
    virtual ~ipump() noexcept = default;
    virtual void pump() = 0;
};
```

----

##Test is compiling but not passing... (Red)

----

##5. Write the simplest implementation

###As before...

```cpp
void coffee_maker::brew() {
  heater.on();
  pump.pump();
  heater.off();
}
```

----

##Test is passing... (Green)

###5 steps

----

##Refactor

###As Before...

--- 

> No duplicates yet

----

##Usual appraoch vs DI + mocks injector approach

# 5 < 7

----

##But what if...?

###Coffee Maker Constructor

```cpp
coffee_maker(iheater&, ipump&);
```

```cpp
1. Usual: coffee_maker cm{heater_mock{}, pump_mock{}}; 
2. DI:    auto cm = make_injector().create<coffee_maker>();
```

----

###Will have a new filter dependency?

```cpp
coffee_maker(iheater&, ipump&, ifilter&); 
```

```cpp
3. Usual: coffee_maker cm{heater_mock{}, pump_mock{}, filter_mock{}}; 
4. DI:    same as in line 2!
```

----

###Will change the constructor order?

```cpp
coffee_maker(ipump&, iheater&, ifilter&);
```

```cpp
5. Usual: coffee_maker cm{pump_mock{}, heater_mock{}, filter_mock{}}; 
6. DI:    same as in line 2!
```

==============================================================================

##BDD By Example

----

##Use case

>Let's make a match-3 game and swipe items

![game](images/game.png)

----

###Usual approach (Integration/Functional tests)

```cpp
"given: player has 1 move, when: swipe, then: no moves"_test = [] {
  StrictMock<canvas_mock> canvas;
  Config config{8/*width*/, 10/*height*/, 1/*moves*/};
  Board board{config, {{3,5,1,4,3,2,2, ...}}};
  Contoller controller{config, board};
  Game game{controller, canvas};

  EXPECT(canvas, show_moves(1));
  EXPECT(canvas, show_board({3,5,1,4,3,2,2...}));
  game.start();

  EXPECT(canvas, show_moves(0));
  EXPECT(canvas, show_board({5,2,1,1,4,2,2...});
  game.swipe({3, 5}, {3, 6});
};
```

----

###Integration/Functional Testing with DI

```cpp
"given: player has 1 move, when: swipe, then: no moves"_test = [] {
  const auto injector = di::make_injector<mocks_provider>(
     di::bind<>.to(config{8/*width*/, 10/*height*/, 1/*moves*/})
   , di::bind<colors_t[]>.to({3,5,1,4,3,2,2, ...})
  );
  auto game = injector.create<Game>();

  Verify(Method(mock<icanvas>, show_moves).Using(1);
  Verify(Method(mock<icanvas>, show_board).Using({3,5,1,4,3,2,2...});
  game.start();

  Verify(Method(mock<icanvas>, show_moves).Using(0);
  Verify(Method(mock<icanvas>, show_board).Using({5,2,1,1,4,2,2...});
  game.swipe({3, 5}, {3, 6});
```

----

##But what if...?

###Anything in the following diagram will change?
<img src="images/game.png" width="20%" />

| Usual appraoch | DI + mocks injector approach |
| - | - |
| BOOM!!! | No changes in the test required! |

==============================================================================

##Brought you by...

----

##Boost.DI (Proposed)

> Dependency Injection Library

https://github.com/boost-experimental/di

---

* One header - 3k LOC - (boost/di.hpp) / generated
* Neither Boost nor STL is required
* No 'if's, 'virtual', 'exceptions' (-fno-rtti, -fno-exceptions)
* Non-intrusive, no run-time overhead
* Quick compilation times and short error messages
* Supported compilers (C++14)
  * [Clang-3.4+](https://travis-ci.org/boost-experimental/di), [XCode-6.1+](https://travis-ci.org/boost-experimental/di), [GCC-5.2+](https://travis-ci.org/boost-experimental/di), [MSVC-2015+](https://ci.appveyor.com/project/krzysztof-jusiak/di)

----

##Boost.DI - Hello World

```cpp
#include <boost/di.hpp>
namespace di = boost::di;
```

```cpp
struct iworld { virtual ~iworld() noexcept = default; };
struct world : iworld {};
struct ihello { virtual ~ihello() noexcept = default; };
struct hello : ihello {};
```

```cpp
struct hello_world {
  hello_world(const ihello&, const iworld&); // DI handles order
};                  ^              ^         // and types
                    |              \------------\
                    \----------------------\    |
int main() {                               |    |
  const auto injector = di::make_injector( |    |
     di::bind<ihello>.to<hello>() ---------/    |
   , di::bind<iworld>.to<world>() -------------/
  );

  auto hw = injector.create<hello_world>();
}
```

----

##Boost.DI vs Java

|    | **Boost.DI** | **Guice** | **Dagger2** |
| ------------------- | ------------ | ---------------- | ------------- |
| Language    | C++14    | Java | Java |
| Errors      | compile-time | exceptions (reflection) | compile-time (annotations) |
| [Test - 64 unique types](http://boost-experimental.github.io/di/benchmarks/index.html) | | | |
| Compilation time    | 0.376s       |  0.570s            | 1.411s        |
| Execution time      | 0.002s       |  0.528s            | 0.157s        |

----

##FakeIt

> Mocking library

https://github.com/eranpeer/FakeIt

---

* Not standard, depening on vtable layout
* Supported compilers (C++11)
  * GCC/Clang/MSVC

----

##Automatic mocks injector

> Create and inject mocks automatically with Boost.DI and FakeIt!

----

##Automatic mocks injector

```cpp
class app {
 public:
  app(const interface& i) {
    assert(i.update());
  }
};
```

```cpp
"update app"_test = [] {
  // create injector with mocks provider
  const auto injector = di::make_injector<mocks_provider>();

  // get the mock to setup expectations
  When(Method(mock<interface>, update)).AlwaysReturn(true);

  // create an app and inject all dependencies
  injector.create<app>();
};
```

----

##Mocks Provider - Implementation

```cpp
template <class T>
static auto& mock() {
  static fakeit::Mock<T> mock;
  return mock;
}

struct mocks_provider {
  template <class T, class... TArgs>
  auto get(TArgs&&... args) const {
    if constexpr(std::is_polymorphic<T>{}) {
      return mock<T>();
    } else {
      return make_unique<T>(std::forward<TArgs>(args)...);
    }
  }
};
```

==============================================================================

##Summary

----

###Less work is better than more work

----

###Think large scale
> * x1000 more work in big projects
> * Treat testing code as production code!

----

###Potenitally Non-functional changes cause tests modifications

> * Tedious changes
  * Leads into an argument that unit-testing are pointless

----

###Wiring mess

> * Boilerplate code
  * Hard to maintain
    * Order of initializing dependencies is important
  * Usually leads into a bad design
    * Breaks Single Responsibily Principle as it's easier to do a workaround

==============================================================================

##Questions?

|   |   |
| - | - |
| Boost.DI | https://github.com/boost-experimental/di |
| FakeIt   | https://github.com/eranpeer/FakeIt |

-

> * [kris@jusiak.net](mailto:kris@jusiak.net)
* [@krisjusiak](https://twitter.com/krisjusiak)
* [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)

==============================================================================

##Bonus - Simplest test framework

----

####Implementation
```cpp
template <char...>
struct test {
  template <class Test>
  auto operator=(const Test& test) { test(); return true; }
};

template <class T, T... Chars> // GNU extension for now, maybe in C++20
constexpr auto operator""_test() {
  return test<Chars...>{};
}
```

####Usage
```cpp
"first test" = [] {
  assert(0 == 0);
};

"second test" = [] {
  assert(1 == 0);
};
```
					</script>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({

        // Display controls in the bottom right corner
        controls: true,

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: true,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'convex', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
